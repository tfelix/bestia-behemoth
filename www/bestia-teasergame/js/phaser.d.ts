declare type CallCallback = (item: Phaser.GameObjects.GameObject)=>void;

declare type GridAlignConfig = {
    /**
     * The width of the grid in items (not pixels). -1 means lay all items out horizontally, regardless of quantity.
     *                                  If both this value and height are set to -1 then this value overrides it and the `height` value is ignored.
     */
    width?: integer;
    /**
     * The height of the grid in items (not pixels). -1 means lay all items out vertically, regardless of quantity.
     *                                   If both this value and `width` are set to -1 then `width` overrides it and this value is ignored.
     */
    height?: integer;
    /**
     * The width of the cell, in pixels, in which the item is positioned.
     */
    cellWidth?: boolean;
    /**
     * The height of the cell, in pixels, in which the item is positioned.
     */
    cellHeight?: integer;
    /**
     * The alignment position. One of the Phaser.Display.Align consts such as `TOP_LEFT` or `RIGHT_CENTER`.
     */
    position?: integer;
    /**
     * Optionally place the top-left of the final grid at this coordinate.
     */
    x?: number;
    /**
     * Optionally place the top-left of the final grid at this coordinate.
     */
    y?: number;
};

declare type JSONAnimation = {
    /**
     * [description]
     */
    key: string;
    /**
     * A frame based animation (as opposed to a bone based animation)
     */
    type: string;
    /**
     * [description]
     */
    frames: JSONAnimationFrame[];
    /**
     * The frame rate of playback in frames per second (default 24 if duration is null)
     */
    frameRate: integer;
    /**
     * How long the animation should play for in milliseconds. If not given its derived from frameRate.
     */
    duration: integer;
    /**
     * Skip frames if the time lags, or always advanced anyway?
     */
    skipMissedFrames: boolean;
    /**
     * Delay before starting playback. Value given in milliseconds.
     */
    delay: integer;
    /**
     * Number of times to repeat the animation (-1 for infinity)
     */
    repeat: integer;
    /**
     * Delay before the animation repeats. Value given in milliseconds.
     */
    repeatDelay: integer;
    /**
     * Should the animation yoyo? (reverse back down to the start) before repeating?
     */
    yoyo: boolean;
    /**
     * Should sprite.visible = true when the animation starts to play?
     */
    showOnStart: boolean;
    /**
     * Should sprite.visible = false when the animation finishes?
     */
    hideOnComplete: boolean;
};

declare type AnimationFrameConfig = {
    /**
     * [description]
     */
    key: string;
    /**
     * [description]
     */
    frame: string | number;
    /**
     * [description]
     */
    duration?: number;
    /**
     * [description]
     */
    visible?: boolean;
};

declare type AnimationConfig = {
    /**
     * [description]
     */
    frames?: AnimationFrameConfig[];
    /**
     * [description]
     */
    defaultTextureKey?: string;
    /**
     * The frame rate of playback in frames per second (default 24 if duration is null)
     */
    frameRate?: integer;
    /**
     * How long the animation should play for in milliseconds. If not given its derived from frameRate.
     */
    duration?: integer;
    /**
     * Skip frames if the time lags, or always advanced anyway?
     */
    skipMissedFrames?: boolean;
    /**
     * Delay before starting playback. Value given in milliseconds.
     */
    delay?: integer;
    /**
     * Number of times to repeat the animation (-1 for infinity)
     */
    repeat?: integer;
    /**
     * Delay before the animation repeats. Value given in milliseconds.
     */
    repeatDelay?: integer;
    /**
     * Should the animation yoyo? (reverse back down to the start) before repeating?
     */
    yoyo?: boolean;
    /**
     * Should sprite.visible = true when the animation starts to play?
     */
    showOnStart?: boolean;
    /**
     * Should sprite.visible = false when the animation finishes?
     */
    hideOnComplete?: boolean;
};

declare type JSONAnimationFrame = {
    /**
     * The key of the Texture this AnimationFrame uses.
     */
    key: string;
    /**
     * The key of the Frame within the Texture that this AnimationFrame uses.
     */
    frame: string | integer;
    /**
     * Additional time (in ms) that this frame should appear for during playback.
     */
    duration: number;
};

declare type JSONAnimationManager = {
    /**
     * [description]
     */
    anims: JSONAnimation[];
    /**
     * [description]
     */
    globalTimeScale: number;
};

declare type GenerateFrameNamesConfig = {
    /**
     * [description]
     */
    prefix?: string;
    /**
     * [description]
     */
    start?: integer;
    /**
     * [description]
     */
    end?: integer;
    /**
     * [description]
     */
    suffix?: string;
    /**
     * [description]
     */
    zeroPad?: integer;
    /**
     * [description]
     */
    outputArray?: AnimationFrameConfig[];
    /**
     * [description]
     */
    frames?: boolean;
};

declare type GenerateFrameNumbersConfig = {
    /**
     * [description]
     */
    start?: integer;
    /**
     * [description]
     */
    end?: integer;
    /**
     * [description]
     */
    first?: boolean;
    /**
     * [description]
     */
    outputArray?: AnimationFrameConfig[];
    /**
     * [description]
     */
    frames?: boolean;
};

/**
 * This callback type is completely empty, a no-operation.
 */
declare type NOOP = ()=>void;

declare type BootCallback = (game: Phaser.Game)=>void;

declare type FPSConfig = {
    /**
     * [description]
     */
    min?: integer;
    /**
     * [description]
     */
    target?: integer;
    /**
     * [description]
     */
    forceSetTimeOut?: boolean;
    /**
     * [description]
     */
    deltaHistory?: integer;
    /**
     * [description]
     */
    panicMax?: integer;
};

declare type LoaderConfig = {
    /**
     * [description]
     */
    baseURL?: string;
    /**
     * [description]
     */
    path?: string;
    /**
     * [description]
     */
    enableParallel?: boolean;
    /**
     * [description]
     */
    maxParallelDownloads?: integer;
    /**
     * [description]
     */
    crossOrigin?: string | undefined;
    /**
     * [description]
     */
    responseType?: string;
    /**
     * [description]
     */
    async?: boolean;
    /**
     * [description]
     */
    user?: string;
    /**
     * [description]
     */
    password?: string;
    /**
     * [description]
     */
    timeout?: integer;
};

declare type GameConfig = {
    /**
     * [description]
     */
    width?: integer | string;
    /**
     * [description]
     */
    height?: integer | string;
    /**
     * [description]
     */
    zoom?: number;
    /**
     * [description]
     */
    resolution?: number;
    /**
     * [description]
     */
    type?: number;
    /**
     * [description]
     */
    parent?: any;
    /**
     * [description]
     */
    canvas?: HTMLCanvasElement;
    /**
     * [description]
     */
    canvasStyle?: string;
    /**
     * [description]
     */
    scene?: object;
    /**
     * [description]
     */
    seed?: string[];
    /**
     * [description]
     */
    title?: string;
    /**
     * [description]
     */
    url?: string;
    /**
     * [description]
     */
    version?: string;
    /**
     * [description]
     */
    input?: boolean | object;
    /**
     * [description]
     */
    "input.keyboard"?: boolean;
    /**
     * [description]
     */
    "input.keyboard.target"?: any;
    /**
     * [description]
     */
    "input.mouse"?: boolean | object;
    /**
     * [description]
     */
    "input.mouse.target"?: any;
    /**
     * [description]
     */
    "input.touch"?: boolean;
    /**
     * [description]
     */
    "input.touch.target"?: any;
    /**
     * [description]
     */
    "input.touch.capture"?: boolean;
    /**
     * [description]
     */
    "input.gamepad"?: boolean | object;
    /**
     * [description]
     */
    disableContextMenu?: boolean;
    /**
     * [description]
     */
    banner?: boolean | object;
    /**
     * [description]
     */
    "banner.hidePhaser"?: boolean;
    /**
     * [description]
     */
    "banner.text"?: string;
    /**
     * [description]
     */
    "banner.background"?: string[];
    /**
     * [description]
     */
    fps?: FPSConfig;
    /**
     * [description]
     */
    antialias?: boolean;
    /**
     * [description]
     */
    pixelArt?: boolean;
    /**
     * [description]
     */
    autoResize?: boolean;
    /**
     * [description]
     */
    roundPixels?: boolean;
    /**
     * [description]
     */
    transparent?: boolean;
    /**
     * [description]
     */
    clearBeforeRender?: boolean;
    /**
     * [description]
     */
    premultipliedAlpha?: boolean;
    /**
     * [description]
     */
    preserveDrawingBuffer?: boolean;
    /**
     * [description]
     */
    failIfMajorPerformanceCaveat?: boolean;
    /**
     * "high-performance", "low-power" or "default"
     */
    powerPreference?: boolean;
    /**
     * [description]
     */
    backgroundColor?: string | number;
    /**
     * [description]
     */
    callbacks?: object;
    /**
     * [description]
     */
    "callbacks.preBoot"?: BootCallback;
    /**
     * [description]
     */
    "callbacks.postBoot"?: BootCallback;
    /**
     * [description]
     */
    loader?: LoaderConfig;
    /**
     * [description]
     */
    images?: object;
    /**
     * [description]
     */
    "images.default"?: string;
    /**
     * [description]
     */
    "images.missing"?: string;
    /**
     * [description]
     */
    physics?: object;
};

declare type GameStepCallback = ()=>void;

declare type TimeStepCallback = (time: number, average: number, interpolation: number)=>void;

declare type JSONCamera = {
    /**
     * The name of the camera
     */
    name: string;
    /**
     * The horizontal position of camera
     */
    x: number;
    /**
     * The vertical position of camera
     */
    y: number;
    /**
     * The width size of camera
     */
    width: number;
    /**
     * The height size of camera
     */
    height: number;
    /**
     * The zoom of camera
     */
    zoom: number;
    /**
     * The rotation of camera
     */
    rotation: number;
    /**
     * The round pixels st status of camera
     */
    roundPixels: boolean;
    /**
     * The horizontal scroll of camera
     */
    scrollX: number;
    /**
     * The vertical scroll of camera
     */
    scrollY: number;
    /**
     * The background color of camera
     */
    backgroundColor: string;
    /**
     * The bounds of camera
     */
    bounds?: object;
    /**
     * The horizontal position of bounds of camera
     */
    "bounds.x"?: number;
    /**
     * The vertical position of bounds of camera
     */
    "bounds.y"?: number;
    /**
     * The width of the bounds of camera
     */
    "bounds.width"?: number;
    /**
     * The height of the bounds of camera
     */
    "bounds.height"?: number;
};

declare type InputJSONCameraObject = {
    /**
     * [description]
     */
    name?: string;
    /**
     * [description]
     */
    x?: integer;
    /**
     * [description]
     */
    y?: integer;
    /**
     * [description]
     */
    width?: integer;
    /**
     * [description]
     */
    height?: integer;
    /**
     * [description]
     */
    zoom?: number;
    /**
     * [description]
     */
    rotation?: number;
    /**
     * [description]
     */
    roundPixels?: boolean;
    /**
     * [description]
     */
    scrollX?: number;
    /**
     * [description]
     */
    scrollY?: number;
    /**
     * [description]
     */
    backgroundColor?: false | string;
    /**
     * [description]
     */
    bounds?: object;
    /**
     * [description]
     */
    "bounds.x"?: number;
    /**
     * [description]
     */
    "bounds.y"?: number;
    /**
     * [description]
     */
    "bounds.width"?: number;
    /**
     * [description]
     */
    "bounds.height"?: number;
};

declare type CameraFadeCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number)=>void;

declare type CameraFlashCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number)=>void;

declare type CameraShakeCallback = (camera: Phaser.Cameras.Scene2D.Camera, progress: number)=>void;

declare type FixedKeyControlConfig = {
    /**
     * The Camera that this Control will update.
     */
    camera?: Phaser.Cameras.Scene2D.Camera;
    /**
     * The Key to be pressed that will move the Camera left.
     */
    left?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera right.
     */
    right?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera up.
     */
    up?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera in.
     */
    zoomIn?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera out.
     */
    zoomOut?: Phaser.Input.Keyboard.Key;
    /**
     * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
     */
    zoomSpeed?: number;
    /**
     * The horizontal and vertical speed the camera will move.
     */
    speed?: number | Object;
};

declare type SmoothedKeyControlConfig = {
    /**
     * The Camera that this Control will update.
     */
    camera?: Phaser.Cameras.Scene2D.Camera;
    /**
     * The Key to be pressed that will move the Camera left.
     */
    left?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera right.
     */
    right?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will move the Camera up.
     */
    up?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera in.
     */
    zoomIn?: Phaser.Input.Keyboard.Key;
    /**
     * The Key to be pressed that will zoom the Camera out.
     */
    zoomOut?: Phaser.Input.Keyboard.Key;
    /**
     * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
     */
    zoomSpeed?: number;
    /**
     * The horizontal and vertical acceleration the camera will move.
     */
    acceleration?: number | Object;
    /**
     * The horizontal and vertical drag applied to the camera when it is moving.
     */
    drag?: number | Object;
    /**
     * The maximum horizontal and vertical speed the camera will move.
     */
    maxSpeed?: number | Object;
};

declare type RayDef = {
    /**
     * [description]
     */
    origin: Phaser.Math.Vector3;
    /**
     * [description]
     */
    direction: Phaser.Math.Vector3;
};

declare type GenerateTextureRendererCallback = (canvas: HTMLCanvasElement, context: CanvasRenderingContext2D)=>void;

declare type GenerateTextureConfig = {
    /**
     * [description]
     */
    data?: any[];
    /**
     * [description]
     */
    canvas?: HTMLCanvasElement;
    /**
     * [description]
     */
    palette?: Palette;
    /**
     * [description]
     */
    pixelWidth?: number;
    /**
     * [description]
     */
    pixelHeight?: number;
    /**
     * [description]
     */
    resizeCanvas?: boolean;
    /**
     * [description]
     */
    clearCanvas?: boolean;
    /**
     * [description]
     */
    preRender?: GenerateTextureRendererCallback;
    /**
     * [description]
     */
    postRender?: GenerateTextureRendererCallback;
};

declare type Palette = {
    /**
     * Color value 1.
     */
    "0": string;
    /**
     * Color value 2.
     */
    "1": string;
    /**
     * Color value 3.
     */
    "2": string;
    /**
     * Color value 4.
     */
    "3": string;
    /**
     * Color value 5.
     */
    "4": string;
    /**
     * Color value 6.
     */
    "5": string;
    /**
     * Color value 7.
     */
    "6": string;
    /**
     * Color value 8.
     */
    "7": string;
    /**
     * Color value 9.
     */
    "8": string;
    /**
     * Color value 10.
     */
    "9": string;
    /**
     * Color value 11.
     */
    A: string;
    /**
     * Color value 12.
     */
    B: string;
    /**
     * Color value 13.
     */
    C: string;
    /**
     * Color value 14.
     */
    D: string;
    /**
     * Color value 15.
     */
    E: string;
    /**
     * Color value 16.
     */
    F: string;
};

declare type JSONEllipseCurve = {
    /**
     * The of the curve.
     */
    type: string;
    /**
     * [description]
     */
    x: number;
    /**
     * [description]
     */
    y: number;
    /**
     * The horizontal radius of ellipse.
     */
    xRadius: number;
    /**
     * The vertical radius of ellipse.
     */
    yRadius: number;
    /**
     * The start angle of ellipse.
     */
    startAngle: integer;
    /**
     * The end angle of ellipse.
     */
    endAngle: integer;
    /**
     * The clockwise of ellipse.
     */
    clockwise: boolean;
    /**
     * The rotation of ellipse.
     */
    rotation: integer;
};

declare type EllipseCurveConfig = {
    /**
     * [description]
     */
    x?: number;
    /**
     * [description]
     */
    y?: number;
    /**
     * [description]
     */
    xRadius?: number;
    /**
     * [description]
     */
    yRadius?: number;
    /**
     * [description]
     */
    startAngle?: integer;
    /**
     * [description]
     */
    endAngle?: integer;
    /**
     * [description]
     */
    clockwise?: boolean;
    /**
     * [description]
     */
    rotation?: integer;
};

declare type JSONCurve = {
    /**
     * The of the curve
     */
    type: string;
    /**
     * The arrays of points like `[x1, y1, x2, y2]`
     */
    points: number[];
};

declare type JSONPath = {
    /**
     * The of the curve.
     */
    type: string;
    /**
     * [description]
     */
    x: number;
    /**
     * [description]
     */
    y: number;
    /**
     * The path is auto closed.
     */
    autoClose: boolean;
    /**
     * The list of the curves
     */
    curves: JSONCurve[];
};

declare type DataEachCallback = (parent: any, key: string, value: any, ...args: any[])=>void;

/**
 * Checks for support of the Full Screen API.
 */
declare function init(): void;

declare type InputColorObject = {
    /**
     * The red color value in the range 0 to 255.
     */
    r?: number;
    /**
     * The green color value in the range 0 to 255.
     */
    g?: number;
    /**
     * The blue color value in the range 0 to 255.
     */
    b?: number;
    /**
     * The alpha color value in the range 0 to 255.
     */
    a?: number;
};

declare type ColorObject = ()=>void;

declare namespace Phaser.Display.Color {
    /**
     * Interpolates color values
     */
    namespace Interpolate {
        /**
         * Interpolates between the two given color ranges over the length supplied.
         * @param r1 Red value.
         * @param g1 Blue value.
         * @param b1 Green value.
         * @param r2 Red value.
         * @param g2 Blue value.
         * @param b2 Green value.
         * @param length Distance to interpolate over. Default 100.
         * @param index Index to start from. Default 0.
         */
        function RGBWithRGB(r1: number, g1: number, b1: number, r2: number, g2: number, b2: number, length?: number, index?: number): ColorObject;

        /**
         * Interpolates between the two given color objects over the length supplied.
         * @param color1 The first Color object.
         * @param color2 The second Color object.
         * @param length Distance to interpolate over. Default 100.
         * @param index Index to start from. Default 0.
         */
        function ColorWithColor(color1: Phaser.Display.Color, color2: Phaser.Display.Color, length?: number, index?: number): ColorObject;

        /**
         * Interpolates between the Color object and color values over the length supplied.
         * @param color1 The first Color object.
         * @param r Red value.
         * @param g Blue value.
         * @param b Green value.
         * @param length Distance to interpolate over. Default 100.
         * @param index Index to start from. Default 0.
         */
        function ColorWithRGB(color1: Phaser.Display.Color, r: number, g: number, b: number, length?: number, index?: number): ColorObject;

    }

}

declare type HSLColorObject = {
    /**
     * The hue color value. A number between 0 and 1
     */
    h: number;
    /**
     * The saturation color value. A number between 0 and 1
     */
    s: number;
    /**
     * The lightness color value. A number between 0 and 1
     */
    l: number;
};

declare type ContentLoadedCallback = ()=>void;

declare type DisplayCallbackConfig = {
    /**
     * [description]
     */
    tint: Object;
    /**
     * [description]
     */
    index: number;
    /**
     * [description]
     */
    charCode: number;
    /**
     * [description]
     */
    x: number;
    /**
     * [description]
     */
    y: number;
    /**
     * [description]
     */
    scale: number;
    /**
     * [description]
     */
    rotation: number;
    /**
     * [description]
     */
    data: any;
};

declare type DisplayCallback = (display: DisplayCallbackConfig)=>void;

declare type BitmapTextConfig = GameObjectConfig & {
    /**
     * [description]
     */
    font?: string;
    /**
     * [description]
     */
    text?: string;
    /**
     * [description]
     */
    size?: number | false;
    /**
     * [description]
     */
    align?: string;
};

declare type TextBounds = {
    /**
     * [description]
     */
    local: object;
    /**
     * [description]
     */
    "local.x": number;
    /**
     * [description]
     */
    "local.y": number;
    /**
     * [description]
     */
    "local.width": number;
    /**
     * [description]
     */
    "local.height": number;
    /**
     * [description]
     */
    global: object;
    /**
     * [description]
     */
    "global.x": number;
    /**
     * [description]
     */
    "global.y": number;
    /**
     * [description]
     */
    "global.width": number;
    /**
     * [description]
     */
    "global.height": number;
};

declare type JSONBitmapText = JSONGameObject & {
    /**
     * [description]
     */
    font: string;
    /**
     * [description]
     */
    text: string;
    /**
     * [description]
     */
    fontSize: number;
    /**
     * Adds/Removes spacing between characters
     */
    letterSpacing: number;
};

declare namespace Phaser.GameObjects.Blitter {
    type BlitterFromCallback = (blitter: Phaser.GameObjects.Blitter, index: integer)=>void;

    /**
     * A Bob Game Object.
     * 
     * 
     * 
     * A Bob belongs to a Blitter Game Object. The Blitter is responsible for managing and rendering this object.
     * 
     * 
     * 
     * A Bob has a position, alpha value and a frame from a texture that it uses to render with. You can also toggle
     * 
     * the flipped and visible state of the Bob. The Frame the Bob uses to render can be changed dynamically, but it
     * 
     * must be a Frame within the Texture used by the parent Blitter.
     * 
     * 
     * 
     * Bob positions are relative to the Blitter parent. So if you move the Blitter parent, all Bob children will
     * 
     * have their positions impacted by this change as well.
     * 
     * 
     * 
     * You can manipulate Bob objects directly from your game code, but the creation and destruction of them should be
     * 
     * handled via the Blitter parent.
     */
    class Bob {
        /**
         * 
         * @param blitter The parent Blitter object is responsible for updating this Bob.
         * @param x The horizontal position of this Game Object in the world, relative to the parent Blitter position.
         * @param y The vertical position of this Game Object in the world, relative to the parent Blitter position.
         * @param frame The Frame this Bob will render with, as defined in the Texture the parent Blitter is using.
         * @param visible Should the Bob render visible or not to start with?
         */
        constructor(blitter: Phaser.GameObjects.Blitter, x: number, y: number, frame: string | integer, visible: boolean);

        /**
         * [description]
         */
        parent: Phaser.GameObjects.Blitter;

        /**
         * [description]
         */
        x: number;

        /**
         * [description]
         */
        y: number;

        /**
         * [description]
         */
        frame: string | integer;

        /**
         * [description]
         */
        data: object;

        /**
         * [description]
         */
        flipX: boolean;

        /**
         * [description]
         */
        flipY: boolean;

        /**
         * [description]
         * @param frame [description]
         */
        setFrame(frame?: Phaser.Textures.Frame): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         */
        resetFlip(): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         * @param x [description]
         * @param y [description]
         * @param frame [description]
         */
        reset(x: number, y: number, frame: Phaser.Textures.Frame): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         * @param value [description]
         */
        setFlipX(value: number): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         * @param value [description]
         */
        setFlipY(value: number): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         * @param x [description]
         * @param y [description]
         */
        setFlip(x: number, y: number): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         * @param value [description]
         */
        setVisible(value: boolean): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         * @param value [description]
         */
        setAlpha(value: number): Phaser.GameObjects.Blitter.Bob;

        /**
         * [description]
         */
        destroy(): void;

        /**
         * [description]
         */
        visible: boolean;

        /**
         * [description]
         */
        alpha: number;

    }

}

declare type GameObjectConfig = {
    /**
     * [description]
     */
    x?: number;
    /**
     * [description]
     */
    y?: number;
    /**
     * [description]
     */
    depth?: number;
    /**
     * [description]
     */
    flipX?: boolean;
    /**
     * [description]
     */
    flipY?: boolean;
    /**
     * [description]
     */
    scale?: number | object;
    /**
     * [description]
     */
    scrollFactor?: number | object;
    /**
     * [description]
     */
    rotation?: number;
    /**
     * [description]
     */
    angle?: number;
    /**
     * [description]
     */
    alpha?: number;
    /**
     * [description]
     */
    origin?: number | object;
    /**
     * [description]
     */
    scaleMode?: number;
    /**
     * [description]
     */
    blendMode?: number;
    /**
     * [description]
     */
    visible?: boolean;
    /**
     * [description]
     */
    add?: boolean;
};

declare type JSONGameObject = {
    /**
     * The name of this Game Object.
     */
    name: string;
    /**
     * A textual representation of this Game Object, i.e. `sprite`.
     */
    type: string;
    /**
     * The x position of this Game Object.
     */
    x: number;
    /**
     * The y position of this Game Object.
     */
    y: number;
    /**
     * The scale of this Game Object
     */
    scale: object;
    /**
     * The horizontal scale of this Game Object.
     */
    "scale.x": number;
    /**
     * The vertical scale of this Game Object.
     */
    "scale.y": number;
    /**
     * The origin of this Game Object.
     */
    origin: object;
    /**
     * The horizontal origin of this Game Object.
     */
    "origin.x": number;
    /**
     * The vertical origin of this Game Object.
     */
    "origin.y": number;
    /**
     * The horizontally flipped state of the Game Object.
     */
    flipX: boolean;
    /**
     * The vertically flipped state of the Game Object.
     */
    flipY: boolean;
    /**
     * The angle of this Game Object in radians.
     */
    rotation: number;
    /**
     * The alpha value of the Game Object.
     */
    alpha: number;
    /**
     * The visible state of the Game Object.
     */
    visible: boolean;
    /**
     * The Scale Mode being used by this Game Object.
     */
    scaleMode: integer;
    /**
     * Sets the Blend Mode being used by this Game Object.
     */
    blendMode: integer | string;
    /**
     * The texture key of this Game Object.
     */
    textureKey: string;
    /**
     * The frame key of this Game Object.
     */
    frameKey: string;
    /**
     * The data of this Game Object.
     */
    data: object;
};

declare type EachContainerCallback<I> = (item: any, ...args: any[])=>void;

declare namespace Phaser.GameObjects.Graphics {
    namespace Commands {
    }

}

declare type GroupCallback = (item: Phaser.GameObjects.GameObject)=>void;

declare type GroupMultipleCreateCallback = (items: Phaser.GameObjects.GameObject[])=>void;

declare type GroupConfig = {
    /**
     * Sets {@link Phaser.GameObjects.Group#classType}.
     */
    classType?: object;
    /**
     * Sets {@link Phaser.GameObjects.Group#active}.
     */
    active?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Group#maxSize}.
     */
    maxSize?: number;
    /**
     * Sets {@link Phaser.GameObjects.Group#defaultKey}.
     */
    defaultKey?: string;
    /**
     * Sets {@link Phaser.GameObjects.Group#defaultFrame}.
     */
    defaultFrame?: string | integer;
    /**
     * Sets {@link Phaser.GameObjects.Group#runChildUpdate}.
     */
    runChildUpdate?: boolean;
    /**
     * Sets {@link Phaser.GameObjects.Group#createCallback}.
     */
    createCallback?: GroupCallback;
    /**
     * Sets {@link Phaser.GameObjects.Group#removeCallback}.
     */
    removeCallback?: GroupCallback;
    /**
     * Sets {@link Phaser.GameObjects.Group#createMultipleCallback}.
     */
    createMultipleCallback?: GroupMultipleCreateCallback;
};

/**
 * The total number of objects created will be
 * 
 *     key.length * frame.length * frameQuantity * (yoyo ? 2 : 1) * (1 + repeat)
 * 
 * In the simplest case, 1 + `repeat` objects will be created.
 * 
 * If `max` is positive, then the total created will not exceed `max`.
 * 
 * `key` is required. {@link Phaser.GameObjects.Group#defaultKey} is not used.
 */
declare type GroupCreateConfig = {
    /**
     * The class of each new Game Object.
     */
    classType?: object;
    /**
     * The texture key of each new Game Object.
     */
    key?: string;
    /**
     * The texture frame of each new Game Object.
     */
    frame?: string | integer;
    /**
     * The visible state of each new Game Object.
     */
    visible?: boolean;
    /**
     * The active state of each new Game Object.
     */
    active?: boolean;
    /**
     * The number of times each `key` × `frame` combination will be *repeated* (after the first combination).
     */
    repeat?: number;
    /**
     * Select a `key` at random.
     */
    randomKey?: boolean;
    /**
     * Select a `frame` at random.
     */
    randomFrame?: boolean;
    /**
     * Select keys and frames by moving forward then backward through `key` and `frame`.
     */
    yoyo?: boolean;
    /**
     * The number of times each `frame` should be combined with one `key`.
     */
    frameQuantity?: number;
    /**
     * The maximum number of new Game Objects to create. 0 is no maximum.
     */
    max?: number;
    setXY?: object;
    /**
     * The horizontal position of each new Game Object.
     */
    "setXY.x"?: number;
    /**
     * The vertical position of each new Game Object.
     */
    "setXY.y"?: number;
    /**
     * Increment each Game Object's horizontal position from the previous by this amount, starting from `setXY.x`.
     */
    "setXY.stepX"?: number;
    /**
     * Increment each Game Object's vertical position from the previous by this amount, starting from `setXY.y`.
     */
    "setXY.stepY"?: number;
    setRotation?: object;
    /**
     * Rotation of each new Game Object.
     */
    "setRotation.value"?: number;
    /**
     * Increment each Game Object's rotation from the previous by this amount, starting at `setRotation.value`.
     */
    "setRotation.step"?: number;
    setScale?: object;
    /**
     * The horizontal scale of each new Game Object.
     */
    "setScale.x"?: number;
    /**
     * The vertical scale of each new Game Object.
     */
    "setScale.y"?: number;
    /**
     * Increment each Game Object's horizontal scale from the previous by this amount, starting from `setScale.x`.
     */
    "setScale.stepX"?: number;
    /**
     * Increment each Game object's vertical scale from the previous by this amount, starting from `setScale.y`.
     */
    "setScale.stepY"?: number;
    setAlpha?: object;
    /**
     * The alpha value of each new Game Object.
     */
    "setAlpha.value"?: number;
    /**
     * Increment each Game Object's alpha from the previous by this amount, starting from `setAlpha.value`.
     */
    "setAlpha.step"?: number;
    /**
     * A geometric shape that defines the hit area for the Game Object.
     */
    hitArea?: any;
    /**
     * A callback to be invoked when the Game Object is interacted with.
     */
    hitAreaCallback?: HitAreaCallback;
    /**
     * Align the new Game Objects in a grid using these settings.
     */
    gridAlign?: false | GridAlignConfig;
};

declare type LightForEach = (light: Phaser.GameObjects.Light)=>void;

/**
 * The returned value sets what the property will be at the START of the particles life, on emit.
 */
declare type EmitterOpOnEmitCallback = (particle: Phaser.GameObjects.Particles.Particle, key: string, value: number)=>void;

/**
 * The returned value updates the property for the duration of the particles life.
 */
declare type EmitterOpOnUpdateCallback = (particle: Phaser.GameObjects.Particles.Particle, key: string, t: number, value: number)=>void;

declare type GravityWellConfig = {
    /**
     * The x coordinate of the Gravity Well, in world space.
     */
    x?: number;
    /**
     * The y coordinate of the Gravity Well, in world space.
     */
    y?: number;
    /**
     * The power of the Gravity Well.
     */
    power?: number;
    /**
     * [description]
     */
    epsilon?: number;
    /**
     * The gravitational force of this Gravity Well.
     */
    gravity?: number;
};

declare type ParticleEmitterCallback = (particle: Phaser.GameObjects.Particles.Particle, emitter: Phaser.GameObjects.Particles.ParticleEmitter)=>void;

declare type ParticleDeathCallback = (particle: Phaser.GameObjects.Particles.Particle)=>void;

declare type PathConfig = {
    /**
     * [description]
     */
    duration: number;
    /**
     * [description]
     */
    from: number;
    /**
     * [description]
     */
    to: number;
    /**
     * [description]
     */
    positionOnPath?: boolean;
    /**
     * [description]
     */
    rotateToPath?: boolean;
    /**
     * [description]
     */
    rotationOffset?: number;
    /**
     * [description]
     */
    verticalAdjust?: boolean;
};

declare type RenderTextureConfig = {
    /**
     * [description]
     */
    x?: number;
    /**
     * [description]
     */
    y?: number;
    /**
     * [description]
     */
    width?: number;
    /**
     * [description]
     */
    height?: number;
};

/**
 * A custom function that will be responsible for wrapping the text.
 */
declare type TextStyleWordWrapCallback = (text: string, textObject: Phaser.GameObjects.Text)=>void;

declare namespace Phaser.GameObjects.Text {
    /**
     * [description]
     */
    class TextStyle {
        /**
         * 
         * @param text The Text object that this TextStyle is styling.
         * @param style [description]
         */
        constructor(text: Phaser.GameObjects.Text, style: object);

        /**
         * The Text object that this TextStyle is styling.
         */
        parent: Phaser.GameObjects.Text;

        /**
         * [description]
         */
        fontFamily: string;

        /**
         * [description]
         */
        fontSize: string;

        /**
         * [description]
         */
        fontStyle: string;

        /**
         * [description]
         */
        backgroundColor: string;

        /**
         * [description]
         */
        color: string;

        /**
         * [description]
         */
        stroke: string;

        /**
         * [description]
         */
        strokeThickness: number;

        /**
         * [description]
         */
        shadowOffsetX: number;

        /**
         * [description]
         */
        shadowOffsetY: number;

        /**
         * [description]
         */
        shadowColor: string;

        /**
         * [description]
         */
        shadowBlur: number;

        /**
         * [description]
         */
        shadowStroke: boolean;

        /**
         * [description]
         */
        shadowFill: boolean;

        /**
         * [description]
         */
        align: string;

        /**
         * [description]
         */
        maxLines: integer;

        /**
         * [description]
         */
        fixedWidth: number;

        /**
         * [description]
         */
        fixedHeight: number;

        /**
         * [description]
         */
        rtl: boolean;

        /**
         * [description]
         */
        testString: string;

        /**
         * The amount of horizontal padding adding to the width of the text when calculating the font metrics.
         */
        baselineX: number;

        /**
         * The amount of vertical padding adding to the width of the text when calculating the font metrics.
         */
        baselineY: number;

        /**
         * [description]
         * @param style [description]
         * @param updateText [description] Default true.
         */
        setStyle(style: CSSStyleRule, updateText?: boolean): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param canvas [description]
         * @param context [description]
         */
        syncFont(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

        /**
         * [description]
         * @param canvas [description]
         * @param context [description]
         */
        syncStyle(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D): void;

        /**
         * [description]
         * @param context [description]
         * @param enabled [description]
         */
        syncShadow(context: CanvasRenderingContext2D, enabled: boolean): void;

        /**
         * [description]
         * @param recalculateMetrics [description]
         */
        update(recalculateMetrics: boolean): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param font [description]
         */
        setFont(font: string | object): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param family [description]
         */
        setFontFamily(family: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param style [description]
         */
        setFontStyle(style: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param size [description]
         */
        setFontSize(size: number | string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param string [description]
         */
        setTestString(string: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param width [description]
         * @param height [description]
         */
        setFixedSize(width: number, height: number): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param color [description]
         */
        setBackgroundColor(color: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param color [description]
         */
        setFill(color: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param color [description]
         */
        setColor(color: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param color [description]
         * @param thickness [description]
         */
        setStroke(color: string, thickness: number): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param x [description] Default 0.
         * @param y [description] Default 0.
         * @param color [description] Default '#000'.
         * @param blur [description] Default 0.
         * @param shadowStroke [description] Default false.
         * @param shadowFill [description] Default true.
         */
        setShadow(x?: number, y?: number, color?: string, blur?: number, shadowStroke?: boolean, shadowFill?: boolean): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param x [description] Default 0.
         * @param y [description] Default 0.
         */
        setShadowOffset(x?: number, y?: number): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param color [description] Default '#000'.
         */
        setShadowColor(color?: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param blur [description] Default 0.
         */
        setShadowBlur(blur?: number): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param enabled [description]
         */
        setShadowStroke(enabled: boolean): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param enabled [description]
         */
        setShadowFill(enabled: boolean): Phaser.GameObjects.Text;

        /**
         * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.
         * @param width The maximum width of a line in pixels. Set to null to remove wrapping.
         * @param useAdvancedWrap Whether or not to use the advanced wrapping
         * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
         * spaces and whitespace are left as is. Default false.
         */
        setWordWrapWidth(width: number, useAdvancedWrap?: boolean): Phaser.GameObjects.Text;

        /**
         * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.
         * @param callback A custom function that will be responsible for wrapping the
         * text. It will receive two arguments: text (the string to wrap), textObject (this Text
         * instance). It should return the wrapped lines either as an array of lines or as a string with
         * newline characters in place to indicate where breaks should happen.
         * @param scope The scope that will be applied when the callback is invoked. Default null.
         */
        setWordWrapCallback(callback: TextStyleWordWrapCallback, scope?: object): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param align [description]
         */
        setAlign(align: string): Phaser.GameObjects.Text;

        /**
         * [description]
         * @param max [description] Default 0.
         */
        setMaxLines(max?: integer): Phaser.GameObjects.Text;

        /**
         * [description]
         */
        getTextMetrics(): object;

        /**
         * [description]
         */
        toJSON(): object;

        /**
         * [description]
         */
        destroy(): void;

    }

}

declare type TileSprite = GameObjectConfig & {
    /**
     * [description]
     */
    x?: number;
    /**
     * [description]
     */
    y?: number;
    /**
     * [description]
     */
    width?: number;
    /**
     * [description]
     */
    height?: number;
    /**
     * [description]
     */
    key?: string;
    /**
     * [description]
     */
    frame?: string;
};

declare type CenterFunction = (triangle: Phaser.Geom.Triangle)=>void;

declare type HitAreaCallback = (hitArea: any, x: number, y: number, gameObject: Phaser.GameObjects.GameObject)=>void;

declare type Pad = {
    /**
     * [description]
     */
    id: string;
    /**
     * [description]
     */
    index: integer;
};

declare type GamepadHandler = ()=>void;

declare type KeyboardKeydownCallback = (event: KeyboardEvent)=>void;

declare type KeyComboConfig = {
    /**
     * [description]
     */
    resetOnWrongKey?: boolean;
    /**
     * [description]
     */
    maxKeyDelay?: number;
    /**
     * [description]
     */
    resetOnMatch?: boolean;
    /**
     * [description]
     */
    deleteOnMatch?: boolean;
};

declare type KeyboardHandler = ()=>void;

declare type CursorKeys = {
    /**
     * [description]
     */
    up?: Phaser.Input.Keyboard.Key;
    /**
     * [description]
     */
    down?: Phaser.Input.Keyboard.Key;
    /**
     * [description]
     */
    left?: Phaser.Input.Keyboard.Key;
    /**
     * [description]
     */
    right?: Phaser.Input.Keyboard.Key;
    /**
     * [description]
     */
    space?: Phaser.Input.Keyboard.Key;
    /**
     * [description]
     */
    shift?: Phaser.Input.Keyboard.Key;
};

declare type MouseHandler = ()=>void;

declare type TouchHandler = (event: TouchEvent)=>void;

declare type FileProcessCallback = (file: Phaser.Loader.File)=>void;

declare type FileConfig = {
    /**
     * The file type string (image, json, etc) for sorting within the Loader.
     */
    type?: string | false;
    /**
     * Unique cache key (unique within its file type)
     */
    key?: string | false;
    /**
     * The URL of the file, not including baseURL.
     */
    url?: string;
    /**
     * [description]
     */
    path?: string;
    /**
     * [description]
     */
    extension?: string;
    /**
     * [description]
     */
    responseType?: XMLHttpRequestResponseType;
    /**
     * [description]
     */
    xhrSettings?: XHRSettingsObject | false;
    /**
     * A config object that can be used by file types to store transitional data.
     */
    config?: object;
};

declare type XHRConfig = {
    /**
     * [description]
     */
    key: string;
    /**
     * [description]
     */
    texture: string;
    /**
     * [description]
     */
    data?: string;
    /**
     * [description]
     */
    xhr?: XHRConfig;
};

declare type FileTypeConfig = {
    /**
     * [description]
     */
    key: string;
    /**
     * [description]
     */
    texture: string;
    /**
     * [description]
     */
    data?: string;
    /**
     * [description]
     */
    url?: string;
    /**
     * [description]
     */
    path?: string;
    /**
     * [description]
     */
    extension?: string;
    /**
     * [description]
     */
    responseType?: string;
    /**
     * [description]
     */
    config?: object;
    /**
     * [description]
     */
    xhr?: XHRConfig;
};

declare type LinkFileObject = {
    /**
     * [description]
     */
    type: string;
    /**
     * [description]
     */
    fileA: Phaser.Loader.File;
    /**
     * [description]
     */
    fileB: Phaser.Loader.File;
};

declare type LoaderFileObject = {
    /**
     * [description]
     */
    key: string;
    /**
     * [description]
     */
    type: string;
    /**
     * [description]
     */
    url?: string;
    /**
     * [description]
     */
    urls?: string[];
    /**
     * [description]
     */
    textureURL?: string;
    /**
     * [description]
     */
    atlasURL?: string;
    /**
     * [description]
     */
    xmlURL?: string;
    /**
     * [description]
     */
    textureURLs?: string[];
    /**
     * [description]
     */
    atlasURLs?: string[];
    /**
     * [description]
     */
    config?: object;
    /**
     * [description]
     */
    json?: object;
    /**
     * [description]
     */
    xhrSettings?: XHRSettingsObject;
    /**
     * [description]
     */
    textureXhrSettings?: XHRSettingsObject;
    /**
     * [description]
     */
    atlasXhrSettings?: XHRSettingsObject;
    /**
     * [description]
     */
    xmlXhrSettings?: XHRSettingsObject;
    /**
     * [description]
     */
    audioXhrSettings?: XHRSettingsObject;
    /**
     * [description]
     */
    jsonXhrSettings?: XHRSettingsObject;
};

declare type XHRSettingsObject = {
    /**
     * [description]
     */
    responseType: XMLHttpRequestResponseType;
    /**
     * [description]
     */
    async: boolean;
    /**
     * [description]
     */
    user: string;
    /**
     * [description]
     */
    password: string;
    /**
     * [description]
     */
    timeout: number;
    /**
     * [description]
     */
    header: string;
    /**
     * [description]
     */
    headerValue: string;
    /**
     * [description]
     */
    overrideMimeType: string | undefined;
};

declare type SinCosTable = {
    /**
     * [description]
     */
    sin: number;
    /**
     * [description]
     */
    cos: number;
    /**
     * [description]
     */
    length: number;
};

declare type Vector2Like = {
    /**
     * [description]
     */
    x: number;
    /**
     * [description]
     */
    y: number;
};

declare namespace Phaser {
    namespace Actions {
        /**
         * Takes an array of Game Objects, or any objects that have a public `angle` property,
         * and then adds the given value to each of their `angle` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `Angle(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `angle` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function Angle<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of objects and passes each of them to the given callback.
         * @param items The array of items to be updated by this action.
         * @param callback The callback to be invoked. It will be passed just one argument: the item from the array.
         * @param context The scope in which the callback will be invoked.
         */
        function Call<G extends Phaser.GameObjects.GameObject[]>(items: G, callback: CallCallback, context: any): G;

        /**
         * Takes an array of objects and returns the first element in the array that has properties which match
         * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`
         * then it would return the first item which had the property `scaleX` set to 0.5 and `alpha` set to 1.
         * 
         * To use this with a Group: `GetFirst(group.getChildren(), compare, index)`
         * @param items The array of items to be searched by this action.
         * @param compare The comparison object. Each property in this object will be checked against the items of the array.
         * @param index An optional offset to start searching from within the items array. Default 0.
         */
        function GetFirst<G extends Phaser.GameObjects.GameObject[]>(items: G, compare: object, index?: integer): object | Phaser.GameObjects.GameObject;

        /**
         * Takes an array of objects and returns the last element in the array that has properties which match
         * all of those specified in the `compare` object. For example, if the compare object was: `{ scaleX: 0.5, alpha: 1 }`
         * then it would return the last item which had the property `scaleX` set to 0.5 and `alpha` set to 1.
         * 
         * To use this with a Group: `GetLast(group.getChildren(), compare, index)`
         * @param items The array of items to be searched by this action.
         * @param compare The comparison object. Each property in this object will be checked against the items of the array.
         * @param index An optional offset to start searching from within the items array. Default 0.
         */
        function GetLast<G extends Phaser.GameObjects.GameObject[]>(items: G, compare: object, index?: integer): object | Phaser.GameObjects.GameObject;

        /**
         * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,
         * and then aligns them based on the grid configuration given to this action.
         * @param items The array of items to be updated by this action.
         * @param options The GridAlign Configuration object.
         */
        function GridAlign<G extends Phaser.GameObjects.GameObject[]>(items: G, options: GridAlignConfig): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `alpha` property,
         * and then adds the given value to each of their `alpha` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `IncAlpha(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `alpha` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncAlpha<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `x` property,
         * and then adds the given value to each of their `x` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `IncX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `x` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncX<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have public `x` and `y` properties,
         * and then adds the given value to each of them.
         * 
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `IncXY(group.getChildren(), x, y, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param x The amount to be added to the `x` property.
         * @param y The amount to be added to the `y` property. If `undefined` or `null` it uses the `x` value. Default x.
         * @param stepX This is added to the `x` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncXY<G extends Phaser.GameObjects.GameObject[]>(items: G, x: number, y?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `y` property,
         * and then adds the given value to each of their `y` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `IncY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `y` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function IncY<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param circle [description]
         * @param startAngle [description] Default 0.
         * @param endAngle [description] Default 6.28.
         */
        function PlaceOnCircle<G extends Phaser.GameObjects.GameObject[]>(items: G, circle: Phaser.Geom.Circle, startAngle?: number, endAngle?: number): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param ellipse [description]
         * @param startAngle [description] Default 0.
         * @param endAngle [description] Default 6.28.
         */
        function PlaceOnEllipse<G extends Phaser.GameObjects.GameObject[]>(items: G, ellipse: Phaser.Geom.Ellipse, startAngle?: number, endAngle?: number): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param line [description]
         */
        function PlaceOnLine<G extends Phaser.GameObjects.GameObject[]>(items: G, line: Phaser.Geom.Line): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param rect [description]
         * @param shift [description] Default 1.
         */
        function PlaceOnRectangle<G extends Phaser.GameObjects.GameObject[]>(items: G, rect: Phaser.Geom.Rectangle, shift?: integer): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param triangle [description]
         * @param stepRate [description] Default 1.
         */
        function PlaceOnTriangle<G extends Phaser.GameObjects.GameObject[]>(items: G, triangle: Phaser.Geom.Triangle, stepRate?: number): G;

        /**
         * Play an animation with the given key, starting at the given startFrame on all Game Objects in items.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param key The name of the animation to play.
         * @param startFrame The starting frame of the animation with the given key.
         */
        function PlayAnimation<G extends Phaser.GameObjects.GameObject[]>(items: G, key: string, startFrame?: string | integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,
         * and then adds the given value to it.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `PropertyValueInc(group.getChildren(), key, value, step)`
         * @param items The array of items to be updated by this action.
         * @param key The property to be updated.
         * @param value The amount to be added to the property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function PropertyValueInc<G extends Phaser.GameObjects.GameObject[]>(items: G, key: string, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public property as defined in `key`,
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `PropertyValueSet(group.getChildren(), key, value, step)`
         * @param items The array of items to be updated by this action.
         * @param key The property to be updated.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function PropertyValueSet<G extends Phaser.GameObjects.GameObject[]>(items: G, key: string, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param circle [description]
         */
        function RandomCircle<G extends Phaser.GameObjects.GameObject[]>(items: G, circle: Phaser.Geom.Circle): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param ellipse [description]
         */
        function RandomEllipse<G extends Phaser.GameObjects.GameObject[]>(items: G, ellipse: Phaser.Geom.Ellipse): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param line [description]
         */
        function RandomLine<G extends Phaser.GameObjects.GameObject[]>(items: G, line: Phaser.Geom.Line): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param rect [description]
         */
        function RandomRectangle<G extends Phaser.GameObjects.GameObject[]>(items: G, rect: Phaser.Geom.Rectangle): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param triangle [description]
         */
        function RandomTriangle<G extends Phaser.GameObjects.GameObject[]>(items: G, triangle: Phaser.Geom.Triangle): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `rotation` property,
         * and then adds the given value to each of their `rotation` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `Rotate(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `rotation` property (in radians).
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function Rotate<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Rotates each item around the given point by the given angle.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param point Any object with public `x` and `y` properties.
         * @param angle The angle to rotate by, in radians.
         */
        function RotateAround<G extends Phaser.GameObjects.GameObject[]>(items: G, point: object, angle: number): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param point Any object with public `x` and `y` properties.
         * @param angle The angle to rotate by, in radians.
         * @param distance The distance from the point of rotation in pixels.
         */
        function RotateAroundDistance<G extends Phaser.GameObjects.GameObject[]>(items: G, point: object, angle: number, distance: number): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `scaleX` property,
         * and then adds the given value to each of their `scaleX` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `ScaleX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `scaleX` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function ScaleX<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have public `scaleX` and `scaleY` properties,
         * and then adds the given value to each of them.
         * 
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `ScaleXY(group.getChildren(), scaleX, scaleY, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param scaleX The amount to be added to the `scaleX` property.
         * @param scaleY The amount to be added to the `scaleY` property. If `undefined` or `null` it uses the `scaleX` value.
         * @param stepX This is added to the `scaleX` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function ScaleXY<G extends Phaser.GameObjects.GameObject[]>(items: G, scaleX: number, scaleY?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have a public `scaleY` property,
         * and then adds the given value to each of their `scaleY` properties.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `ScaleY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to be added to the `scaleY` property.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function ScaleY<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `alpha`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetAlpha(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetAlpha<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `blendMode`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetBlendMode(group.getChildren(), value)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetBlendMode<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `depth`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetDepth(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetDepth<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param hitArea [description]
         * @param hitAreaCallback [description]
         */
        function SetHitArea<G extends Phaser.GameObjects.GameObject[]>(items: G, hitArea: any, hitAreaCallback: HitAreaCallback): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public properties `originX` and `originY`
         * and then sets them to the given values.
         * 
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetOrigin(group.getChildren(), originX, originY, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param originX The amount to set the `originX` property to.
         * @param originY The amount to set the `originY` property to. If `undefined` or `null` it uses the `originX` value.
         * @param stepX This is added to the `originX` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `originY` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetOrigin<G extends Phaser.GameObjects.GameObject[]>(items: G, originX: number, originY?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `rotation`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetRotation(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetRotation<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public properties `scaleX` and `scaleY`
         * and then sets them to the given values.
         * 
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetScale(group.getChildren(), scaleX, scaleY, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param scaleX The amount to set the `scaleX` property to.
         * @param scaleY The amount to set the `scaleY` property to. If `undefined` or `null` it uses the `scaleX` value.
         * @param stepX This is added to the `scaleX` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `scaleY` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetScale<G extends Phaser.GameObjects.GameObject[]>(items: G, scaleX: number, scaleY?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `scaleX`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetScaleX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetScaleX<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `scaleY`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetScaleY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetScaleY<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param topLeft [description]
         * @param topRight [description]
         * @param bottomLeft [description]
         * @param bottomRight [description]
         */
        function SetTint<G extends Phaser.GameObjects.GameObject[]>(items: G, topLeft: number, topRight?: number, bottomLeft?: number, bottomRight?: number): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `visible`
         * and then sets it to the given value.
         * 
         * To use this with a Group: `SetVisible(group.getChildren(), value)`
         * @param items The array of items to be updated by this action.
         * @param value The value to set the property to.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetVisible<G extends Phaser.GameObjects.GameObject[]>(items: G, value: boolean, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `x`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetX(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetX<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public properties `x` and `y`
         * and then sets them to the given values.
         * 
         * The optional `stepX` and `stepY` properties are applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetXY(group.getChildren(), x, y, stepX, stepY)`
         * @param items The array of items to be updated by this action.
         * @param x The amount to set the `x` property to.
         * @param y The amount to set the `y` property to. If `undefined` or `null` it uses the `x` value. Default x.
         * @param stepX This is added to the `x` amount, multiplied by the iteration counter. Default 0.
         * @param stepY This is added to the `y` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetXY<G extends Phaser.GameObjects.GameObject[]>(items: G, x: number, y?: number, stepX?: number, stepY?: number, index?: integer, direction?: integer): G;

        /**
         * Takes an array of Game Objects, or any objects that have the public property `y`
         * and then sets it to the given value.
         * 
         * The optional `step` property is applied incrementally, multiplied by each item in the array.
         * 
         * To use this with a Group: `SetY(group.getChildren(), value, step)`
         * @param items The array of items to be updated by this action.
         * @param value The amount to set the property to.
         * @param step This is added to the `value` amount, multiplied by the iteration counter. Default 0.
         * @param index An optional offset to start searching from within the items array. Default 0.
         * @param direction The direction to iterate through the array. 1 is from beginning to end, -1 from end to beginning. Default 1.
         */
        function SetY<G extends Phaser.GameObjects.GameObject[]>(items: G, value: number, step?: number, index?: integer, direction?: integer): G;

        /**
         * Iterate through items changing the position of each element to
         * be that of the element that came before it in the array (or after it if direction = 1)
         * The first items position is set to x/y.
         * The final x/y coords are returned
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param x [description]
         * @param y [description]
         * @param direction [description] Default 0.
         * @param output [description]
         */
        function ShiftPosition<G extends Phaser.GameObjects.GameObject[], O extends Phaser.Math.Vector2>(items: G, x: number, y: number, direction?: integer, output?: O): O;

        /**
         * Shuffles the array in place. The shuffled array is both modified and returned.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         */
        function Shuffle<G extends Phaser.GameObjects.GameObject[]>(items: G): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param property [description]
         * @param min [description]
         * @param max [description]
         * @param inc [description]
         */
        function SmootherStep<G extends Phaser.GameObjects.GameObject[]>(items: G, property: string, min: number, max: number, inc: number): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param property [description]
         * @param min [description]
         * @param max [description]
         * @param inc [description]
         */
        function SmoothStep<G extends Phaser.GameObjects.GameObject[]>(items: G, property: string, min: number, max: number, inc: number): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param property [description]
         * @param min [description]
         * @param max [description]
         * @param inc [description] Default false.
         */
        function Spread<G extends Phaser.GameObjects.GameObject[]>(items: G, property: string, min: number, max: number, inc?: number): G;

        /**
         * [description]
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         */
        function ToggleVisible<G extends Phaser.GameObjects.GameObject[]>(items: G): G;

        /**
         * Wrap each item's coordinates within a rectangle's area.
         * @param items An array of Game Objects. The contents of this array are updated by this Action.
         * @param rect The rectangle.
         * @param padding An amount added to each side of the rectangle during the operation. Default 0.
         */
        function WrapInRectangle<G extends Phaser.GameObjects.GameObject[]>(items: G, rect: Phaser.Geom.Rectangle, padding?: number): G;

    }

    namespace Animations {
        /**
         * A Frame based Animation.
         * 
         * 
         * 
         * This consists of a key, some default values (like the frame rate) and a bunch of Frame objects.
         * 
         * 
         * 
         * The Animation Manager creates these. Game Objects don't own an instance of these directly.
         * 
         * Game Objects have the Animation Component, which are like playheads to global Animations (these objects)
         * 
         * So multiple Game Objects can have playheads all pointing to this one Animation instance.
         */
        class Animation {
            /**
             * 
             * @param manager [description]
             * @param key [description]
             * @param config [description]
             */
            constructor(manager: Phaser.Animations.AnimationManager, key: string, config: AnimationConfig);

            /**
             * [description]
             */
            manager: Phaser.Animations.AnimationManager;

            /**
             * [description]
             */
            key: string;

            /**
             * A frame based animation (as opposed to a bone based animation)
             */
            type: string;

            /**
             * Extract all the frame data into the frames array
             */
            frames: Phaser.Animations.AnimationFrame[];

            /**
             * The frame rate of playback in frames per second (default 24 if duration is null)
             */
            frameRate: integer;

            /**
             * How long the animation should play for, in milliseconds.
             * If the `frameRate` property has been set then it overrides this value,
             * otherwise the `frameRate` is derived from `duration`.
             */
            duration: integer;

            /**
             * How many ms per frame, not including frame specific modifiers.
             */
            msPerFrame: integer;

            /**
             * Skip frames if the time lags, or always advanced anyway?
             */
            skipMissedFrames: boolean;

            /**
             * The delay in ms before the playback will begin.
             */
            delay: integer;

            /**
             * Number of times to repeat the animation. Set to -1 to repeat forever.
             */
            repeat: integer;

            /**
             * The delay in ms before the a repeat playthrough starts.
             */
            repeatDelay: integer;

            /**
             * Should the animation yoyo? (reverse back down to the start) before repeating?
             */
            yoyo: boolean;

            /**
             * Should sprite.visible = true when the animation starts to play?
             */
            showOnStart: boolean;

            /**
             * Should sprite.visible = false when the animation finishes?
             */
            hideOnComplete: boolean;

            /**
             * Global pause. All Game Objects using this Animation instance are impacted by this property.
             */
            paused: boolean;

            /**
             * Add frames to the end of the animation.
             * @param config [description]
             */
            addFrame(config: string | AnimationFrameConfig[]): Phaser.Animations.Animation;

            /**
             * Add frame/s into the animation.
             * @param index [description]
             * @param config [description]
             */
            addFrameAt(index: integer, config: string | AnimationFrameConfig[]): Phaser.Animations.Animation;

            /**
             * Check if the given frame index is valid.
             * @param index The index to be checked.
             */
            checkFrame(index: integer): boolean;

            /**
             * [description]
             * @param component [description]
             */
            protected completeAnimation(component: Phaser.GameObjects.Components.Animation): void;

            /**
             * [description]
             * @param component [description]
             * @param includeDelay [description] Default true.
             */
            protected getFirstTick(component: Phaser.GameObjects.Components.Animation, includeDelay?: boolean): void;

            /**
             * [description]
             * @param index [description]
             */
            protected getFrameAt(index: integer): Phaser.Animations.AnimationFrame;

            /**
             * [description]
             * @param textureManager [description]
             * @param frames [description]
             * @param defaultTextureKey [description]
             */
            getFrames(textureManager: Phaser.Textures.TextureManager, frames: string | AnimationFrameConfig[], defaultTextureKey?: string): Phaser.Animations.AnimationFrame[];

            /**
             * [description]
             * @param component [description]
             */
            getNextTick(component: Phaser.GameObjects.Components.Animation): void;

            /**
             * Returns the frame closest to the given progress value between 0 and 1.
             * @param value A value between 0 and 1.
             */
            getFrameByProgress(value: number): Phaser.Animations.AnimationFrame;

            /**
             * [description]
             * @param component [description]
             */
            nextFrame(component: Phaser.GameObjects.Components.Animation): void;

            /**
             * [description]
             * @param component [description]
             */
            previousFrame(component: Phaser.GameObjects.Components.Animation): void;

            /**
             * [description]
             * @param frame [description]
             */
            removeFrame(frame: Phaser.Animations.AnimationFrame): Phaser.Animations.Animation;

            /**
             * [description]
             * @param index [description]
             */
            removeFrameAt(index: integer): Phaser.Animations.Animation;

            /**
             * [description]
             * @param component [description]
             */
            repeatAnimation(component: Phaser.GameObjects.Components.Animation): void;

            /**
             * [description]
             * @param component [description]
             */
            setFrame(component: Phaser.GameObjects.Components.Animation): void;

            /**
             * [description]
             */
            toJSON(): JSONAnimation;

            /**
             * [description]
             */
            updateFrameSequence(): Phaser.Animations.Animation;

            /**
             * [description]
             */
            pause(): Phaser.Animations.Animation;

            /**
             * [description]
             */
            resume(): Phaser.Animations.Animation;

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * A single frame in an Animation sequence.
         * 
         * 
         * 
         * An AnimationFrame consists of a reference to the Texture it uses for rendering, references to other
         * 
         * frames in the animation, and index data. It also has the ability to fire its own `onUpdate` callback
         * 
         * and modify the animation timing.
         * 
         * 
         * 
         * AnimationFrames are generated automatically by the Animation class.
         */
        class AnimationFrame {
            /**
             * 
             * @param textureKey The key of the Texture this AnimationFrame uses.
             * @param textureFrame The key of the Frame within the Texture that this AnimationFrame uses.
             * @param index The index of this AnimationFrame within the Animation sequence.
             * @param frame A reference to the Texture Frame this AnimationFrame uses for rendering.
             */
            constructor(textureKey: string, textureFrame: string | integer, index: integer, frame: Phaser.Textures.Frame);

            /**
             * The key of the Texture this AnimationFrame uses.
             */
            textureKey: string;

            /**
             * The key of the Frame within the Texture that this AnimationFrame uses.
             */
            textureFrame: string | integer;

            /**
             * The index of this AnimationFrame within the Animation sequence.
             */
            index: integer;

            /**
             * A reference to the Texture Frame this AnimationFrame uses for rendering.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Is this the first frame in an animation sequence?
             */
            isFirst: boolean;

            /**
             * Is this the last frame in an animation sequence?
             */
            isLast: boolean;

            /**
             * A reference to the AnimationFrame that comes before this one in the animation, if any.
             */
            prevFrame: Phaser.Animations.AnimationFrame;

            /**
             * A reference to the AnimationFrame that comes after this one in the animation, if any.
             */
            nextFrame: Phaser.Animations.AnimationFrame;

            /**
             * Additional time (in ms) that this frame should appear for during playback.
             * The value is added onto the msPerFrame set by the animation.
             */
            duration: number;

            /**
             * What % through the animation does this frame come?
             * This value is generated when the animation is created and cached here.
             */
            progress: number;

            /**
             * Generates a JavaScript object suitable for converting to JSON.
             */
            toJSON(): JSONAnimationFrame;

            /**
             * Destroys this object by removing references to external resources and callbacks.
             */
            destroy(): void;

        }

        /**
         * The Animation Manager.
         * 
         * 
         * 
         * Animations are managed by the global Animation Manager. This is a singleton class that is
         * 
         * responsible for creating and delivering animations and their corresponding data to all Game Objects.
         * 
         * Unlike plugins it is owned by the Game instance, not the Scene.
         * 
         * 
         * 
         * Sprites and other Game Objects get the data they need from the AnimationManager.
         */
        class AnimationManager extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param game [description]
             */
            constructor(game: Phaser.Game);

            /**
             * [description]
             */
            protected game: Phaser.Game;

            /**
             * [description]
             */
            protected textureManager: Phaser.Textures.TextureManager;

            /**
             * [description]
             */
            globalTimeScale: number;

            /**
             * [description]
             */
            protected anims: Phaser.Structs.Map<string, Phaser.Animations.Animation>;

            /**
             * [description]
             */
            paused: boolean;

            /**
             * [description]
             */
            name: string;

            /**
             * [description]
             */
            boot(): void;

            /**
             * [description]
             * @param key [description]
             * @param animation [description]
             */
            add(key: string, animation: Phaser.Animations.Animation): Phaser.Animations.AnimationManager;

            /**
             * [description]
             * @param config [description]
             */
            create(config: AnimationConfig): Phaser.Animations.Animation;

            /**
             * [description]
             * @param data [description]
             * @param clearCurrentAnimations [description] Default false.
             */
            fromJSON(data: string | JSONAnimationManager | JSONAnimation, clearCurrentAnimations?: boolean): Phaser.Animations.Animation[];

            /**
             * [description]
             * @param key [description]
             * @param config [description]
             */
            generateFrameNames(key: string, config: GenerateFrameNamesConfig): AnimationFrameConfig[];

            /**
             * [description]
             * @param key [description]
             * @param config [description]
             */
            generateFrameNumbers(key: string, config: GenerateFrameNumbersConfig): AnimationFrameConfig[];

            /**
             * [description]
             * @param key [description]
             */
            get(key: string): Phaser.Animations.Animation;

            /**
             * Load an Animation into a Game Objects Animation Component.
             * @param child [description]
             * @param key [description]
             * @param startFrame [description]
             */
            load(child: Phaser.GameObjects.GameObject, key: string, startFrame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            pauseAll(): Phaser.Animations.AnimationManager;

            /**
             * [description]
             * @param key [description]
             * @param child [description]
             */
            play(key: string, child: Phaser.GameObjects.GameObject): Phaser.Animations.AnimationManager;

            /**
             * [description]
             * @param key [description]
             */
            remove(key: string): Phaser.Animations.Animation;

            /**
             * [description]
             */
            resumeAll(): Phaser.Animations.AnimationManager;

            /**
             * Takes an array of Game Objects that have the Animation Component and then
             * starts the given animation playing on them, each one offset by the
             * `stagger` amount given to this method.
             * @param key The key of the animation to play on the Game Objects.
             * @param children An array of Game Objects to play the animation on. They must have the Animation Component.
             * @param stagger The amount of time, in milliseconds, to offset each play time by. Default 0.
             */
            staggerPlay<G extends Phaser.GameObjects.GameObject[]>(key: string, children: Phaser.GameObjects.GameObject[], stagger?: number): G;

            /**
             * [description]
             * @param key [description]
             */
            toJSON(key: string): JSONAnimationManager;

            /**
             * [description]
             */
            destroy(): void;

        }

    }

    /**
     * The Phaser.Game instance is the main controller for the entire Phaser game. It is responsible
     * 
     * for handling the boot process, parsing the configuration values, creating the renderer,
     * 
     * and setting-up all of the global Phaser systems, such as sound and input.
     * 
     * Once that is complete it will start the Scene Manager and then begin the main game loop.
     * 
     * 
     * 
     * You should generally avoid accessing any of the systems created by Game, and instead use those
     * 
     * made available to you via the Phaser.Scene Systems class instead.
     */
    class Game {
        /**
         * 
         * @param GameConfig The configuration object for your Phaser Game instance.
         */
        constructor(GameConfig?: GameConfig);

        /**
         * The parsed Game Configuration object.
         * 
         * The values stored within this object are read-only and should not be changed at run-time.
         */
        config: Phaser.Boot.Config;

        /**
         * A reference to either the Canvas or WebGL Renderer that this Game is using.
         */
        renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

        /**
         * A reference to the HTML Canvas Element on which the renderer is drawing.
         */
        canvas: HTMLCanvasElement;

        /**
         * A reference to the Canvas Rendering Context belonging to the Canvas Element this game is rendering to.
         */
        context: CanvasRenderingContext2D;

        /**
         * A flag indicating when this Game instance has finished its boot process.
         */
        isBooted: boolean;

        /**
         * A flag indicating if this Game is currently running its game step or not.
         */
        isRunning: boolean;

        /**
         * An Event Emitter which is used to broadcast game-level events from the global systems.
         */
        events: Phaser.Events.EventEmitter;

        /**
         * An instance of the Animation Manager.
         * 
         * The Animation Manager is a global system responsible for managing all animations used within your game.
         */
        anims: Phaser.Animations.AnimationManager;

        /**
         * An instance of the Texture Manager.
         * 
         * The Texture Manager is a global system responsible for managing all textures being used by your game.
         */
        textures: Phaser.Textures.TextureManager;

        /**
         * An instance of the Cache Manager.
         * 
         * The Cache Manager is a global system responsible for caching, accessing and releasing external game assets.
         */
        cache: Phaser.Cache.CacheManager;

        /**
         * An instance of the Data Manager
         */
        registry: Phaser.Data.DataManager;

        /**
         * An instance of the Input Manager.
         * 
         * The Input Manager is a global system responsible for the capture of browser-level input events.
         */
        input: Phaser.Input.InputManager;

        /**
         * An instance of the Scene Manager.
         * 
         * The Scene Manager is a global system responsible for creating, modifying and updating the Scenes in your game.
         */
        scene: Phaser.Scenes.SceneManager;

        /**
         * A reference to the Device inspector.
         * 
         * Contains information about the device running this game, such as OS, browser vendor and feature support.
         * Used by various systems to determine capabilities and code paths.
         */
        device: Phaser.DeviceConf;

        /**
         * An instance of the base Sound Manager.
         * 
         * The Sound Manager is a global system responsible for the playback and updating of all audio in your game.
         */
        sound: Phaser.Sound.BaseSoundManager;

        /**
         * An instance of the Time Step.
         * 
         * The Time Step is a global system responsible for setting-up and responding to the browser frame events, processing
         * them and calculating delta values. It then automatically calls the game step.
         */
        loop: Phaser.Boot.TimeStep;

        /**
         * An instance of the Plugin Manager.
         * 
         * The Plugin Manager is a global system that allows plugins to register themselves with it, and can then install
         * those plugins into Scenes as required.
         */
        plugins: Phaser.Boot.PluginManager;

        /**
         * This method is called automatically when the DOM is ready. It is responsible for creating the renderer,
         * displaying the Debug Header, adding the game canvas to the DOM and emitting the 'boot' event.
         * It listens for a 'ready' event from the base systems and once received it will call `Game.start`.
         */
        protected boot(): void;

        /**
         * Called automatically by Game.boot once all of the global systems have finished setting themselves up.
         * By this point the Game is now ready to start the main loop running.
         * It will also enable the Visibility Handler.
         */
        protected start(): void;

        /**
         * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of
         * Request Animation Frame, or Set Timeout on very old browsers.)
         * 
         * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.
         * 
         * It will then render each Scene in turn, via the Renderer. This process emits `prerender` and `postrender` events.
         * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
         * @param delta The delta time, in ms, elapsed since the last frame.
         */
        step(time: integer, delta: number): void;

        /**
         * A special version of the Game Step for the HEADLESS renderer only.
         * 
         * The main Game Step. Called automatically by the Time Step, once per browser frame (typically as a result of
         * Request Animation Frame, or Set Timeout on very old browsers.)
         * 
         * The step will update the global managers first, then proceed to update each Scene in turn, via the Scene Manager.
         * 
         * This process emits `prerender` and `postrender` events, even though nothing actually displays.
         * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
         * @param delta The delta time elapsed since the last frame.
         */
        headlessStep(time: integer, delta: number): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will pause the main loop and then emit a pause event.
         */
        protected onHidden(): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will resume the main loop and then emit a resume event.
         */
        protected onVisible(): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will set the main loop into a 'blurred' state, which pauses it.
         */
        protected onBlur(): void;

        /**
         * Called automatically by the Visibility Handler.
         * This will set the main loop into a 'focused' state, which resumes it.
         */
        protected onFocus(): void;

        /**
         * Updates the Game Config with the new width and height values given.
         * Then resizes the Renderer and Input Manager scale.
         * @param width The new width of the game.
         * @param height The new height of the game.
         */
        resize(width: number, height: number): void;

        /**
         * Flags this Game instance as needing to be destroyed on the next frame.
         * It will wait until the current frame has completed and then call `runDestroy` internally.
         * @param removeCanvas Set to `true` if you would like the parent canvas element removed from the DOM, or `false` to leave it in place.
         */
        destroy(removeCanvas: boolean): void;

    }

    namespace Boot {
        /**
         * [description]
         */
        class Config {
            /**
             * 
             * @param GameConfig The configuration object for your Phaser Game instance.
             */
            constructor(GameConfig?: GameConfig);

        }

        /**
         * Called automatically by Phaser.Game and responsible for creating the renderer it will use.
         * 
         * Relies upon two webpack global flags to be defined: `WEBGL_RENDERER` and `CANVAS_RENDERER` during build time, but not at run-time.
         * @param game The Phaser.Game instance on which the renderer will be set.
         */
        function CreateRenderer(game: Phaser.Game): void;

        /**
         * Called automatically by Phaser.Game and responsible for creating the console.log debug header.
         * 
         * You can customize or disable the header via the Game Config object.
         * @param game The Phaser.Game instance which will output this debug header.
         */
        function DebugHeader(game: Phaser.Game): void;

        /**
         * The PluginManager is global and belongs to the Game instance, not a Scene.
         * 
         * It handles the installation and removal of all global and Scene based plugins.
         * 
         * Plugins automatically register themselves with the PluginManager in their respective classes.
         */
        class PluginManager {
            /**
             * 
             * @param game [description]
             */
            constructor(game: Phaser.Game);

            /**
             * [description]
             */
            game: Phaser.Game;

            /**
             * [description]
             */
            boot(): void;

            /**
             * [description]
             * @param sys [description]
             * @param globalPlugins [description]
             */
            installGlobal(sys: Phaser.Scenes.Systems, globalPlugins: any[]): void;

            /**
             * [description]
             * @param sys [description]
             * @param scenePlugins [description]
             */
            installLocal(sys: Phaser.Scenes.Systems, scenePlugins: any[]): void;

            /**
             * [description]
             * @param key [description]
             */
            remove(key: string): void;

            /**
             * [description]
             */
            destroy(): void;

            /**
             * Static method called directly by the Plugins
             * Key is a reference used to get the plugin from the plugins object (i.e. InputPlugin)
             * Plugin is the object to instantiate to create the plugin
             * Mapping is what the plugin is injected into the Scene.Systems as (i.e. input)
             * @param key [description]
             * @param plugin [description]
             * @param mapping [description]
             */
            static register(key: string, plugin: object, mapping: string): void;

        }

        /**
         * [description]
         */
        class TimeStep {
            /**
             * 
             * @param game A reference to the Phaser.Game instance that owns this Time Step.
             */
            constructor(game: Phaser.Game, config: FPSConfig);

            /**
             * A reference to the Phaser.Game instance.
             */
            game: Phaser.Game;

            /**
             * [description]
             */
            raf: Phaser.DOM.RequestAnimationFrame;

            /**
             * A flag that is set once the TimeStep has started running and toggled when it stops.
             */
            started: boolean;

            /**
             * A flag that is set once the TimeStep has started running and toggled when it stops.
             * The difference between this value and `started` is that `running` is toggled when
             * the TimeStep is sent to sleep, where-as `started` remains `true`, only changing if
             * the TimeStep is actually stopped, not just paused.
             */
            running: boolean;

            /**
             * The minimum fps rate you want the Time Step to run at.
             */
            minFps: integer;

            /**
             * The target fps rate for the Time Step to run at.
             * 
             * Setting this value will not actually change the speed at which the browser runs, that is beyond
             * the control of Phaser. Instead, it allows you to determine performance issues and if the Time Step
             * is spiraling out of control.
             */
            targetFps: integer;

            /**
             * An exponential moving average of the frames per second.
             */
            actualFps: integer;

            /**
             * [description]
             */
            nextFpsUpdate: integer;

            /**
             * The number of frames processed this second.
             */
            framesThisSecond: integer;

            /**
             * A callback to be invoked each time the Time Step steps.
             */
            callback: TimeStepCallback;

            /**
             * You can force the Time Step to use Set Timeout instead of Request Animation Frame by setting
             * the `forceSetTimeOut` property to `true` in the Game Configuration object. It cannot be changed at run-time.
             */
            forceSetTimeOut: boolean;

            /**
             * [description]
             */
            time: integer;

            /**
             * [description]
             */
            startTime: integer;

            /**
             * [description]
             */
            lastTime: integer;

            /**
             * [description]
             */
            frame: integer;

            /**
             * [description]
             */
            inFocus: boolean;

            /**
             * [description]
             */
            delta: integer;

            /**
             * [description]
             */
            deltaIndex: integer;

            /**
             * [description]
             */
            deltaHistory: any[];

            /**
             * [description]
             */
            deltaSmoothingMax: integer;

            /**
             * [description]
             */
            panicMax: integer;

            /**
             * The actual elapsed time in ms between one update and the next.
             * Unlike with `delta` no smoothing, capping, or averaging is applied to this value.
             * So please be careful when using this value in calculations.
             */
            rawDelta: number;

            /**
             * Called when the DOM window.onBlur event triggers.
             */
            blur(): void;

            /**
             * Called when the DOM window.onFocus event triggers.
             */
            focus(): void;

            /**
             * Called when the visibility API says the game is 'hidden' (tab switch out of view, etc)
             */
            pause(): void;

            /**
             * Called when the visibility API says the game is 'visible' again (tab switch back into view, etc)
             */
            resume(): void;

            /**
             * [description]
             */
            resetDelta(): void;

            /**
             * Starts the Time Step running, if it is not already doing so.
             * Called automatically by the Game Boot process.
             * @param callback The callback to be invoked each time the Time Step steps.
             */
            start(callback: TimeStepCallback): void;

            /**
             * The main step method. This is called each time the browser updates, either by Request Animation Frame,
             * or by Set Timeout. It is responsible for calculating the delta values, frame totals, cool down history and more.
             * You generally should never call this method directly.
             * @param time The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.
             */
            step(time: integer): void;

            /**
             * Manually calls TimeStep.step, passing in the performance.now value to it.
             */
            tick(): void;

            /**
             * Sends the TimeStep to sleep, stopping Request Animation Frame (or SetTimeout) and toggling the `running` flag to false.
             */
            sleep(): void;

            /**
             * Wakes-up the TimeStep, restarting Request Animation Frame (or SetTimeout) and toggling the `running` flag to true.
             * The `seamless` argument controls if the wake-up should adjust the start time or not.
             * @param seamless Adjust the startTime based on the lastTime values. Default false.
             */
            wake(seamless?: boolean): void;

            /**
             * Stops the TimeStep running.
             */
            stop(): Phaser.Boot.TimeStep;

            /**
             * Destroys the TimeStep. This will stop Request Animation Frame, stop the step, clear the callbacks and null
             * any objects.
             */
            destroy(): void;

        }

        /**
         * The Visibility Handler is responsible for listening out for document level visibility change events.
         * This includes `visibilitychange` if the browser supports it, and blur and focus events. It then uses
         * the provided Event Emitter and fires the related events.
         * @param eventEmitter The EventEmitter that will emit the visibility events.
         */
        function VisibilityHandler(eventEmitter: Phaser.Events.EventEmitter): void;

    }

    namespace Cache {
        /**
         * The BaseCache is a base Cache class that can be used for storing references to any kind of data.
         * 
         * 
         * 
         * Data can be added, retrieved and removed based on the given keys.
         * 
         * 
         * 
         * Keys are string-based.
         */
        class BaseCache {
            /**
             * The Map in which the cache objects are stored.
             * 
             * You can query the Map directly or use the BaseCache methods.
             */
            entries: Phaser.Structs.Map<String, any>;

            /**
             * An instance of EventEmitter used by the cache to emit related events.
             */
            events: Phaser.Events.EventEmitter;

            /**
             * Adds an item to this cache. The item is referenced by a unique string, which you are responsible
             * for setting and keeping track of. The item can only be retrieved by using this string.
             * @param key The unique key by which the data added to the cache will be referenced.
             * @param data The data to be stored in the cache.
             */
            add(key: string, data: any): Phaser.Cache.BaseCache;

            /**
             * Checks if this cache contains an item matching the given key.
             * @param key The unique key of the item to be checked in this cache.
             */
            has(key: string): boolean;

            /**
             * Gets an item from this cache based on the given key.
             * @param key The unique key of the item to be retrieved from this cache.
             */
            get(key: string): any;

            /**
             * Removes and item from this cache based on the given key.
             * 
             * If an entry matching the key is found it is removed from the cache and a `remove` event emitted.
             * No additional checks are done on the item removed. If other systems or parts of your game code
             * are relying on this item, it is up to you to sever those relationships prior to removing the item.
             * @param key The unique key of the item to remove from the cache.
             */
            remove(key: string): Phaser.Cache.BaseCache;

            /**
             * Destroys this cache and all items within it.
             */
            destroy(): void;

        }

        /**
         * The Cache Manager is the global cache owned and maintained by the Game instance.
         * 
         * 
         * 
         * Various systems, such as the file Loader, rely on this cache in order to store the files
         * 
         * it has loaded. The manager itself doesn't store any files, but instead owns multiple BaseCache
         * 
         * instances, one per type of file. You can also add your own custom caches.
         */
        class CacheManager {
            /**
             * 
             * @param game A reference to the Phaser.Game instance that owns this CacheManager.
             */
            constructor(game: Phaser.Game);

            /**
             * A reference to the Phaser.Game instance that owns this CacheManager.
             */
            protected game: Phaser.Game;

            /**
             * A Cache storing all binary files, typically added via the Loader.
             */
            binary: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all bitmap font data files, typically added via the Loader.
             * Only the font data is stored in this cache, the textures are part of the Texture Manager.
             */
            bitmapFont: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all JSON data files, typically added via the Loader.
             */
            json: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all physics data files, typically added via the Loader.
             */
            physics: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all shader source files, typically added via the Loader.
             */
            shader: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all non-streaming audio files, typically added via the Loader.
             */
            audio: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all text files, typically added via the Loader.
             */
            text: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all WaveFront OBJ files, typically added via the Loader.
             */
            obj: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all tilemap data files, typically added via the Loader.
             * Only the data is stored in this cache, the textures are part of the Texture Manager.
             */
            tilemap: Phaser.Cache.BaseCache;

            /**
             * A Cache storing all xml data files, typically added via the Loader.
             */
            xml: Phaser.Cache.BaseCache;

            /**
             * An object that contains your own custom BaseCache entries.
             * Add to this via the `addCustom` method.
             */
            custom: {[key: string]: Phaser.Cache.BaseCache};

            /**
             * Add your own custom Cache for storing your own files.
             * The cache will be available under `Cache.custom.key`.
             * The cache will only be created if the key is not already in use.
             * @param key The unique key of your custom cache.
             */
            addCustom(key: string): Phaser.Cache.BaseCache;

            /**
             * Removes all entries from all BaseCaches and destroys all custom caches.
             */
            destroy(): void;

        }

    }

    namespace Cameras {
        namespace Scene2D {
            /**
             * A Camera.
             * 
             * 
             * 
             * The Camera is the way in which all games are rendered in Phaser. They provide a view into your game world,
             * 
             * and can be positioned, rotated, zoomed and scrolled accordingly.
             * 
             * 
             * 
             * A Camera consists of two elements: The viewport and the scroll values.
             * 
             * 
             * 
             * The viewport is the physical position and size of the Camera within your game. Cameras, by default, are
             * 
             * created the same size as your game, but their position and size can be set to anything. This means if you
             * 
             * wanted to create a camera that was 320x200 in size, positioned in the bottom-right corner of your game,
             * 
             * you'd adjust the viewport to do that (using methods like `setViewport` and `setSize`).
             * 
             * 
             * 
             * If you wish to change where the Camera is looking in your game, then you scroll it. You can do this
             * 
             * via the properties `scrollX` and `scrollY` or the method `setScroll`. Scrolling has no impact on the
             * 
             * viewport, and changing the viewport has no impact on the scrolling.
             * 
             * 
             * 
             * By default a Camera will render all Game Objects it can see. You can change this using the `ignore` method,
             * 
             * allowing you to filter Game Objects out on a per-Camera basis.
             * 
             * 
             * 
             * A Camera also has built-in special effects including Fade, Flash and Camera Shake.
             */
            class Camera extends Phaser.Events.EventEmitter {
                /**
                 * 
                 * @param x The x position of the Camera, relative to the top-left of the game canvas.
                 * @param y The y position of the Camera, relative to the top-left of the game canvas.
                 * @param width The width of the Camera, in pixels.
                 * @param height The height of the Camera, in pixels.
                 */
                constructor(x: number, y: number, width: number, height: number);

                /**
                 * A reference to the Scene this camera belongs to.
                 */
                scene: Phaser.Scene;

                /**
                 * The name of the Camera. This is left empty for your own use.
                 */
                name: string;

                /**
                 * The x position of the Camera, relative to the top-left of the game canvas.
                 */
                x: number;

                /**
                 * The y position of the Camera, relative to the top-left of the game canvas.
                 */
                y: number;

                /**
                 * The width of the Camera, in pixels.
                 */
                width: number;

                /**
                 * The height of the Camera, in pixels.
                 */
                height: number;

                /**
                 * Should this camera round its pixel values to integers?
                 */
                roundPixels: boolean;

                /**
                 * Is this Camera using a bounds to restrict scrolling movement?
                 * Set this property along with the bounds via `Camera.setBounds`.
                 */
                useBounds: boolean;

                /**
                 * Does this Camera allow the Game Objects it renders to receive input events?
                 */
                inputEnabled: boolean;

                /**
                 * The horizontal scroll position of this camera.
                 * Optionally restricted via the Camera bounds.
                 */
                scrollX: number;

                /**
                 * The vertical scroll position of this camera.
                 * Optionally restricted via the Camera bounds.
                 */
                scrollY: number;

                /**
                 * The Camera zoom value. Change this value to zoom in, or out of, a Scene.
                 * Set to 1 to return to the default zoom level.
                 */
                zoom: number;

                /**
                 * The rotation of the Camera. This influences the rendering of all Game Objects visible by this camera.
                 */
                rotation: number;

                /**
                 * A local transform matrix used for internal calculations.
                 */
                matrix: Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Does this Camera have a transparent background?
                 */
                transparent: boolean;

                /**
                 * The background color of this Camera. Only used if `transparent` is `false`.
                 */
                backgroundColor: Phaser.Display.Color;

                /**
                 * The Camera Fade effect handler.
                 * To fade this camera see the `Camera.fade` methods.
                 */
                fadeEffect: Phaser.Cameras.Scene2D.Effects.Fade;

                /**
                 * The Camera Flash effect handler.
                 * To flash this camera see the `Camera.flash` method.
                 */
                flashEffect: Phaser.Cameras.Scene2D.Effects.Flash;

                /**
                 * The Camera Shake effect handler.
                 * To shake this camera see the `Camera.shake` method.
                 */
                shakeEffect: Phaser.Cameras.Scene2D.Effects.Shake;

                /**
                 * Should the camera cull Game Objects before checking them for input hit tests?
                 * In some special cases it may be beneficial to disable this.
                 */
                disableCull: boolean;

                /**
                 * A temporary array of culled objects.
                 */
                culledObjects: Phaser.GameObjects.GameObject[];

                /**
                 * Scrolls the Camera so that it is looking at the center of the Camera Bounds (if previously enabled)
                 */
                centerToBounds(): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Scrolls the Camera so that it is re-centered based on its viewport size.
                 */
                centerToSize(): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Takes an array of Game Objects and returns a new array featuring only those objects
                 * visible by this camera.
                 * @param renderableObjects An array of Game Objects to cull.
                 */
                cull<G extends Phaser.GameObjects.GameObject[]>(renderableObjects: G): G;

                /**
                 * Fades the Camera in from the given color over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fadeIn(duration?: integer, red?: integer, green?: integer, blue?: integer, callback?: Function, context?: any): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Fades the Camera out to the given color over the duration specified.
                 * This is an alias for Camera.fade that forces the fade to start, regardless of existing fades.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fadeOut(duration?: integer, red?: integer, green?: integer, blue?: integer, callback?: Function, context?: any): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Fades the Camera from the given color to transparent over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param force Force the effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fadeFrom(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: Function, context?: any): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Fades the Camera from transparent to the given color over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 1000.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                 * @param force Force the effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                fade(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: Function, context?: any): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Flashes the Camera by setting it to the given color immediately and then fading it away again quickly over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 250.
                 * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 255.
                 * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 255.
                 * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 255.
                 * @param force Force the effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                flash(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: Function, context?: any): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Shakes the Camera by the given intensity over the duration specified.
                 * @param duration The duration of the effect in milliseconds. Default 100.
                 * @param intensity The intensity of the shake. Default 0.05.
                 * @param force Force the shake effect to start immediately, even if already running. Default false.
                 * @param callback This callback will be invoked every frame for the duration of the effect.
                 * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                 * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                 */
                shake(duration?: integer, intensity?: number, force?: boolean, callback?: Function, context?: any): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Converts the given `x` and `y` coordinates into World space, based on this Cameras transform.
                 * You can optionally provide a Vector2, or similar object, to store the results in.
                 * @param x The x position to convert to world space.
                 * @param y The y position to convert to world space.
                 * @param output An optional object to store the results in. If not provided a new Vector2 will be created.
                 */
                getWorldPoint<O extends Phaser.Math.Vector2>(x: number, y: number, output?: O): O;

                /**
                 * Given a Game Object, or an array of Game Objects, it will update all of their camera filter settings
                 * so that they are ignored by this Camera. This means they will not be rendered by this Camera.
                 * @param gameObject The Game Object, or array of Game Objects, to be ignored by this Camera.
                 */
                ignore(gameObject: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Internal preRender step.
                 * @param baseScale The base scale, as set in the Camera Manager.
                 * @param resolution The game resolution.
                 */
                protected preRender(baseScale: number, resolution: number): void;

                /**
                 * If this Camera has previously had movement bounds set on it, this will remove them.
                 */
                removeBounds(): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the rotation of this Camera. This causes everything it renders to appear rotated.
                 * 
                 * Rotating a camera does not rotate the viewport itself, it is applied during rendering.
                 * @param value The cameras angle of rotation, given in degrees. Default 0.
                 */
                setAngle(value?: number): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Sets the background color for this Camera.
                 * 
                 * By default a Camera has a transparent background but it can be given a solid color, with any level
                 * of transparency, via this method.
                 * 
                 * The color value can be specified using CSS color notation, hex or numbers.
                 * @param color The color value. In CSS, hex or numeric color notation. Default 'rgba(0,0,0,0)'.
                 */
                setBackgroundColor(color?: string | number | InputColorObject): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the world bounds for this Camera.
                 * 
                 * A Camera bounds controls where the camera can scroll to within the world. It does not limit
                 * rendering of the camera, or placement of the viewport within your game.
                 * @param x The top-left x coordinate of the bounds.
                 * @param y The top-left y coordinate of the bounds.
                 * @param width The width of the bounds, in pixels.
                 * @param height The height of the bounds, in pixels.
                 */
                setBounds(x: integer, y: integer, width: integer, height: integer): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Sets the name of this Camera.
                 * This value is for your own use and isn't used internally.
                 * @param value The name of the Camera. Default ''.
                 */
                setName(value?: string): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the position of the Camera viewport within the game.
                 * 
                 * This does not change where the camera is 'looking'. See `setScroll` to control that.
                 * @param x The top-left x coordinate of the Camera viewport.
                 * @param y The top-left y coordinate of the Camera viewport. Default x.
                 */
                setPosition(x: number, y?: number): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the rotation of this Camera. This causes everything it renders to appear rotated.
                 * 
                 * Rotating a camera does not rotate the viewport itself, it is applied during rendering.
                 * @param value The rotation of the Camera, in radians. Default 0.
                 */
                setRotation(value?: number): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Should the Camera round pixel values to whole integers when scrolling?
                 * In some types of game this is required to prevent sub-pixel aliasing.
                 * @param value `true` to round Camera pixels, `false` to not.
                 */
                setRoundPixels(value: boolean): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Sets the Scene the Camera is bound to.
                 * @param scene The Scene the camera is bound to.
                 */
                setScene(scene: Phaser.Scene): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the position of where the Camera is looking within the game.
                 * You can also modify the properties `Camera.scrollX` and `Camera.scrollY` directly.
                 * Use this method, or the scroll properties, to move your camera around the game world.
                 * 
                 * This does not change where the camera viewport is placed. See `setPosition` to control that.
                 * @param x The x coordinate of the Camera in the game world.
                 * @param y The y coordinate of the Camera in the game world. Default x.
                 */
                setScroll(x: number, y?: number): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the size of the Camera viewport.
                 * 
                 * By default a Camera is the same size as the game, but can be made smaller via this method,
                 * allowing you to create mini-cam style effects by creating and positioning a smaller Camera
                 * viewport within your game.
                 * @param width The width of the Camera viewport.
                 * @param height The height of the Camera viewport. Default width.
                 */
                setSize(width: integer, height?: integer): Phaser.Cameras.Scene2D.Camera;

                /**
                 * This method sets the position and size of the Camera viewport in a single call.
                 * 
                 * If you're trying to change where the Camera is looking at in your game, then see
                 * the method `Camera.setScroll` instead. This method is for changing the viewport
                 * itself, not what the camera can see.
                 * 
                 * By default a Camera is the same size as the game, but can be made smaller via this method,
                 * allowing you to create mini-cam style effects by creating and positioning a smaller Camera
                 * viewport within your game.
                 * @param x The top-left x coordinate of the Camera viewport.
                 * @param y The top-left y coordinate of the Camera viewport.
                 * @param width The width of the Camera viewport.
                 * @param height The height of the Camera viewport. Default width.
                 */
                setViewport(x: number, y: number, width: integer, height?: integer): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Set the zoom value of the Camera.
                 * 
                 * Changing to a smaller value, such as 0.5, will cause the camera to 'zoom out'.
                 * Changing to a larger value, such as 2, will cause the camera to 'zoom in'.
                 * 
                 * A value of 1 means 'no zoom' and is the default.
                 * 
                 * Changing the zoom does not impact the Camera viewport in any way, it is only applied during rendering.
                 * @param value The zoom value of the Camera. Default 1.
                 */
                setZoom(value?: number): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Sets the Camera to follow a Game Object.
                 * 
                 * When enabled the Camera will automatically adjust its scroll position to keep the target Game Object
                 * in its center.
                 * @param target The target for the Camera to follow.
                 * @param roundPx Round the movement pixels to whole integers? Default false.
                 */
                startFollow(target: Phaser.GameObjects.GameObject | object, roundPx?: boolean): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Stops a Camera from following a Game Object, if previously set via `Camera.startFollow`.
                 */
                stopFollow(): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Returns an Object suitable for JSON storage containing all of the Camera viewport and rendering properties.
                 */
                toJSON(): JSONCamera;

                /**
                 * Resets any active FX, such as a fade, flash or shake. Useful to call after a fade in order to
                 * remove the fade.
                 */
                resetFX(): Phaser.Cameras.Scene2D.Camera;

                /**
                 * Internal method called automatically by the Camera Manager.
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                protected update(time: integer, delta: number): void;

                /**
                 * Destroys this Camera instance. You rarely need to call this directly.
                 * 
                 * Called by the Camera Manager. If you wish to destroy a Camera please use `CameraManager.remove` as
                 * cameras are stored in a pool, ready for recycling later, and calling this directly will prevent that.
                 */
                destroy(): void;

            }

            /**
             * [description]
             */
            class CameraManager {
                /**
                 * 
                 * @param scene The Scene that owns the Camera Manager plugin.
                 */
                constructor(scene: Phaser.Scene);

                /**
                 * The Scene that owns the Camera Manager plugin.
                 */
                scene: Phaser.Scene;

                /**
                 * A reference to the Scene.Systems handler for the Scene that owns the Camera Manager.
                 */
                systems: Phaser.Scenes.Systems;

                /**
                 * The current Camera ID.
                 */
                currentCameraId: number;

                /**
                 * An Array of the Camera objects being managed by this Camera Manager.
                 */
                cameras: Phaser.Cameras.Scene2D.Camera[];

                /**
                 * A pool of Camera objects available to be used by the Camera Manager.
                 */
                cameraPool: Phaser.Cameras.Scene2D.Camera[];

                /**
                 * The default Camera in the Camera Manager.
                 */
                main: Phaser.Cameras.Scene2D.Camera;

                /**
                 * This scale affects all cameras. It's used by Scale Manager.
                 */
                baseScale: number;

                /**
                 * [description]
                 * @param x [description] Default 0.
                 * @param y [description] Default 0.
                 * @param width [description]
                 * @param height [description]
                 * @param makeMain [description] Default false.
                 * @param name [description] Default ''.
                 */
                add(x?: number, y?: number, width?: number, height?: number, makeMain?: boolean, name?: string): Phaser.Cameras.Scene2D.Camera;

                /**
                 * [description]
                 * @param camera [description]
                 */
                addExisting(camera: Phaser.Cameras.Scene2D.Camera): Phaser.Cameras.Scene2D.Camera;

                /**
                 * [description]
                 * @param config [description]
                 */
                fromJSON(config: InputJSONCameraObject | InputJSONCameraObject[]): Phaser.Cameras.Scene2D.CameraManager;

                /**
                 * [description]
                 * @param name [description]
                 */
                getCamera(name: string): Phaser.Cameras.Scene2D.Camera;

                /**
                 * [description]
                 * @param pointer [description]
                 */
                getCameraBelowPointer(pointer: Phaser.Input.Pointer): Phaser.Cameras.Scene2D.Camera;

                /**
                 * [description]
                 * @param camera [description]
                 */
                remove(camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 * @param renderer The Renderer that will render the children to this camera.
                 * @param children An array of renderable Game Objects.
                 * @param interpolation Interpolation value. Reserved for future use.
                 */
                render(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer, children: Phaser.GameObjects.GameObject[], interpolation: number): void;

                /**
                 * [description]
                 */
                resetAll(): Phaser.Cameras.Scene2D.Camera;

                /**
                 * [description]
                 * @param timestep [description]
                 * @param delta [description]
                 */
                update(timestep: number, delta: number): void;

                /**
                 * Resizes all cameras to the given dimensions.
                 * @param width The new width of the camera.
                 * @param height The new height of the camera.
                 */
                resize(width: number, height: number): void;

            }

            namespace Effects {
                /**
                 * A Camera Fade effect.
                 * 
                 * 
                 * 
                 * This effect will fade the camera viewport to the given color, over the duration specified.
                 * 
                 * 
                 * 
                 * Only the camera viewport is faded. None of the objects it is displaying are impacted, i.e. their colors do
                 * 
                 * not change.
                 * 
                 * 
                 * 
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * 
                 * which is invoked each frame for the duration of the effect, if required.
                 */
                class Fade {
                    /**
                     * 
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Phaser.Cameras.Scene2D.Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    camera: Phaser.Cameras.Scene2D.Camera;

                    /**
                     * Is this effect actively running?
                     */
                    isRunning: boolean;

                    /**
                     * Has this effect finished running?
                     * 
                     * This is different from `isRunning` because it remains set to `true` when the effect is over,
                     * until the effect is either reset or started again.
                     */
                    isComplete: boolean;

                    /**
                     * The direction of the fade.
                     * `true` = fade out (transparent to color), `false` = fade in (color to transparent)
                     */
                    direction: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    duration: integer;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * Fades the Camera to or from the given color over the duration specified.
                     * @param direction The direction of the fade. `true` = fade out (transparent to color), `false` = fade in (color to transparent) Default true.
                     * @param duration The duration of the effect in milliseconds. Default 1000.
                     * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 0.
                     * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 0.
                     * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 0.
                     * @param force Force the effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(direction?: boolean, duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: CameraFadeCallback, context?: any): Phaser.Cameras.Scene2D.Camera;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally by the Canvas Renderer.
                     * @param ctx The Canvas context to render to.
                     */
                    postRenderCanvas(ctx: CanvasRenderingContext2D): boolean;

                    /**
                     * Called internally by the WebGL Renderer.
                     * @param pipeline The WebGL Pipeline to render to.
                     * @param getTintFunction A function that will return the gl safe tint colors.
                     */
                    postRenderWebGL(pipeline: Phaser.Renderer.WebGL.Pipelines.FlatTintPipeline, getTintFunction: Function): boolean;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;

                }

                /**
                 * A Camera Flash effect.
                 * 
                 * 
                 * 
                 * This effect will flash the camera viewport to the given color, over the duration specified.
                 * 
                 * 
                 * 
                 * Only the camera viewport is flashed. None of the objects it is displaying are impacted, i.e. their colors do
                 * 
                 * not change.
                 * 
                 * 
                 * 
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * 
                 * which is invoked each frame for the duration of the effect, if required.
                 */
                class Flash {
                    /**
                     * 
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Phaser.Cameras.Scene2D.Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    camera: Phaser.Cameras.Scene2D.Camera;

                    /**
                     * Is this effect actively running?
                     */
                    isRunning: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    duration: integer;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * Flashes the Camera to or from the given color over the duration specified.
                     * @param duration The duration of the effect in milliseconds. Default 250.
                     * @param red The amount to fade the red channel towards. A value between 0 and 255. Default 255.
                     * @param green The amount to fade the green channel towards. A value between 0 and 255. Default 255.
                     * @param blue The amount to fade the blue channel towards. A value between 0 and 255. Default 255.
                     * @param force Force the effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(duration?: integer, red?: integer, green?: integer, blue?: integer, force?: boolean, callback?: CameraFlashCallback, context?: any): Phaser.Cameras.Scene2D.Camera;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally by the Canvas Renderer.
                     * @param ctx The Canvas context to render to.
                     */
                    postRenderCanvas(ctx: CanvasRenderingContext2D): boolean;

                    /**
                     * Called internally by the WebGL Renderer.
                     * @param pipeline The WebGL Pipeline to render to.
                     * @param getTintFunction A function that will return the gl safe tint colors.
                     */
                    postRenderWebGL(pipeline: Phaser.Renderer.WebGL.Pipelines.FlatTintPipeline, getTintFunction: Function): boolean;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;

                }

                /**
                 * A Camera Shake effect.
                 * 
                 * 
                 * 
                 * This effect will shake the camera viewport by a random amount, bounded by the specified intensity, each frame.
                 * 
                 * 
                 * 
                 * Only the camera viewport is moved. None of the objects it is displaying are impacted, i.e. their positions do
                 * 
                 * not change.
                 * 
                 * 
                 * 
                 * The effect will dispatch several events on the Camera itself and you can also specify an `onUpdate` callback,
                 * 
                 * which is invoked each frame for the duration of the effect if required.
                 */
                class Shake {
                    /**
                     * 
                     * @param camera The camera this effect is acting upon.
                     */
                    constructor(camera: Phaser.Cameras.Scene2D.Camera);

                    /**
                     * The Camera this effect belongs to.
                     */
                    camera: Phaser.Cameras.Scene2D.Camera;

                    /**
                     * Is this effect actively running?
                     */
                    isRunning: boolean;

                    /**
                     * The duration of the effect, in milliseconds.
                     */
                    duration: integer;

                    /**
                     * The intensity of the effect. Use small float values. The default when the effect starts is 0.05.
                     * This is a Vector2 object, allowing you to control the shake intensity independently across x and y.
                     * You can modify this value while the effect is active to create more varied shake effects.
                     */
                    intensity: Phaser.Math.Vector2;

                    /**
                     * If this effect is running this holds the current percentage of the progress, a value between 0 and 1.
                     */
                    progress: number;

                    /**
                     * Shakes the Camera by the given intensity over the duration specified.
                     * @param duration The duration of the effect in milliseconds. Default 100.
                     * @param intensity The intensity of the shake. Default 0.05.
                     * @param force Force the shake effect to start immediately, even if already running. Default false.
                     * @param callback This callback will be invoked every frame for the duration of the effect.
                     * It is sent two arguments: A reference to the camera and a progress amount between 0 and 1 indicating how complete the effect is.
                     * @param context The context in which the callback is invoked. Defaults to the Scene to which the Camera belongs.
                     */
                    start(duration?: integer, intensity?: number, force?: boolean, callback?: CameraShakeCallback, context?: any): Phaser.Cameras.Scene2D.Camera;

                    /**
                     * The pre-render step for this effect. Called automatically by the Camera.
                     */
                    preRender(): void;

                    /**
                     * The main update loop for this effect. Called automatically by the Camera.
                     * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                     * @param delta The delta time, in ms, elapsed since the last frame.
                     */
                    update(time: integer, delta: number): void;

                    /**
                     * Called internally when the effect completes.
                     */
                    effectComplete(): void;

                    /**
                     * Resets this camera effect.
                     * If it was previously running, it stops instantly without calling its onComplete callback or emitting an event.
                     */
                    reset(): void;

                    /**
                     * Destroys this effect, releasing it from the Camera.
                     */
                    destroy(): void;

                }

            }

        }

        namespace Controls {
            /**
             * [description]
             */
            class FixedKeyControl {
                /**
                 * 
                 * @param config [description]
                 */
                constructor(config: FixedKeyControlConfig);

                /**
                 * The Camera that this Control will update.
                 */
                camera: Phaser.Cameras.Scene2D.Camera;

                /**
                 * The Key to be pressed that will move the Camera left.
                 */
                left: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera right.
                 */
                right: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera up.
                 */
                up: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera down.
                 */
                down: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera in.
                 */
                zoomIn: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera out.
                 */
                zoomOut: Phaser.Input.Keyboard.Key;

                /**
                 * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
                 */
                zoomSpeed: number;

                /**
                 * The horizontal speed the camera will move.
                 */
                speedX: number;

                /**
                 * The vertical speed the camera will move.
                 */
                speedY: number;

                /**
                 * A flag controlling if the Controls will update the Camera or not.
                 */
                active: boolean;

                /**
                 * Starts the Key Control running, providing it has been linked to a camera.
                 */
                start(): Phaser.Cameras.Controls.FixedKeyControl;

                /**
                 * Stops this Key Control from running. Call `start` to start it again.
                 */
                stop(): Phaser.Cameras.Controls.FixedKeyControl;

                /**
                 * Binds this Key Control to a camera.
                 * @param camera The camera to bind this Key Control to.
                 */
                setCamera(camera: Phaser.Cameras.Scene2D.Camera): Phaser.Cameras.Controls.FixedKeyControl;

                /**
                 * [description]
                 * @param delta [description]
                 */
                update(delta: number): void;

                /**
                 * Destroys this Key Control.
                 */
                destroy(): void;

            }

            /**
             * This alias will be removed in a future version.
             * Use `FixedKeyControl` instead.
             */
            var Fixed: any;

            /**
             * This alias will be removed in a future version.
             * Use `SmoothedKeyControl` instead.
             */
            var Smoothed: any;

            /**
             * [description]
             */
            class SmoothedKeyControl {
                /**
                 * 
                 * @param config [description]
                 */
                constructor(config: SmoothedKeyControlConfig);

                /**
                 * The Camera that this Control will update.
                 */
                camera: Phaser.Cameras.Scene2D.Camera;

                /**
                 * The Key to be pressed that will move the Camera left.
                 */
                left: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera right.
                 */
                right: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera up.
                 */
                up: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will move the Camera down.
                 */
                down: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera in.
                 */
                zoomIn: Phaser.Input.Keyboard.Key;

                /**
                 * The Key to be pressed that will zoom the Camera out.
                 */
                zoomOut: Phaser.Input.Keyboard.Key;

                /**
                 * The speed at which the camera will zoom if the `zoomIn` or `zoomOut` keys are pressed.
                 */
                zoomSpeed: number;

                /**
                 * The horizontal acceleration the camera will move.
                 */
                accelX: number;

                /**
                 * The vertical acceleration the camera will move.
                 */
                accelY: number;

                /**
                 * The horizontal drag applied to the camera when it is moving.
                 */
                dragX: number;

                /**
                 * The vertical drag applied to the camera when it is moving.
                 */
                dragY: number;

                /**
                 * The maximum horizontal speed the camera will move.
                 */
                maxSpeedX: number;

                /**
                 * The maximum vertical speed the camera will move.
                 */
                maxSpeedY: number;

                /**
                 * A flag controlling if the Controls will update the Camera or not.
                 */
                active: boolean;

                /**
                 * Starts the Key Control running, providing it has been linked to a camera.
                 */
                start(): Phaser.Cameras.Controls.SmoothedKeyControl;

                /**
                 * Stops this Key Control from running. Call `start` to start it again.
                 */
                stop(): Phaser.Cameras.Controls.SmoothedKeyControl;

                /**
                 * Binds this Key Control to a camera.
                 * @param camera The camera to bind this Key Control to.
                 */
                setCamera(camera: Phaser.Cameras.Scene2D.Camera): Phaser.Cameras.Controls.SmoothedKeyControl;

                /**
                 * [description]
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                update(delta: number): void;

                /**
                 * Destroys this Key Control.
                 */
                destroy(): void;

            }

        }

        namespace Sprite3D {
            /**
             * [description]
             */
            class Camera {
                /**
                 * 
                 * @param scene [description]
                 */
                constructor(scene: Phaser.Scene);

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                setPosition(x: number, y: number, z: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param scene [description]
                 */
                setScene(scene: Phaser.Scene): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param value [description]
                 */
                setPixelScale(value: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param sprite3D [description]
                 */
                add(sprite3D: Phaser.GameObjects.Sprite3D): Phaser.GameObjects.Sprite3D;

                /**
                 * [description]
                 * @param child [description]
                 */
                remove(child: Phaser.GameObjects.GameObject): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 */
                clear(): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 */
                getChildren(): any[];

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 * @param key [description]
                 * @param frame [description]
                 * @param visible [description] Default true.
                 */
                create(x: number, y: number, z: number, key: string, frame: string | number, visible?: boolean): Phaser.GameObjects.Sprite3D;

                /**
                 * [description]
                 * @param quantity [description]
                 * @param key [description]
                 * @param frame [description]
                 * @param visible [description] Default true.
                 */
                createMultiple(quantity: number, key: string, frame: string | number, visible?: boolean): Phaser.GameObjects.Sprite3D[];

                /**
                 * [description]
                 * @param size [description]
                 * @param spacing [description]
                 * @param key [description]
                 * @param frame [description]
                 */
                createRect(size: number | Object, spacing: number | Object, key: string, frame?: string | number): Phaser.GameObjects.Sprite3D[];

                /**
                 * [description]
                 * @param radius [description] Default 1.
                 * @param sprites [description]
                 */
                randomSphere(radius?: number, sprites?: Phaser.GameObjects.Sprite3D[]): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param scale [description] Default 1.
                 * @param sprites [description]
                 */
                randomCube(scale?: number, sprites?: Phaser.GameObjects.Sprite3D[]): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param vec3 [description]
                 * @param sprites [description]
                 */
                translateChildren(vec3: Phaser.Math.Vector3, sprites: Phaser.GameObjects.Sprite3D[]): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param mat4 [description]
                 * @param sprites [description]
                 */
                transformChildren(mat4: Phaser.Math.Matrix4, sprites: Phaser.GameObjects.Sprite3D[]): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * Sets the width and height of the viewport. Does not update any matrices.
                 * @param width [description]
                 * @param height [description]
                 */
                setViewport(width: number, height: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * Translates this camera by a specified Vector3 object
                 * or x, y, z parameters. Any undefined x y z values will
                 * default to zero, leaving that component unaffected.
                 * If you wish to set the camera position directly call setPosition instead.
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                translate(x: number | object, y?: number, z?: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                lookAt(x: number | object, y?: number, z?: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param radians [description]
                 * @param axis [description]
                 */
                rotate(radians: number, axis: Phaser.Math.Vector3): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param point [description]
                 * @param radians [description]
                 * @param axis [description]
                 */
                rotateAround(point: Phaser.Math.Vector3, radians: number, axis: Phaser.Math.Vector3): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param vec [description]
                 * @param out [description]
                 */
                project(vec: Phaser.Math.Vector3, out: Phaser.Math.Vector4): Phaser.Math.Vector4;

                /**
                 * [description]
                 * @param vec [description]
                 * @param out [description]
                 */
                unproject(vec: Phaser.Math.Vector4, out: Phaser.Math.Vector3): Phaser.Math.Vector3;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                getPickRay(x: number, y?: number): RayDef;

                /**
                 * [description]
                 */
                updateChildren(): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 */
                update(): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 */
                updateBillboardMatrix(): void;

                /**
                 * This is a utility function for canvas 3D rendering,
                 * which determines the "point size" of a camera-facing
                 * sprite billboard given its 3D world position
                 * (origin at center of sprite) and its world width
                 * and height in x/y.
                 * 
                 * We place into the output Vector2 the scaled width
                 * and height. If no `out` is specified, a new Vector2
                 * will be created for convenience (this should be avoided
                 * in tight loops).
                 * @param vec The position of the 3D Sprite.
                 * @param size The x and y dimensions.
                 * @param out The result, scaled x and y dimensions.
                 */
                getPointSize(vec: Phaser.Math.Vector2, size: Phaser.Math.Vector2, out: Phaser.Math.Vector2): Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                destroy(): void;

                /**
                 * [description]
                 * @param value [description]
                 */
                setX(value: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param value [description]
                 */
                setY(value: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 * @param value [description]
                 */
                setZ(value: number): Phaser.Cameras.Sprite3D.Camera;

                /**
                 * [description]
                 */
                x: number;

                /**
                 * [description]
                 */
                y: number;

                /**
                 * [description]
                 */
                z: number;

            }

            /**
             * [description]
             */
            var scene: Phaser.Scene;

            /**
             * [description]
             */
            var displayList: Phaser.GameObjects.DisplayList;

            /**
             * [description]
             */
            var updateList: Phaser.GameObjects.UpdateList;

            /**
             * [description]
             */
            var name: string;

            /**
             * [description]
             */
            var direction: Phaser.Math.Vector3;

            /**
             * [description]
             */
            var up: Phaser.Math.Vector3;

            /**
             * [description]
             */
            var position: Phaser.Math.Vector3;

            /**
             * [description]
             */
            var pixelScale: number;

            /**
             * [description]
             */
            var projection: Phaser.Math.Matrix4;

            /**
             * [description]
             */
            var view: Phaser.Math.Matrix4;

            /**
             * [description]
             */
            var combined: Phaser.Math.Matrix4;

            /**
             * [description]
             */
            var invProjectionView: Phaser.Math.Matrix4;

            /**
             * [description]
             */
            var near: number;

            /**
             * [description]
             */
            var far: number;

            /**
             * [description]
             */
            var ray: RayDef;

            /**
             * [description]
             */
            var viewportWidth: number;

            /**
             * [description]
             */
            var viewportHeight: number;

            /**
             * [description]
             */
            var billboardMatrixDirty: boolean;

            /**
             * [description]
             */
            var children: Phaser.Structs.Set<Phaser.GameObjects.GameObject>;

            /**
             * [description]
             */
            class CameraManager {
                /**
                 * 
                 * @param scene [description]
                 */
                constructor(scene: Phaser.Scene);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                systems: Phaser.Scenes.Systems;

                /**
                 * An Array of the Camera objects being managed by this Camera Manager.
                 */
                cameras: Phaser.Cameras.Sprite3D.Camera[];

                /**
                 * [description]
                 * @param fieldOfView [description] Default 80.
                 * @param width [description]
                 * @param height [description]
                 */
                add(fieldOfView?: number, width?: number, height?: number): Phaser.Cameras.Sprite3D.PerspectiveCamera;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 */
                addOrthographicCamera(width: number, height: number): Phaser.Cameras.Sprite3D.OrthographicCamera;

                /**
                 * [description]
                 * @param fieldOfView [description] Default 80.
                 * @param width [description]
                 * @param height [description]
                 */
                addPerspectiveCamera(fieldOfView?: number, width?: number, height?: number): Phaser.Cameras.Sprite3D.PerspectiveCamera;

                /**
                 * [description]
                 * @param name [description]
                 */
                getCamera(name: string): Phaser.Cameras.Sprite3D.OrthographicCamera | Phaser.Cameras.Sprite3D.PerspectiveCamera;

                /**
                 * [description]
                 * @param camera [description]
                 */
                removeCamera(camera: Phaser.Cameras.Sprite3D.OrthographicCamera | Phaser.Cameras.Sprite3D.PerspectiveCamera): void;

                /**
                 * [description]
                 */
                removeAll(): Phaser.Cameras.Sprite3D.OrthographicCamera | Phaser.Cameras.Sprite3D.PerspectiveCamera;

                /**
                 * [description]
                 * @param timestep [description]
                 * @param delta [description]
                 */
                update(timestep: number, delta: number): void;

            }

            /**
             * [description]
             */
            class OrthographicCamera extends Phaser.Cameras.Sprite3D.Camera {
                /**
                 * 
                 * @param scene [description]
                 * @param viewportWidth [description] Default 0.
                 * @param viewportHeight [description] Default 0.
                 */
                constructor(scene: Phaser.Scene, viewportWidth?: integer, viewportHeight?: integer);

                /**
                 * [description]
                 */
                viewportWidth: integer;

                /**
                 * [description]
                 */
                viewportHeight: integer;

                /**
                 * [description]
                 */
                near: number;

                /**
                 * [description]
                 * @param yDown [description]
                 * @param viewportWidth [description]
                 * @param viewportHeight [description]
                 */
                setToOrtho(yDown: number, viewportWidth?: number, viewportHeight?: number): Phaser.Cameras.Sprite3D.OrthographicCamera;

                /**
                 * [description]
                 */
                update(): Phaser.Cameras.Sprite3D.OrthographicCamera;

                /**
                 * [description]
                 */
                zoom: number;

            }

            /**
             * [description]
             */
            class PerspectiveCamera extends Phaser.Cameras.Sprite3D.Camera {
                /**
                 * 
                 * @param scene [description]
                 * @param fieldOfView [description] Default 80.
                 * @param viewportWidth [description] Default 0.
                 * @param viewportHeight [description] Default 0.
                 */
                constructor(scene: Phaser.Scene, fieldOfView?: integer, viewportWidth?: integer, viewportHeight?: integer);

                /**
                 * [description]
                 */
                viewportWidth: integer;

                /**
                 * [description]
                 */
                viewportHeight: integer;

                /**
                 * [description]
                 */
                fieldOfView: integer;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFOV(value: number): Phaser.Cameras.Sprite3D.PerspectiveCamera;

                /**
                 * [description]
                 */
                update(): Phaser.Cameras.Sprite3D.PerspectiveCamera;

            }

        }

    }

    /**
     * Phaser Release Version
     */
    var VERSION: string;

    /**
     * AUTO Detect Renderer.
     */
    var AUTO: integer;

    /**
     * Canvas Renderer.
     */
    var CANVAS: integer;

    /**
     * WebGL Renderer.
     */
    var WEBGL: integer;

    /**
     * Headless Renderer.
     */
    var HEADLESS: integer;

    /**
     * In Phaser the value -1 means 'forever' in lots of cases, this const allows you to use it instead
     * to help you remember what the value is doing in your code.
     */
    var FOREVER: integer;

    /**
     * Direction constant.
     */
    var NONE: integer;

    /**
     * Direction constant.
     */
    var UP: integer;

    /**
     * Direction constant.
     */
    var DOWN: integer;

    /**
     * Direction constant.
     */
    var LEFT: integer;

    /**
     * Direction constant.
     */
    var RIGHT: integer;

    namespace Create {
        /**
         * [description]
         * @param config [description]
         */
        function GenerateTexture(config: GenerateTextureConfig): HTMLCanvasElement;

        namespace Palettes {
            /**
             * A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)
             */
            var ARNE16: Palette;

            /**
             * A 16 color palette inspired by the Commodore 64.
             */
            var C64: Palette;

            /**
             * A 16 color CGA inspired palette by [Arne](http://androidarts.com/palette/16pal.htm)
             */
            var CGA: Palette;

            /**
             * A 16 color JMP palette by [Arne](http://androidarts.com/palette/16pal.htm)
             */
            var JMP: Palette;

            /**
             * A 16 color palette inspired by Japanese computers like the MSX.
             */
            var MSX: Palette;

        }

    }

    namespace Curves {
        /**
         * [description]
         */
        class CubicBezierCurve extends Phaser.Curves.Curve {
            /**
             * 
             * @param p0 Start point, or an array of point pairs.
             * @param p1 Control Point 1.
             * @param p2 Control Point 2.
             * @param p3 End Point.
             */
            constructor(p0: Phaser.Math.Vector2 | Phaser.Math.Vector2[], p1: Phaser.Math.Vector2, p2: Phaser.Math.Vector2, p3: Phaser.Math.Vector2);

            /**
             * [description]
             */
            p0: Phaser.Math.Vector2;

            /**
             * [description]
             */
            p1: Phaser.Math.Vector2;

            /**
             * [description]
             */
            p2: Phaser.Math.Vector2;

            /**
             * [description]
             */
            p3: Phaser.Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions The amount of divisions used by this curve.
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param graphics [description]
             * @param pointsTotal [description] Default 32.
             */
            draw<G extends Phaser.GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * [description]
             */
            toJSON(): JSONCurve;

            /**
             * [description]
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): Phaser.Curves.CubicBezierCurve;

        }

        /**
         * A Base Curve class, which all other curve types extend.
         * 
         * 
         * 
         * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)
         */
        class Curve {
            /**
             * 
             * @param type [description]
             */
            constructor(type: string);

            /**
             * String based identifier for the type of curve.
             */
            type: string;

            /**
             * The default number of divisions within the curve.
             */
            defaultDivisions: integer;

            /**
             * The quantity of arc length divisions within the curve.
             */
            arcLengthDivisions: integer;

            /**
             * An array of cached arc length values.
             */
            cacheArcLengths: number[];

            /**
             * Does the data of this curve need updating?
             */
            needsUpdate: boolean;

            /**
             * [description]
             */
            active: boolean;

            /**
             * Draws this curve on the given Graphics object.
             * 
             * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.
             * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
             * @param graphics The Graphics instance onto which this curve will be drawn.
             * @param pointsTotal The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance. Default 32.
             */
            draw<G extends Phaser.GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * Returns a Rectangle where the position and dimensions match the bounds of this Curve.
             * 
             * You can control the accuracy of the bounds. The value given is used to work out how many points
             * to plot across the curve. Higher values are more accurate at the cost of calculation speed.
             * @param out The Rectangle to store the bounds in. If falsey a new object will be created.
             * @param accuracy The accuracy of the bounds calculations. Default 16.
             */
            getBounds(out?: Phaser.Geom.Rectangle, accuracy?: integer): Phaser.Geom.Rectangle;

            /**
             * Returns an array of points, spaced out X distance pixels apart.
             * The smaller the distance, the larger the array will be.
             * @param distance The distance, in pixels, between each point along the curve.
             */
            getDistancePoints(distance: integer): Phaser.Geom.Point[];

            /**
             * [description]
             * @param out [description]
             */
            getEndPoint(out: Phaser.Math.Vector2): Phaser.Math.Vector2;

            /**
             * [description]
             */
            getLength(): number;

            /**
             * [description]
             * @param divisions [description]
             */
            getLengths(divisions?: integer): number[];

            /**
             * [description]
             * @param u [description]
             * @param out [description]
             */
            getPointAt<O extends Phaser.Math.Vector2>(u: number, out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getPoints(divisions?: integer): Phaser.Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getRandomPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getSpacedPoints(divisions?: integer): Phaser.Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param t [description]
             * @param out [description]
             */
            getTangent<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param u [description]
             * @param out [description]
             */
            getTangentAt<O extends Phaser.Math.Vector2>(u: number, out?: O): O;

            /**
             * [description]
             * @param distance [description]
             * @param divisions [description]
             */
            getTFromDistance(distance: integer, divisions?: integer): number;

            /**
             * [description]
             * @param u [description]
             * @param distance [description]
             * @param divisions [description]
             */
            getUtoTmapping(u: number, distance: integer, divisions?: integer): number;

            /**
             * [description]
             */
            updateArcLengths(): void;

        }

        /**
         * [description]
         */
        class EllipseCurve extends Phaser.Curves.Curve {
            /**
             * 
             * @param x [description] Default 0.
             * @param y [description] Default 0.
             * @param xRadius [description] Default 0.
             * @param yRadius [description] Default 0.
             * @param startAngle [description] Default 0.
             * @param endAngle [description] Default 360.
             * @param clockwise [description] Default false.
             * @param rotation [description] Default 0.
             */
            constructor(x?: number | EllipseCurveConfig, y?: number, xRadius?: number, yRadius?: number, startAngle?: integer, endAngle?: integer, clockwise?: boolean, rotation?: integer);

            /**
             * [description]
             */
            p0: Phaser.Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * Sets the horizontal radius of this curve.
             * @param value The horizontal radius of this curve.
             */
            setXRadius(value: number): Phaser.Curves.EllipseCurve;

            /**
             * Sets the vertical radius of this curve.
             * @param value The vertical radius of this curve.
             */
            setYRadius(value: number): Phaser.Curves.EllipseCurve;

            /**
             * Sets the width of this curve.
             * @param value The width of this curve.
             */
            setWidth(value: number): Phaser.Curves.EllipseCurve;

            /**
             * Sets the height of this curve.
             * @param value The height of this curve.
             */
            setHeight(value: number): Phaser.Curves.EllipseCurve;

            /**
             * Sets the start angle of this curve.
             * @param value The start angle of this curve, in radians.
             */
            setStartAngle(value: number): Phaser.Curves.EllipseCurve;

            /**
             * Sets the end angle of this curve.
             * @param value The end angle of this curve, in radians.
             */
            setEndAngle(value: number): Phaser.Curves.EllipseCurve;

            /**
             * Sets if this curve extends clockwise or anti-clockwise.
             * @param value The clockwise state of this curve.
             */
            setClockwise(value: boolean): Phaser.Curves.EllipseCurve;

            /**
             * Sets the rotation of this curve.
             * @param value The rotation of this curve, in radians.
             */
            setRotation(value: number): Phaser.Curves.EllipseCurve;

            /**
             * [description]
             */
            x: number;

            /**
             * [description]
             */
            y: number;

            /**
             * [description]
             */
            xRadius: number;

            /**
             * [description]
             */
            yRadius: number;

            /**
             * [description]
             */
            startAngle: number;

            /**
             * [description]
             */
            endAngle: number;

            /**
             * [description]
             */
            clockwise: boolean;

            /**
             * [description]
             */
            rotation: number;

            /**
             * [description]
             */
            toJSON(): JSONEllipseCurve;

            /**
             * [description]
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONEllipseCurve): Phaser.Curves.EllipseCurve;

        }

        /**
         * [description]
         */
        class LineCurve extends Phaser.Curves.Curve {
            /**
             * 
             * @param p0 [description]
             * @param p1 [description]
             */
            constructor(p0: Phaser.Math.Vector2 | number[], p1?: Phaser.Math.Vector2);

            /**
             * [description]
             */
            p0: Phaser.Math.Vector2;

            /**
             * [description]
             */
            p1: Phaser.Math.Vector2;

            /**
             * Returns a Rectangle where the position and dimensions match the bounds of this Curve.
             * @param out A Rectangle object to store the bounds in. If not given a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Geom.Rectangle>(out?: O): O;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description] Default 1.
             */
            getResolution(divisions?: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param u The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPointAt<O extends Phaser.Math.Vector2>(u: number, out?: O): O;

            /**
             * [description]
             */
            getTangent<O extends Phaser.Math.Vector2>(): O;

            /**
             * Draws this curve on the given Graphics object.
             * 
             * The curve is drawn using `Graphics.lineBetween` so will be drawn at whatever the present Graphics line color is.
             * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.
             * @param graphics The Graphics instance onto which this curve will be drawn.
             */
            draw<G extends Phaser.GameObjects.Graphics>(graphics: G): G;

            /**
             * [description]
             */
            toJSON(): JSONCurve;

            /**
             * [description]
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): Phaser.Curves.LineCurve;

        }

        /**
         * [description]
         */
        class MoveTo {
            /**
             * 
             * @param x [description]
             * @param y [description]
             */
            constructor(x?: number, y?: number);

            /**
             * [description]
             */
            active: boolean;

            /**
             * [description]
             */
            p0: Phaser.Math.Vector2;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param u [description]
             * @param out [description]
             */
            getPointAt<O extends Phaser.Math.Vector2>(u: number, out?: O): O;

            /**
             * Gets the resolution of this curve.
             */
            getResolution(): number;

            /**
             * Gets the length of this curve.
             */
            getLength(): number;

            /**
             * [description]
             */
            toJSON(): JSONCurve;

        }

        /**
         * [description]
         */
        class Path {
            /**
             * 
             * @param x [description] Default 0.
             * @param y [description] Default 0.
             */
            constructor(x?: number, y?: number);

            /**
             * [description]
             */
            name: string;

            /**
             * [description]
             */
            curves: Phaser.Curves.Curve[];

            /**
             * [description]
             */
            cacheLengths: number[];

            /**
             * Automatically closes the path.
             */
            autoClose: boolean;

            /**
             * [description]
             */
            startPoint: Phaser.Math.Vector2;

            /**
             * [description]
             * @param curve [description]
             */
            add(curve: Phaser.Curves.Curve): Phaser.Curves.Path;

            /**
             * [description]
             * @param radius [description]
             * @param clockwise [description] Default false.
             * @param rotation [description] Default 0.
             */
            circleTo(radius: number, clockwise?: boolean, rotation?: number): Phaser.Curves.Path;

            /**
             * [description]
             */
            closePath(): Phaser.Curves.Path;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param control1X [description]
             * @param control1Y [description]
             * @param control2X [description]
             * @param control2Y [description]
             */
            cubicBezierTo(x: number, y: number, control1X: Phaser.Math.Vector2, control1Y: Phaser.Math.Vector2, control2X: Phaser.Math.Vector2, control2Y: Phaser.Math.Vector2): Phaser.Curves.Path;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param controlX [description]
             * @param controlY [description]
             */
            quadraticBezierTo(x: number | Phaser.Math.Vector2[], y?: number, controlX?: number, controlY?: number): Phaser.Curves.Path;

            /**
             * [description]
             * @param graphics [description]
             * @param pointsTotal [description] Default 32.
             */
            draw<G extends Phaser.GameObjects.Graphics>(graphics: Phaser.GameObjects.Graphics, pointsTotal?: integer): G;

            /**
             * Creates an ellipse curve positioned at the previous end point, using the given parameters.
             * @param xRadius [description]
             * @param yRadius [description]
             * @param startAngle [description]
             * @param endAngle [description]
             * @param clockwise [description]
             * @param rotation [description]
             */
            ellipseTo(xRadius: number, yRadius: number, startAngle: number, endAngle: number, clockwise: boolean, rotation: number): Phaser.Curves.Path;

            /**
             * [description]
             * @param data [description]
             */
            fromJSON(data: object): Phaser.Curves.Path;

            /**
             * [description]
             * @param out [description]
             * @param accuracy [description] Default 16.
             */
            getBounds<O extends Phaser.Math.Vector2>(out?: O, accuracy?: integer): O;

            /**
             * [description]
             */
            getCurveLengths(): number[];

            /**
             * [description]
             * @param out [description]
             */
            getEndPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             */
            getLength(): number;

            /**
             * [description]
             * @param t [description]
             * @param out [description]
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param divisions [description] Default 12.
             */
            getPoints(divisions?: integer): Phaser.Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getRandomPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description] Default 40.
             */
            getSpacedPoints(divisions?: integer): Phaser.Math.Vector2[];

            /**
             * [description]
             * @param out [description]
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            lineTo(x: number | Phaser.Math.Vector2, y?: number): Phaser.Curves.Path;

            /**
             * [description]
             * @param points [description]
             */
            splineTo(points: Phaser.Math.Vector2[]): Phaser.Curves.Path;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            moveTo(x: number, y: number): Phaser.Curves.Path;

            /**
             * [description]
             */
            toJSON(): JSONPath;

            /**
             * [description]
             */
            updateArcLengths(): void;

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * [description]
         */
        class QuadraticBezier extends Phaser.Curves.Curve {
            /**
             * 
             * @param p0 Start point, or an array of point pairs.
             * @param p1 Control Point 1.
             * @param p2 Control Point 2.
             */
            constructor(p0: Phaser.Math.Vector2 | number[], p1: Phaser.Math.Vector2, p2: Phaser.Math.Vector2);

            /**
             * [description]
             */
            p0: Phaser.Math.Vector2;

            /**
             * [description]
             */
            p1: Phaser.Math.Vector2;

            /**
             * [description]
             */
            p2: Phaser.Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             * @param graphics [description]
             * @param pointsTotal [description] Default 32.
             */
            draw<G extends Phaser.GameObjects.Graphics>(graphics: G, pointsTotal?: integer): G;

            /**
             * [description]
             */
            toJSON(): JSONCurve;

            /**
             * [description]
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): Phaser.Curves.QuadraticBezier;

        }

        /**
         * [description]
         */
        class SplineCurve extends Phaser.Curves.Curve {
            /**
             * 
             * @param points [description]
             */
            constructor(points?: Phaser.Math.Vector2[]);

            /**
             * [description]
             */
            points: Phaser.Math.Vector2[];

            /**
             * [description]
             * @param points [description]
             */
            addPoints(points: Phaser.Math.Vector2[] | number[] | number[][]): Phaser.Curves.SplineCurve;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            addPoint(x: number, y: number): Phaser.Math.Vector2;

            /**
             * Gets the starting point on the curve.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getStartPoint<O extends Phaser.Math.Vector2>(out?: O): O;

            /**
             * [description]
             * @param divisions [description]
             */
            getResolution(divisions: number): number;

            /**
             * Get point at relative position in curve according to length.
             * @param t The position along the curve to return. Where 0 is the start and 1 is the end.
             * @param out A Vector2 object to store the result in. If not given will be created.
             */
            getPoint<O extends Phaser.Math.Vector2>(t: number, out?: O): O;

            /**
             * [description]
             */
            toJSON(): JSONCurve;

            /**
             * [description]
             * @param data The JSON object containing this curve data.
             */
            static fromJSON(data: JSONCurve): Phaser.Curves.SplineCurve;

        }

    }

    namespace Data {
        /**
         * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.
         * 
         * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,
         * 
         * or have a property called `events` that is an instance of it.
         */
        class DataManager {
            /**
             * 
             * @param parent The object that this DataManager belongs to.
             * @param eventEmitter The DataManager's event emitter.
             */
            constructor(parent: object, eventEmitter: Phaser.Events.EventEmitter);

            /**
             * The object that this DataManager belongs to.
             */
            parent: any;

            /**
             * The DataManager's event emitter.
             */
            events: Phaser.Events.EventEmitter;

            /**
             * The data list.
             */
            list: {[key: string]:  any};

            /**
             * Whether setting data is blocked for this DataManager.
             * 
             * Used temporarily to allow 'changedata' event listeners to prevent
             * specific data from being set.
             */
            blockSet: boolean;

            /**
             * Retrieves the value for the given key, or undefined if it doesn't exist.
             * @param key The key of the value to retrieve.
             */
            get(key: string): any;

            /**
             * Retrieves all data values.
             */
            getAll(): {[key: string]:  any};

            /**
             * Queries the DataManager for the values of keys matching the given search string.
             * @param search The search string.
             */
            query(search: string): {[key: string]:  any};

            /**
             * Sets the value for the given key.
             * 
             * Emits the 'changedata' and 'setdata' events.
             * @param key The key to set the value for.
             * @param data The value to set.
             */
            set(key: string, data: any): Phaser.Data.DataManager;

            /**
             * Passes all data entries to the given callback. Stores the result of the callback.
             * @param callback The function to call.
             * @param scope Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the game object, key, and data.
             */
            each(callback: DataEachCallback, scope?: any, ...args: any[]): Phaser.Data.DataManager;

            /**
             * Merge the given data object into this DataManager's data object.
             * @param data The data to merge.
             * @param overwrite Whether to overwrite existing data. Defaults to true.
             */
            merge(data: {[key: string]:  any}, overwrite: boolean): Phaser.Data.DataManager;

            /**
             * Remove the value for the given key.
             * @param key The key to remove
             */
            remove(key: string): Phaser.Data.DataManager;

            /**
             * Retrieves the data associated with the given 'key', deletes it from this Data store, then returns it.
             * @param key The key of the value to retrieve and delete.
             */
            pop(key: string): any;

            /**
             * Determines whether the given key is set in this Data store.
             * @param key The key to check.
             */
            has(key: string): boolean;

            /**
             * Freeze or unfreeze this Data store, to allow or prevent setting its values.
             * @param value Whether to freeze the Data store.
             */
            setFreeze(value: boolean): Phaser.Data.DataManager;

            /**
             * Delete all data in this Data store and unfreeze it.
             */
            reset(): Phaser.Data.DataManager;

            /**
             * Destroy this data manager.
             */
            destroy(): void;

            /**
             * Freeze this Data component, so no values can be set.
             */
            freeze: boolean;

            /**
             * Return the total number of entries in this Data component.
             */
            count: integer;

        }

        /**
         * The Data Component features a means to store pieces of data specific to a Game Object, System or Plugin.
         * 
         * You can then search, query it, and retrieve the data. The parent must either extend EventEmitter,
         * 
         * or have a property called `events` that is an instance of it.
         */
        class DataManagerPlugin extends Phaser.Data.DataManager {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * The Scene that owns this plugin is being destroyed.
             * We need to shutdown and then kill off all external references.
             */
            destroy(): void;

        }

    }

    namespace Device {
        /**
         * Determines the audio playback capabilities of the device running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.audio` from within any Scene.
         */
        type Audio = {
            /**
             * Can this device play HTML Audio tags?
             */
            audioData: boolean;
            /**
             * Can this device play EC-3 Dolby Digital Plus files?
             */
            dolby: boolean;
            /**
             * Can this device can play m4a files.
             */
            m4a: boolean;
            /**
             * Can this device play mp3 files?
             */
            mp3: boolean;
            /**
             * Can this device play ogg files?
             */
            ogg: boolean;
            /**
             * Can this device play opus files?
             */
            opus: boolean;
            /**
             * Can this device play wav files?
             */
            wav: boolean;
            /**
             * Does this device have the Web Audio API?
             */
            webAudio: boolean;
            /**
             * Can this device play webm files?
             */
            webm: boolean;
        };

        /**
         * Determines the browser type and version running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.browser` from within any Scene.
         */
        type Browser = {
            /**
             * Set to true if running in Chrome.
             */
            chrome: boolean;
            /**
             * Set to true if running in Microsoft Edge browser.
             */
            edge: boolean;
            /**
             * Set to true if running in Firefox.
             */
            firefox: boolean;
            /**
             * Set to true if running in Internet Explorer 11 or less (not Edge).
             */
            ie: boolean;
            /**
             * Set to true if running in Mobile Safari.
             */
            mobileSafari: boolean;
            /**
             * Set to true if running in Opera.
             */
            opera: boolean;
            /**
             * Set to true if running in Safari.
             */
            safari: boolean;
            /**
             * Set to true if running in the Silk browser (as used on the Amazon Kindle)
             */
            silk: boolean;
            /**
             * Set to true if running a Trident version of Internet Explorer (IE11+)
             */
            trident: boolean;
            /**
             * If running in Chrome this will contain the major version number.
             */
            chromeVersion: number;
            /**
             * If running in Firefox this will contain the major version number.
             */
            firefoxVersion: number;
            /**
             * If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Browser.trident and Browser.tridentVersion.
             */
            ieVersion: number;
            /**
             * If running in Safari this will contain the major version number.
             */
            safariVersion: number;
            /**
             * If running in Internet Explorer 11 this will contain the major version number. See {@link http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx}
             */
            tridentVersion: number;
        };

        /**
         * Determines the canvas features of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.canvasFeatures` from within any Scene.
         */
        type CanvasFeatures = {
            /**
             * Set to true if the browser supports inversed alpha.
             */
            supportInverseAlpha: boolean;
            /**
             * Set to true if the browser supports new canvas blend modes.
             */
            supportNewBlendModes: boolean;
        };

        /**
         * Determines the features of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.features` from within any Scene.
         */
        type Features = {
            /**
             * True if canvas supports a 'copy' bitblt onto itself when the source and destination regions overlap.
             */
            canvasBitBltShift: boolean;
            /**
             * Is canvas available?
             */
            canvas: boolean;
            /**
             * Is file available?
             */
            file: boolean;
            /**
             * Is fileSystem available?
             */
            fileSystem: boolean;
            /**
             * Does the device support the getUserMedia API?
             */
            getUserMedia: boolean;
            /**
             * Is the device big or little endian? (only detected if the browser supports TypedArrays)
             */
            littleEndian: boolean;
            /**
             * Is localStorage available?
             */
            localStorage: boolean;
            /**
             * Is Pointer Lock available?
             */
            pointerLock: boolean;
            /**
             * Does the device context support 32bit pixel manipulation using array buffer views?
             */
            support32bit: boolean;
            /**
             * Does the device support the Vibration API?
             */
            vibration: boolean;
            /**
             * Is webGL available?
             */
            webGL: boolean;
            /**
             * Is worker available?
             */
            worker: boolean;
        };

        /**
         * Determines the full screen support of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.fullscreen` from within any Scene.
         */
        type Fullscreen = {
            /**
             * Does the browser support the Full Screen API?
             */
            available: boolean;
            /**
             * Does the browser support access to the Keyboard during Full Screen mode?
             */
            keyboard: boolean;
            /**
             * If the browser supports the Full Screen API this holds the call you need to use to cancel it.
             */
            cancel: string;
            /**
             * If the browser supports the Full Screen API this holds the call you need to use to activate it.
             */
            request: string;
        };

        /**
         * Determines the input support of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.input` from within any Scene.
         */
        type Input = {
            /**
             * The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
             */
            wheelType: string;
            /**
             * Is navigator.getGamepads available?
             */
            gamepads: boolean;
            /**
             * Is mspointer available?
             */
            mspointer: boolean;
            /**
             * Is touch available?
             */
            touch: boolean;
        };

        /**
         * Determines the operating system of the device running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.os` from within any Scene.
         */
        type OS = {
            /**
             * Is running on android?
             */
            android: boolean;
            /**
             * Is running on chromeOS?
             */
            chromeOS: boolean;
            /**
             * Is the game running under CocoonJS?
             */
            cocoonJS: boolean;
            /**
             * Is this game running with CocoonJS.App?
             */
            cocoonJSApp: boolean;
            /**
             * Is the game running under Apache Cordova?
             */
            cordova: boolean;
            /**
             * Is the game running under the Intel Crosswalk XDK?
             */
            crosswalk: boolean;
            /**
             * Is running on a desktop?
             */
            desktop: boolean;
            /**
             * Is the game running under Ejecta?
             */
            ejecta: boolean;
            /**
             * Is the game running under GitHub Electron?
             */
            electron: boolean;
            /**
             * Is running on iOS?
             */
            iOS: boolean;
            /**
             * Is running on iPad?
             */
            iPad: boolean;
            /**
             * Is running on iPhone?
             */
            iPhone: boolean;
            /**
             * Is running on an Amazon Kindle?
             */
            kindle: boolean;
            /**
             * Is running on linux?
             */
            linux: boolean;
            /**
             * Is running on macOS?
             */
            macOS: boolean;
            /**
             * Is the game running under Node.js?
             */
            node: boolean;
            /**
             * Is the game running under Node-Webkit?
             */
            nodeWebkit: boolean;
            /**
             * Set to true if running as a WebApp, i.e. within a WebView
             */
            webApp: boolean;
            /**
             * Is running on windows?
             */
            windows: boolean;
            /**
             * Is running on a Windows Phone?
             */
            windowsPhone: boolean;
            /**
             * If running in iOS this will contain the major version number.
             */
            iOSVersion: number;
            /**
             * PixelRatio of the host device?
             */
            pixelRatio: number;
        };

        /**
         * Determines the video support of the browser running this Phaser Game instance.
         * These values are read-only and populated during the boot sequence of the game.
         * They are then referenced by internal game systems and are available for you to access
         * via `this.sys.game.device.video` from within any Scene.
         */
        type Video = {
            /**
             * Can this device play h264 mp4 video files?
             */
            h264Video: boolean;
            /**
             * Can this device play hls video files?
             */
            hlsVideo: boolean;
            /**
             * Can this device play h264 mp4 video files?
             */
            mp4Video: boolean;
            /**
             * Can this device play ogg video files?
             */
            oggVideo: boolean;
            /**
             * Can this device play vp9 video files?
             */
            vp9Video: boolean;
            /**
             * Can this device play webm video files?
             */
            webmVideo: boolean;
        };

    }

    type DeviceConf = {
        /**
         * The OS Device functions.
         */
        os: Phaser.Device.OS;
        /**
         * The Browser Device functions.
         */
        browser: Phaser.Device.Browser;
        /**
         * The Features Device functions.
         */
        features: Phaser.Device.Features;
        /**
         * The Input Device functions.
         */
        input: Phaser.Device.Input;
        /**
         * The Audio Device functions.
         */
        audio: Phaser.Device.Audio;
        /**
         * The Video Device functions.
         */
        video: Phaser.Device.Video;
        /**
         * The Fullscreen Device functions.
         */
        fullscreen: Phaser.Device.Fullscreen;
        /**
         * The Canvas Device functions.
         */
        canvasFeatures: Phaser.Device.CanvasFeatures;
    };

    namespace Display {
        namespace Align {
            /**
             * A constant representing a top-left alignment or position.
             */
            const TOP_LEFT: integer;

            /**
             * A constant representing a top-center alignment or position.
             */
            const TOP_CENTER: integer;

            /**
             * A constant representing a top-right alignment or position.
             */
            const TOP_RIGHT: integer;

            /**
             * A constant representing a left-top alignment or position.
             */
            const LEFT_TOP: integer;

            /**
             * A constant representing a left-center alignment or position.
             */
            const LEFT_CENTER: integer;

            /**
             * A constant representing a left-bottom alignment or position.
             */
            const LEFT_BOTTOM: integer;

            /**
             * A constant representing a center alignment or position.
             */
            const CENTER: integer;

            /**
             * A constant representing a right-top alignment or position.
             */
            const RIGHT_TOP: integer;

            /**
             * A constant representing a right-center alignment or position.
             */
            const RIGHT_CENTER: integer;

            /**
             * A constant representing a right-bottom alignment or position.
             */
            const RIGHT_BOTTOM: integer;

            /**
             * A constant representing a bottom-left alignment or position.
             */
            const BOTTOM_LEFT: integer;

            /**
             * A constant representing a bottom-center alignment or position.
             */
            const BOTTOM_CENTER: integer;

            /**
             * A constant representing a bottom-right alignment or position.
             */
            const BOTTOM_RIGHT: integer;

            namespace In {
                /**
                 * Takes given Game Object and aligns it so that it is positioned in the bottom center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the bottom left of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomLeft<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the bottom right of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomRight<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function Center<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the left center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned relative to the other.
                 * The alignment used is based on the `position` argument, which is an `ALIGN_CONST` value, such as `LEFT_CENTER` or `TOP_RIGHT`.
                 * @param child The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param position The position to align the Game Object with. This is an align constant, such as `ALIGN_CONST.LEFT_CENTER`.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function QuickSet<G extends Phaser.GameObjects.GameObject>(child: G, alignIn: Phaser.GameObjects.GameObject, position: integer, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the right center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the top center of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the top left of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopLeft<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned in the top right of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignIn The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopRight<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignIn: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

            }

            namespace To {
                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the bottom center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the bottom left position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomLeft<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the bottom right position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function BottomRight<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the left bottom position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftBottom<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the left center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the left top position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function LeftTop<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the right bottom position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightBottom<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the right center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the right top position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function RightTop<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the top center position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopCenter<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the top left position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopLeft<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

                /**
                 * Takes given Game Object and aligns it so that it is positioned next to the top right position of the other.
                 * @param gameObject The Game Object that will be positioned.
                 * @param alignTo The Game Object to base the alignment position on.
                 * @param offsetX Optional horizontal offset from the position. Default 0.
                 * @param offsetY Optional vertical offset from the position. Default 0.
                 */
                function TopRight<G extends Phaser.GameObjects.GameObject>(gameObject: G, alignTo: Phaser.GameObjects.GameObject, offsetX?: number, offsetY?: number): G;

            }

        }

        namespace Bounds {
            /**
             * Positions the Game Object so that it is centered on the given coordinates.
             * @param gameObject The Game Object that will be re-positioned.
             * @param x The horizontal coordinate to position the Game Object on.
             * @param y The vertical coordinate to position the Game Object on.
             */
            function CenterOn<G extends Phaser.GameObjects.GameObject>(gameObject: G, x: number, y: number): G;

            /**
             * Returns the bottom coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetBottom(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the center x coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetCenterX(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the center y coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetCenterY(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the left coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetLeft(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the amount the Game Object is visually offset from its x coordinate.
             * This is the same as `width * origin.x`.
             * This value will only be > 0 if `origin.x` is not equal to zero.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetOffsetX(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the amount the Game Object is visually offset from its y coordinate.
             * This is the same as `width * origin.y`.
             * This value will only be > 0 if `origin.y` is not equal to zero.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetOffsetY(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the right coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetRight(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Returns the top coordinate from the bounds of the Game Object.
             * @param gameObject The Game Object to get the bounds value from.
             */
            function GetTop(gameObject: Phaser.GameObjects.GameObject): number;

            /**
             * Positions the Game Object so that the bottom of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetBottom<G extends Phaser.GameObjects.GameObject>(gameObject: G, value: number): G;

            /**
             * Positions the Game Object so that the center top of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param x The coordinate to position the Game Object bounds on.
             */
            function SetCenterX<G extends Phaser.GameObjects.GameObject>(gameObject: G, x: number): G;

            /**
             * Positions the Game Object so that the center top of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param y The coordinate to position the Game Object bounds on.
             */
            function SetCenterY<G extends Phaser.GameObjects.GameObject>(gameObject: G, y: number): G;

            /**
             * Positions the Game Object so that the left of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetLeft<G extends Phaser.GameObjects.GameObject>(gameObject: G, value: number): G;

            /**
             * Positions the Game Object so that the left of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetRight<G extends Phaser.GameObjects.GameObject>(gameObject: G, value: number): G;

            /**
             * Positions the Game Object so that the top of its bounds aligns with the given coordinate.
             * @param gameObject The Game Object that will be re-positioned.
             * @param value The coordinate to position the Game Object bounds on.
             */
            function SetTop<G extends Phaser.GameObjects.GameObject>(gameObject: G, value: number): G;

        }

        namespace Canvas {
            namespace CanvasInterpolation {
                /**
                 * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
                 * @param canvas The canvas object to have the style set on.
                 */
                function setCrisp(canvas: HTMLCanvasElement): HTMLCanvasElement;

                /**
                 * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
                 * @param canvas The canvas object to have the style set on.
                 */
                function setBicubic(canvas: HTMLCanvasElement): HTMLCanvasElement;

            }

            /**
             * The CanvasPool is a global static object, that allows Phaser to recycle and pool 2D Context Canvas DOM elements.
             * It does not pool WebGL Contexts, because once the context options are set they cannot be modified again, 
             * which is useless for some of the Phaser pipelines / renderer.
             * 
             * This singleton is instantiated as soon as Phaser loads, before a Phaser.Game instance has even been created.
             * Which means all instances of Phaser Games on the same page can share the one single pool.
             */
            namespace CanvasPool {
                /**
                 * Creates a new Canvas DOM element, or pulls one from the pool if free.
                 * @param parent The parent of the Canvas object.
                 * @param width The width of the Canvas. Default 1.
                 * @param height The height of the Canvas. Default 1.
                 * @param canvasType The type of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`. Default Phaser.CANVAS.
                 */
                function create(parent: any, width?: integer, height?: integer, canvasType?: integer): HTMLCanvasElement;

                /**
                 * Creates a new Canvas DOM element, or pulls one from the pool if free.
                 * @param parent The parent of the Canvas object.
                 * @param width The width of the Canvas. Default 1.
                 * @param height The height of the Canvas. Default 1.
                 */
                function create2D(parent: any, width?: integer, height?: integer): HTMLCanvasElement;

                /**
                 * Creates a new Canvas DOM element, or pulls one from the pool if free.
                 * @param parent The parent of the Canvas object.
                 * @param width The width of the Canvas. Default 1.
                 * @param height The height of the Canvas. Default 1.
                 */
                function createWebGL(parent: any, width?: integer, height?: integer): HTMLCanvasElement;

                /**
                 * Gets the first free canvas index from the pool.
                 * @param canvasType The type of the Canvas. Either `Phaser.CANVAS` or `Phaser.WEBGL`. Default Phaser.CANVAS.
                 */
                function first(canvasType?: integer): HTMLCanvasElement;

                /**
                 * Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
                 * The canvas has its width and height set to 1, and its parent attribute nulled.
                 * @param parent [description]
                 */
                function remove(parent: any): void;

                /**
                 * Gets the total number of used canvas elements in the pool.
                 */
                function total(): integer;

                /**
                 * Gets the total number of free canvas elements in the pool.
                 */
                function free(): integer;

                /**
                 * Disable context smoothing on any new Canvas element created.
                 */
                function disableSmoothing(): void;

                /**
                 * Enable context smoothing on any new Canvas element created.
                 */
                function enableSmoothing(): void;

            }

            namespace Smoothing {
                /**
                 * Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.
                 * @param context [description]
                 */
                function getPrefix(context: CanvasRenderingContext2D | WebGLRenderingContext): string;

                /**
                 * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
                 * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
                 * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
                 * drawn to the context will be affected. This sets the property across all current browsers but support is
                 * patchy on earlier browsers, especially on mobile.
                 * @param context [description]
                 */
                function enable(context: CanvasRenderingContext2D | WebGLRenderingContext): CanvasRenderingContext2D | WebGLRenderingContext;

                /**
                 * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
                 * By default browsers have image smoothing enabled, which isn't always what you visually want, especially
                 * when using pixel art in a game. Note that this sets the property on the context itself, so that any image
                 * drawn to the context will be affected. This sets the property across all current browsers but support is
                 * patchy on earlier browsers, especially on mobile.
                 * @param context [description]
                 */
                function disable(context: CanvasRenderingContext2D | WebGLRenderingContext): CanvasRenderingContext2D | WebGLRenderingContext;

                /**
                 * Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.
                 * Returns null if no smoothing prefix is available.
                 * @param context [description]
                 */
                function isEnabled(context: CanvasRenderingContext2D | WebGLRenderingContext): boolean;

            }

            /**
             * Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
             * @param canvas The canvas element to have the style applied to.
             * @param value The touch action value to set on the canvas. Set to `none` to disable touch actions. Default 'none'.
             */
            function TouchAction(canvas: HTMLCanvasElement, value?: string): HTMLCanvasElement;

            /**
             * Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
             * @param canvas The canvas element to have the style applied to.
             * @param value The touch callout value to set on the canvas. Set to `none` to disable touch callouts. Default 'none'.
             */
            function UserSelect(canvas: HTMLCanvasElement, value?: string): HTMLCanvasElement;

        }

        /**
         * The Color class holds a single color value and allows for easy modification and reading of it.
         */
        class Color {
            /**
             * 
             * @param red The red color value. A number between 0 and 255. Default 0.
             * @param green The green color value. A number between 0 and 255. Default 0.
             * @param blue The blue color value. A number between 0 and 255. Default 0.
             * @param alpha The alpha value. A number between 0 and 255. Default 255.
             */
            constructor(red?: integer, green?: integer, blue?: integer, alpha?: integer);

            /**
             * An array containing the calculated color values for WebGL use.
             */
            gl: number[];

            /**
             * Sets this color to be transparent. Sets all values to zero.
             */
            transparent(): Phaser.Display.Color;

            /**
             * Sets the color of this Color component.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             * @param alpha The alpha value. A number between 0 and 255. Default 255.
             */
            setTo(red: integer, green: integer, blue: integer, alpha?: integer): Phaser.Display.Color;

            /**
             * Sets the red, green, blue and alpha GL values of this Color component.
             * @param red The red color value. A number between 0 and 1.
             * @param green The green color value. A number between 0 and 1.
             * @param blue The blue color value. A number between 0 and 1.
             * @param alpha The alpha value. A number between 0 and 1. Default 1.
             */
            setGLTo(red: number, green: number, blue: number, alpha?: number): Phaser.Display.Color;

            /**
             * Sets the color based on the color object given.
             * @param color An object containing `r`, `g`, `b` and optionally `a` values in the range 0 to 255.
             */
            setFromRGB(color: InputColorObject): Phaser.Display.Color;

            /**
             * Updates the internal cache values.
             */
            update(): Phaser.Display.Color;

            /**
             * Returns a new Color component using the values from this one.
             */
            clone(): Phaser.Display.Color;

            /**
             * The color of this Color component, not including the alpha channel.
             */
            color: number;

            /**
             * The color of this Color component, including the alpha channel.
             */
            color32: number;

            /**
             * The color of this Color component as a string which can be used in CSS color values.
             */
            rgba: string;

            /**
             * The red color value, normalized to the range 0 to 1.
             */
            redGL: number;

            /**
             * The green color value, normalized to the range 0 to 1.
             */
            greenGL: number;

            /**
             * The blue color value, normalized to the range 0 to 1.
             */
            blueGL: number;

            /**
             * The alpha color value, normalized to the range 0 to 1.
             */
            alphaGL: number;

            /**
             * The red color value, normalized to the range 0 to 255.
             */
            red: number;

            /**
             * The green color value, normalized to the range 0 to 255.
             */
            green: number;

            /**
             * The blue color value, normalized to the range 0 to 255.
             */
            blue: number;

            /**
             * The alpha color value, normalized to the range 0 to 255.
             */
            alpha: number;

            /**
             * Converts the given color value into an Object containing r,g,b and a properties.
             * @param color A color value, optionally including the alpha value.
             */
            static ColorToRGBA(color: number): ColorObject;

            /**
             * Returns a string containing a hex representation of the given color component.
             * @param color The color channel to get the hex value for, must be a value between 0 and 255.
             */
            static ComponentToHex(color: integer): string;

            /**
             * Given 3 separate color values this will return an integer representation of it.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             */
            static GetColor(red: integer, green: integer, blue: integer): number;

            /**
             * Given an alpha and 3 color values this will return an integer representation of it.
             * @param red The red color value. A number between 0 and 255.
             * @param green The green color value. A number between 0 and 255.
             * @param blue The blue color value. A number between 0 and 255.
             * @param alpha The alpha color value. A number between 0 and 255.
             */
            static GetColor32(red: integer, green: integer, blue: integer, alpha: integer): number;

            /**
             * Converts a hex string into a Phaser Color object.
             * 
             * The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.
             * 
             * An alpha channel is _not_ supported.
             * @param hex The hex color value to convert, such as `#0033ff` or the short-hand format: `#03f`.
             */
            static HexStringToColor(hex: string): Phaser.Display.Color;

            /**
             * Converts HSL (hue, saturation and lightness) values to a Phaser Color object.
             * @param h The hue value in the range 0 to 1.
             * @param s The saturation value in the range 0 to 1.
             * @param l The lightness value in the range 0 to 1.
             */
            static HSLToColor(h: number, s: number, l: number): Phaser.Display.Color;

            /**
             * Get HSV color wheel values in an array which will be 360 elements in size.
             * @param s The saturation, in the range 0 - 1. Default 1.
             * @param v The value, in the range 0 - 1. Default 1.
             */
            static HSVColorWheel(s?: number, v?: number): any[];

            /**
             * Converts an HSV (hue, saturation and value) color value to RGB.
             * Conversion formula from http://en.wikipedia.org/wiki/HSL_color_space.
             * Assumes HSV values are contained in the set [0, 1].
             * Based on code by Michael Jackson (https://github.com/mjijackson)
             * @param h The hue, in the range 0 - 1.
             * @param s The saturation, in the range 0 - 1.
             * @param v The value, in the range 0 - 1.
             */
            static HSVToRGB(h: number, s: number, v: number): ColorObject;

            /**
             * Converts a hue to an RGB color.
             * Based on code by Michael Jackson (https://github.com/mjijackson)
             */
            static HueToComponent(p: number, q: number, t: number): number;

            /**
             * Converts the given color value into an instance of a Color object.
             * @param input The color value to convert into a Color object.
             */
            static IntegerToColor(input: integer): Phaser.Display.Color;

            /**
             * Return the component parts of a color as an Object with the properties alpha, red, green, blue.
             * 
             * Alpha will only be set if it exists in the given color (0xAARRGGBB)
             * @param input The color value to convert into a Color object.
             */
            static IntegerToRGB(input: integer): ColorObject;

            /**
             * Converts an object containing `r`, `g`, `b` and `a` properties into a Color class instance.
             * @param input An object containing `r`, `g`, `b` and `a` properties in the range 0 to 255.
             */
            static ObjectToColor(input: InputColorObject): Phaser.Display.Color;

            /**
             * Creates a new Color object where the r, g, and b values have been set to random values
             * based on the given min max values.
             * @param min The minimum value to set the random range from (between 0 and 255) Default 0.
             * @param max The maximum value to set the random range from (between 0 and 255) Default 255.
             */
            static RandomRGB(min?: integer, max?: integer): Phaser.Display.Color;

            /**
             * Converts a CSS 'web' string into a Phaser Color object.
             * 
             * The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
             * @param rgb The CSS format color string, using the `rgb` or `rgba` format.
             */
            static RGBStringToColor(rgb: string): Phaser.Display.Color;

            /**
             * Converts an RGB color value to HSV (hue, saturation and value).
             * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
             * Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
             * Based on code by Michael Jackson (https://github.com/mjijackson)
             * @param r The red color value. A number between 0 and 255.
             * @param g The green color value. A number between 0 and 255.
             * @param b The blue color value. A number between 0 and 255.
             */
            static RGBToHSV(r: integer, g: integer, b: integer): HSLColorObject;

            /**
             * Converts the color values into an HTML compatible color string, prefixed with either `#` or `0x`.
             * @param r The red color value. A number between 0 and 255.
             * @param g The green color value. A number between 0 and 255.
             * @param b The blue color value. A number between 0 and 255.
             * @param a The alpha value. A number between 0 and 255. Default 255.
             * @param prefix The prefix of the string. Either `#` or `0x`. Default #.
             */
            static RGBToString(r: integer, g: integer, b: integer, a?: integer, prefix?: string): string;

            /**
             * Converts the given source color value into an instance of a Color class.
             * The value can be either a string, prefixed with `rgb` or a hex string, a number or an Object.
             * @param input The source color value to convert.
             */
            static ValueToColor(input: string | number | InputColorObject): Phaser.Display.Color;

        }

        namespace Masks {
            /**
             * [description]
             */
            class BitmapMask {
                /**
                 * 
                 * @param scene [description]
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                constructor(scene: Phaser.Scene, renderable: Phaser.GameObjects.GameObject);

                /**
                 * A renderable Game Object that uses a texture, such as a Sprite.
                 */
                bitmapMask: Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                maskTexture: WebGLTexture;

                /**
                 * [description]
                 */
                mainTexture: WebGLTexture;

                /**
                 * [description]
                 */
                dirty: boolean;

                /**
                 * [description]
                 */
                mainFramebuffer: WebGLFramebuffer;

                /**
                 * [description]
                 */
                maskFramebuffer: WebGLFramebuffer;

                /**
                 * [description]
                 */
                invertAlpha: boolean;

                /**
                 * [description]
                 * @param renderable A renderable Game Object that uses a texture, such as a Sprite.
                 */
                setBitmap(renderable: Phaser.GameObjects.GameObject): void;

                /**
                 * [description]
                 * @param renderer [description]
                 * @param maskedObject [description]
                 * @param camera The Camera to render to.
                 */
                preRenderWebGL(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer, maskedObject: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 * @param renderer [description]
                 */
                postRenderWebGL(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer): void;

                /**
                 * [description]
                 * @param renderer [description]
                 * @param mask [description]
                 * @param camera The Camera to render to.
                 */
                preRenderCanvas(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer, mask: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 * @param renderer [description]
                 */
                postRenderCanvas(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer): void;

            }

            /**
             * [description]
             */
            class GeometryMask {
                /**
                 * 
                 * @param scene [description]
                 * @param graphicsGeometry [description]
                 */
                constructor(scene: Phaser.Scene, graphicsGeometry: Phaser.GameObjects.Graphics);

                /**
                 * [description]
                 */
                geometryMask: Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 * @param graphicsGeometry [description]
                 */
                setShape(graphicsGeometry: Phaser.GameObjects.Graphics): void;

                /**
                 * [description]
                 * @param renderer [description]
                 * @param mask [description]
                 * @param camera [description]
                 */
                preRenderWebGL(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer, mask: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 * @param renderer [description]
                 */
                postRenderWebGL(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer): void;

                /**
                 * [description]
                 * @param renderer [description]
                 * @param mask [description]
                 * @param camera [description]
                 */
                preRenderCanvas(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer, mask: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 * @param renderer [description]
                 */
                postRenderCanvas(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer): void;

            }

        }

    }

    namespace DOM {
        /**
         * Adds the given element to the DOM. If a parent is provided the element is added as a child of the parent, providing it was able to access it.
         * If no parent was given or falls back to using `document.body`.
         * @param element The element to be added to the DOM. Usually a Canvas object.
         * @param parent The parent in which to add the element. Can be a string which is passed to `getElementById` or an actual DOM object.
         * @param overflowHidden Whether or not to hide overflowing content inside the parent. Default true.
         */
        function AddToDOM(element: HTMLElement, parent?: string | HTMLElement, overflowHidden?: boolean): HTMLElement;

        /**
         * Inspects the readyState of the document. If the document is already complete then it invokes the given callback.
         * If not complete it sets up several event listeners such as `deviceready`, and once those fire, it invokes the callback.
         * Called automatically by the Phaser.Game instance. Should not usually be accessed directly.
         * @param callback The callback to be invoked when the device is ready and the DOM content is loaded.
         */
        function DOMContentLoaded(callback: ContentLoadedCallback): void;

        /**
         * Takes the given data string and parses it as XML.
         * First tries to use the window.DOMParser and reverts to the Microsoft.XMLDOM if that fails.
         * The parsed XML object is returned, or `null` if there was an error while parsing the data.
         * @param data The XML source stored in a string.
         */
        function ParseXML(data: string): DOMParser | ActiveXObject;

        /**
         * Attempts to remove the element from its parentNode in the DOM.
         * @param element The DOM element to remove from its parent node.
         */
        function RemoveFromDOM(element: HTMLElement): void;

        /**
         * Abstracts away the use of RAF or setTimeOut for the core game update loop.
         * 
         * This is invoked automatically by the Phaser.Game instance.
         */
        class RequestAnimationFrame {
            /**
             * True if RequestAnimationFrame is running, otherwise false.
             */
            isRunning: boolean;

            /**
             * The callback to be invoked each step.
             */
            callback: FrameRequestCallback;

            /**
             * The most recent timestamp. Either a DOMHighResTimeStamp under RAF or `Date.now` under SetTimeout.
             */
            tick: number;

            /**
             * True if the step is using setTimeout instead of RAF.
             */
            isSetTimeOut: boolean;

            /**
             * The setTimeout or RAF callback ID used when canceling them.
             */
            timeOutID: number;

            /**
             * The previous time the step was called.
             */
            lastTime: number;

            /**
             * The RAF step function.
             * Updates the local tick value, invokes the callback and schedules another call to requestAnimationFrame.
             */
            step: FrameRequestCallback;

            /**
             * The SetTimeout step function.
             * Updates the local tick value, invokes the callback and schedules another call to setTimeout.
             */
            stepTimeout: Function;

            /**
             * Starts the requestAnimationFrame or setTimeout process running.
             * @param callback The callback to invoke each step.
             * @param forceSetTimeOut Should it use SetTimeout, even if RAF is available?
             */
            start(callback: FrameRequestCallback, forceSetTimeOut: boolean): void;

            /**
             * Stops the requestAnimationFrame or setTimeout from running.
             */
            stop(): void;

            /**
             * Stops the step from running and clears the callback reference.
             */
            destroy(): void;

        }

    }

    namespace Events {
        /**
         * EventEmitter is a Scene Systems plugin compatible version of eventemitter3.
         */
        class EventEmitter {
            /**
             * Removes all listeners.
             */
            shutdown(): void;

            /**
             * Removes all listeners.
             */
            destroy(): void;

            /**
             * Return an array listing the events for which the emitter has registered listeners.
             */
            eventNames(): any[];

            /**
             * Return the listeners registered for a given event.
             * @param event The event name.
             */
            listeners(event: string | symbol): any[];

            /**
             * Return the number of listeners listening to a given event.
             * @param event The event name.
             */
            listenerCount(event: string | symbol): number;

            /**
             * Calls each of the listeners registered for a given event.
             * @param event The event name.
             * @param args Additional arguments that will be passed to the event handler.
             */
            emit(event: string | symbol, ...args: any[]): boolean;

            /**
             * Add a listener for a given event.
             * @param event The event name.
             * @param fn The listener function.
             * @param context The context to invoke the listener with. Default this.
             */
            on(event: string | symbol, fn: Function, context?: any): Phaser.Events.EventEmitter;

            /**
             * Add a listener for a given event.
             * @param event The event name.
             * @param fn The listener function.
             * @param context The context to invoke the listener with. Default this.
             */
            addListener(event: string | symbol, fn: Function, context?: any): Phaser.Events.EventEmitter;

            /**
             * Add a one-time listener for a given event.
             * @param event The event name.
             * @param fn The listener function.
             * @param context The context to invoke the listener with. Default this.
             */
            once(event: string | symbol, fn: Function, context?: any): Phaser.Events.EventEmitter;

            /**
             * Remove the listeners of a given event.
             * @param event The event name.
             * @param fn Only remove the listeners that match this function.
             * @param context Only remove the listeners that have this context.
             * @param once Only remove one-time listeners.
             */
            removeListener(event: string | symbol, fn: Function, context: any, once: boolean): Phaser.Events.EventEmitter;

            /**
             * Remove the listeners of a given event.
             * @param event The event name.
             * @param fn Only remove the listeners that match this function.
             * @param context Only remove the listeners that have this context.
             * @param once Only remove one-time listeners.
             */
            off(event: string | symbol, fn: Function, context: any, once: boolean): Phaser.Events.EventEmitter;

            /**
             * Remove all listeners, or those of the specified event.
             * @param event The event name.
             */
            removeAllListeners(event?: string | symbol): Phaser.Events.EventEmitter;

        }

    }

    namespace GameObjects {
        /**
         * [description]
         */
        class DynamicBitmapText extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
             * @param x The x coordinate of this Game Object in world space.
             * @param y The y coordinate of this Game Object in world space.
             * @param font [description]
             * @param text [description]
             * @param size [description]
             */
            constructor(scene: Phaser.Scene, x: number, y: number, font: string, text?: string | string[], size?: number);

            /**
             * [description]
             */
            font: string;

            /**
             * [description]
             */
            fontData: object;

            /**
             * [description]
             */
            text: string;

            /**
             * [description]
             */
            fontSize: number;

            /**
             * Adds/Removes spacing between characters
             * Can be a negative or positive number
             */
            letterSpacing: number;

            /**
             * [description]
             */
            scrollX: number;

            /**
             * [description]
             */
            scrollY: number;

            /**
             * [description]
             */
            cropWidth: number;

            /**
             * [description]
             */
            cropHeight: number;

            /**
             * [description]
             */
            "displayCallback;": DisplayCallback;

            /**
             * [description]
             * @param width [description]
             * @param height [description]
             */
            setSize(width: number, height: number): Phaser.GameObjects.DynamicBitmapText;

            /**
             * [description]
             * @param callback [description]
             */
            setDisplayCallback(callback: DisplayCallback): Phaser.GameObjects.DynamicBitmapText;

            /**
             * [description]
             * @param size [description]
             */
            setFontSize(size: number): Phaser.GameObjects.DynamicBitmapText;

            /**
             * [description]
             * @param value The string, or array of strings, to be set as the content of this BitmapText.
             */
            setText(value: string | string[]): Phaser.GameObjects.DynamicBitmapText;

            /**
             * [description]
             * @param value [description]
             */
            setScrollX(value: number): Phaser.GameObjects.DynamicBitmapText;

            /**
             * [description]
             * @param value [description]
             */
            setScrollY(value: number): Phaser.GameObjects.DynamicBitmapText;

            /**
             * [description]
             * @param round [description]
             */
            getTextBounds(round: boolean): TextBounds;

            /**
             * [description]
             */
            width: number;

            /**
             * [description]
             */
            height: number;

            /**
             * [description]
             */
            toJSON(): JSONBitmapText;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        namespace RetroFont {
            /**
             * Text Set 1 =  !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~
             */
            var TEXT_SET1: string;

            /**
             * Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
             */
            var TEXT_SET2: string;

            /**
             * Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
             */
            var TEXT_SET3: string;

            /**
             * Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
             */
            var TEXT_SET4: string;

            /**
             * Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
             */
            var TEXT_SET5: string;

            /**
             * Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.'
             */
            var TEXT_SET6: string;

            /**
             * Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
             */
            var TEXT_SET7: string;

            /**
             * Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
             */
            var TEXT_SET8: string;

            /**
             * Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
             */
            var TEXT_SET9: string;

            /**
             * Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
             */
            var TEXT_SET10: string;

            /**
             * Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
             */
            var TEXT_SET11: string;

            /**
             * Parses a Retro Font configuration object so you can pass it to the BitmapText constructor
             * and create a BitmapText object using a fixed-width retro font.
             * @param scene A reference to the Phaser Scene.
             * @param config The font configuration object.
             */
            function Parse(scene: Phaser.Scene, config: Phaser.GameObjects.RetroFont.Config): void;

            type Config = {
                /**
                 * [description]
                 */
                image: string;
                /**
                 * If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
                 */
                "offset.x": number;
                /**
                 * If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
                 */
                "offset.y": number;
                /**
                 * The width of each character in the font set.
                 */
                width: number;
                /**
                 * The height of each character in the font set.
                 */
                height: number;
                /**
                 * The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.
                 */
                chars: string;
                /**
                 * The number of characters per row in the font set. If not given charsPerRow will be the image width / characterWidth.
                 */
                charsPerRow: number;
                /**
                 * If the characters in the font set have horizontal spacing between them set the required amount here.
                 */
                "spacing.x": number;
                /**
                 * If the characters in the font set have vertical spacing between them set the required amount here.
                 */
                "spacing.y": number;
            };

        }

        /**
         * [description]
         */
        class BitmapText extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
             * @param x The x coordinate of this Game Object in world space.
             * @param y The y coordinate of this Game Object in world space.
             * @param font [description]
             * @param text [description]
             * @param size [description]
             */
            constructor(scene: Phaser.Scene, x: number, y: number, font: string, text?: string | string[], size?: number);

            /**
             * [description]
             */
            font: string;

            /**
             * [description]
             */
            fontData: object;

            /**
             * [description]
             */
            text: string;

            /**
             * [description]
             */
            fontSize: number;

            /**
             * Adds/Removes spacing between characters
             * Can be a negative or positive number
             */
            letterSpacing: number;

            /**
             * [description]
             * @param size [description]
             */
            setFontSize(size: number): Phaser.GameObjects.BitmapText;

            /**
             * Sets the letter spacing between each character of this Bitmap Text.
             * Can be a positive value to increase the space, or negative to reduce it.
             * Spacing is applied after the kerning values have been set.
             * @param spacing The amount of horizontal space to add between each character. Default 0.
             */
            setLetterSpacing(spacing?: number): Phaser.GameObjects.BitmapText;

            /**
             * [description]
             * @param value The string, or array of strings, to be set as the content of this BitmapText.
             */
            setText(value: string | string[]): Phaser.GameObjects.BitmapText;

            /**
             * [description]
             * @param round [description]
             */
            getTextBounds(round: boolean): TextBounds;

            /**
             * [description]
             */
            width: number;

            /**
             * [description]
             */
            height: number;

            /**
             * [description]
             */
            toJSON(): JSONBitmapText;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * A Blitter Game Object.
         * 
         * 
         * 
         * The Blitter Game Object is a special kind of container that creates, updates and manages Bob objects.
         * 
         * Bobs are designed for rendering speed rather than flexibility. They consist of a texture, or frame from a texture,
         * 
         * a position and an alpha value. You cannot scale or rotate them. They use a batched drawing method for speed
         * 
         * during rendering.
         * 
         * 
         * 
         * A Blitter Game Object has one texture bound to it. Bobs created by the Blitter can use any Frame from this
         * 
         * Texture to render with, but they cannot use any other Texture. It is this single texture-bind that allows
         * 
         * them their speed.
         * 
         * 
         * 
         * If you have a need to blast a large volume of frames around the screen then Blitter objects are well worth
         * 
         * investigating. They are especially useful for using as a base for your own special effects systems.
         */
        class Blitter extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. It can only belong to one Scene at any given time.
             * @param x The x coordinate of this Game Object in world space. Default 0.
             * @param y The y coordinate of this Game Object in world space. Default 0.
             * @param texture The key of the texture this Game Object will use for rendering. The Texture must already exist in the Texture Manager. Default '__DEFAULT'.
             * @param frame The Frame of the Texture that this Game Object will use. Only set if the Texture has multiple frames, such as a Texture Atlas or Sprite Sheet. Default 0.
             */
            constructor(scene: Phaser.Scene, x?: number, y?: number, texture?: string, frame?: string | integer);

            /**
             * [description]
             */
            children: Phaser.Structs.List<Phaser.GameObjects.Blitter.Bob>;

            /**
             * [description]
             */
            renderList: Phaser.GameObjects.Blitter.Bob[];

            /**
             * [description]
             * @param x The x position of the Bob. Bob coordinate are relative to the position of the Blitter object.
             * @param y The y position of the Bob. Bob coordinate are relative to the position of the Blitter object.
             * @param frame The Frame the Bob will use. It _must_ be part of the Texture the parent Blitter object is using.
             * @param visible Should the created Bob render or not? Default true.
             * @param index The position in the Blitters Display List to add the new Bob at. Defaults to the top of the list.
             */
            create(x: number, y: number, frame?: string | integer | Phaser.Textures.Frame, visible?: boolean, index?: integer): Phaser.GameObjects.Blitter.Bob;

            /**
             * [description]
             * @param callback The callback to invoke after creating a bob. It will be sent two arguments: The Bob and the index of the Bob.
             * @param quantity The quantity of Bob objects to create.
             * @param frame The Frame the Bobs will use. It must be part of the Blitter Texture.
             * @param visible [description] Default true.
             */
            createFromCallback(callback: Phaser.GameObjects.Blitter.BlitterFromCallback, quantity: integer, frame?: string | integer | Phaser.Textures.Frame | string[] | integer[] | Phaser.Textures.Frame[], visible?: boolean): Phaser.GameObjects.Blitter.Bob[];

            /**
             * [description]
             * @param quantity The quantity of Bob objects to create.
             * @param frame The Frame the Bobs will use. It must be part of the Blitter Texture.
             * @param visible [description] Default true.
             */
            createMultiple(quantity: integer, frame?: string | integer | Phaser.Textures.Frame | string[] | integer[] | Phaser.Textures.Frame[], visible?: boolean): Phaser.GameObjects.Blitter.Bob[];

            /**
             * [description]
             * @param child [description]
             */
            childCanRender(child: Phaser.GameObjects.Blitter.Bob): boolean;

            /**
             * [description]
             */
            getRenderList(): Phaser.GameObjects.Blitter.Bob[];

            /**
             * [description]
             */
            clear(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * Builds a Game Object using the provided configuration object.
         * @param scene [description]
         * @param gameObject [description]
         * @param config [description]
         */
        function BuildGameObject(scene: Phaser.Scene, gameObject: Phaser.GameObjects.GameObject, config: GameObjectConfig): Phaser.GameObjects.GameObject;

        /**
         * Adds an Animation component to a Sprite and populates it based on the given config.
         * @param sprite [description]
         * @param config [description]
         */
        function BuildGameObjectAnimation(sprite: Phaser.GameObjects.Sprite, config: object): Phaser.GameObjects.Sprite;

        namespace Components {
            /**
             * Provides methods used for setting the alpha properties of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Alpha {
                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;
                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;
                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;
                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;
                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;
                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;
                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;
            }

            interface Animation {
                /**
                 * The Game Object to which this animation controller belongs.
                 */
                parent: Phaser.GameObjects.GameObject;
                /**
                 * A reference to the global Animation Manager.
                 */
                animationManager: Phaser.Animations.AnimationManager;
                /**
                 * Is an animation currently playing or not?
                 */
                isPlaying: boolean;
                /**
                 * The current Animation loaded into this Animation Controller.
                 */
                currentAnim: Phaser.Animations.Animation;
                /**
                 * The current AnimationFrame being displayed by this Animation Controller.
                 */
                currentFrame: Phaser.Animations.AnimationFrame;
                /**
                 * The frame rate of playback in frames per second.
                 * The default is 24 if the `duration` property is `null`.
                 */
                frameRate: number;
                /**
                 * How long the animation should play for, in milliseconds.
                 * If the `frameRate` property has been set then it overrides this value,
                 * otherwise the `frameRate` is derived from `duration`.
                 */
                duration: number;
                /**
                 * ms per frame, not including frame specific modifiers that may be present in the Animation data.
                 */
                msPerFrame: number;
                /**
                 * Skip frames if the time lags, or always advanced anyway?
                 */
                skipMissedFrames: boolean;
                /**
                 * Will the playhead move forwards (`true`) or in reverse (`false`)
                 */
                forward: boolean;
                /**
                 * Internal time overflow accumulator.
                 */
                accumulator: number;
                /**
                 * The time point at which the next animation frame will change.
                 */
                nextTick: number;
                /**
                 * An internal counter keeping track of how many repeats are left to play.
                 */
                repeatCounter: number;
                /**
                 * An internal flag keeping track of pending repeats.
                 */
                pendingRepeat: boolean;
                /**
                 * Sets the amount of time, in milliseconds, that the animation will be delayed before starting playback.
                 * @param value The amount of time, in milliseconds, to wait before starting playback. Default 0.
                 */
                setDelay(value?: integer): Phaser.GameObjects.GameObject;
                /**
                 * Gets the amount of time, in milliseconds that the animation will be delayed before starting playback.
                 */
                getDelay(): integer;
                /**
                 * Waits for the specified delay, in milliseconds, then starts playback of the requested animation.
                 * @param delay The delay, in milliseconds, to wait before starting the animation playing.
                 * @param key The key of the animation to play.
                 * @param startFrame The frame of the animation to start from. Default 0.
                 */
                delayedPlay(delay: integer, key: string, startFrame?: integer): Phaser.GameObjects.GameObject;
                /**
                 * Returns the key of the animation currently loaded into this component.
                 */
                getCurrentKey(): string;
                /**
                 * Internal method used to load an animation into this component.
                 * @param key [description]
                 * @param startFrame [description] Default 0.
                 */
                load(key: string, startFrame?: integer): Phaser.GameObjects.GameObject;
                /**
                 * Pause the current animation and set the `isPlaying` property to `false`.
                 * You can optionally pause it at a specific frame.
                 * @param atFrame An optional frame to set after pausing the animation.
                 */
                pause(atFrame?: Phaser.Animations.AnimationFrame): Phaser.GameObjects.GameObject;
                /**
                 * Resumes playback of a paused animation and sets the `isPlaying` property to `true`.
                 * You can optionally tell it to start playback from a specific frame.
                 * @param fromFrame An optional frame to set before restarting playback.
                 */
                resume(fromFrame?: Phaser.Animations.AnimationFrame): Phaser.GameObjects.GameObject;
                /**
                 * `true` if the current animation is paused, otherwise `false`.
                 */
                isPaused: boolean;
                /**
                 * Plays an Animation on the Game Object that owns this Animation Component.
                 * @param key The string-based key of the animation to play, as defined previously in the Animation Manager.
                 * @param ignoreIfPlaying If an animation is already playing then ignore this call. Default false.
                 * @param startFrame Optionally start the animation playing from this frame index. Default 0.
                 */
                play(key: string, ignoreIfPlaying?: boolean, startFrame?: integer): Phaser.GameObjects.GameObject;
                /**
                 * Returns a value between 0 and 1 indicating how far this animation is through, ignoring repeats and yoyos.
                 * If the animation has a non-zero repeat defined, `getProgress` and `getTotalProgress` will be different
                 * because `getProgress` doesn't include any repeats or repeat delays, whereas `getTotalProgress` does.
                 */
                getProgress(): number;
                /**
                 * Takes a value between 0 and 1 and uses it to set how far this animation is through playback.
                 * Does not factor in repeats or yoyos, but does handle playing forwards or backwards.
                 * @param value [description] Default 0.
                 */
                setProgress(value?: number): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 * @param event [description]
                 */
                remove(event?: Phaser.Animations.Animation): void;
                /**
                 * Gets the number of times that the animation will repeat
                 * after its first iteration. For example, if returns 1, the animation will
                 * play a total of twice (the initial play plus 1 repeat).
                 * A value of -1 means the animation will repeat indefinitely.
                 */
                getRepeat(): integer;
                /**
                 * Sets the number of times that the animation should repeat
                 * after its first iteration. For example, if repeat is 1, the animation will
                 * play a total of twice (the initial play plus 1 repeat).
                 * To repeat indefinitely, use -1. repeat should always be an integer.
                 * @param value [description]
                 */
                setRepeat(value: integer): Phaser.GameObjects.GameObject;
                /**
                 * Gets the amount of delay between repeats, if any.
                 */
                getRepeatDelay(): number;
                /**
                 * Sets the amount of time in seconds between repeats.
                 * For example, if `repeat` is 2 and `repeatDelay` is 10, the animation will play initially,
                 * then wait for 10 seconds before repeating, then play again, then wait another 10 seconds
                 * before doing its final repeat.
                 * @param value The delay to wait between repeats, in seconds.
                 */
                setRepeatDelay(value: number): Phaser.GameObjects.GameObject;
                /**
                 * Restarts the current animation from its beginning, optionally including its delay value.
                 * @param includeDelay [description] Default false.
                 */
                restart(includeDelay?: boolean): Phaser.GameObjects.GameObject;
                /**
                 * Immediately stops the current animation from playing and dispatches the `animationcomplete` event.
                 */
                stop(): Phaser.GameObjects.GameObject;
                /**
                 * Stops the current animation from playing after the specified time delay, given in milliseconds.
                 * @param delay The number of milliseconds to wait before stopping this animation.
                 */
                stopAfterDelay(delay: integer): Phaser.GameObjects.GameObject;
                /**
                 * Stops the current animation from playing when it next repeats.
                 */
                stopOnRepeat(): Phaser.GameObjects.GameObject;
                /**
                 * Stops the current animation from playing when it next sets the given frame.
                 * If this frame doesn't exist within the animation it will not stop it from playing.
                 * @param delay The frame to check before stopping this animation.
                 */
                stopOnFrame(delay: Phaser.Animations.AnimationFrame): Phaser.GameObjects.GameObject;
                /**
                 * Sets the Time Scale factor, allowing you to make the animation go go faster or slower than default.
                 * Where 1 = normal speed (the default), 0.5 = half speed, 2 = double speed, etc.
                 * @param value The time scale factor, where 1 is no change, 0.5 is half speed, etc. Default 1.
                 */
                setTimeScale(value?: number): Phaser.GameObjects.GameObject;
                /**
                 * Gets the Time Scale factor.
                 */
                getTimeScale(): number;
                /**
                 * Returns the total number of frames in this animation.
                 */
                getTotalFrames(): integer;
                /**
                 * The internal update loop for the Animation Component.
                 * @param timestamp [description]
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                update(timestamp: number, delta: number): void;
                /**
                 * Sets the given Animation Frame as being the current frame
                 * and applies it to the parent Game Object, adjusting its size and origin as needed.
                 * @param animationFrame The Animation Frame to set as being current.
                 */
                setCurrentFrame(animationFrame: Phaser.Animations.AnimationFrame): Phaser.GameObjects.GameObject;
                /**
                 * Sets if the current Animation will yoyo when it reaches the end.
                 * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.
                 * @param value `true` if the animation should yoyo, `false` to not. Default false.
                 */
                setYoyo(value?: boolean): Phaser.GameObjects.GameObject;
                /**
                 * Gets if the current Animation will yoyo when it reaches the end.
                 * A yoyo'ing animation will play through consecutively, and then reverse-play back to the start again.
                 */
                getYoyo(): boolean;
                /**
                 * [description]
                 */
                destroy(): void;
            }

            /**
             * Provides methods used for setting the blend mode of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface BlendMode {
                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;
                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for calculating and setting the size of a non-Frame based Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface ComputedSize {
                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;
                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;
                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;
                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;
                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for setting the depth of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Depth {
                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;
                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for visually flipping a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Flip {
                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;
                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;
                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;
                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;
                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;
                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;
                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;
                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for obtaining the bounds of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface GetBounds {
                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;
                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;
                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;
            }

            /**
             * Provides methods used for getting and setting the transform values of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface MatrixStack {
                /**
                 * [description]
                 */
                initMatrixStack(): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 */
                save(): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 */
                restore(): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 */
                loadIdentity(): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 * @param a [description]
                 * @param b [description]
                 * @param c [description]
                 * @param d [description]
                 * @param tx [description]
                 * @param ty [description]
                 */
                transform(a: number, b: number, c: number, d: number, tx: number, ty: number): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 * @param a [description]
                 * @param b [description]
                 * @param c [description]
                 * @param d [description]
                 * @param tx [description]
                 * @param ty [description]
                 */
                setTransform(a: number, b: number, c: number, d: number, tx: number, ty: number): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                translate(x: number, y: number): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                scale(x: number, y: number): Phaser.GameObjects.GameObject;
                /**
                 * [description]
                 * @param t The angle of rotation, in radians.
                 */
                rotate(t: number): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for getting and setting the origin of a Game Object.
             * Values are normalized, given in the range 0 to 1.
             * Display values contain the calculated pixel values.
             * Should be applied as a mixin and not used directly.
             */
            interface Origin {
                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;
                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;
                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;
                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;
                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;
                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;
                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for setting the WebGL rendering pipeline of a Game Object.
             */
            interface Pipeline {
                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;
                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;
                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;
                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;
                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;
                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;
            }

            /**
             * Provides methods used for getting and setting the scale of a Game Object.
             */
            interface ScaleMode {
                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;
                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for getting and setting the Scroll Factor of a Game Object.
             */
            interface ScrollFactor {
                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;
                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;
                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for getting and setting the size of a Game Object.
             */
            interface Size {
                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;
                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;
                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;
                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;
                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;
                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for getting and setting the texture of a Game Object.
             */
            interface Texture {
                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;
                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;
                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;
                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;
            }

            /**
             * Provides methods used for setting the tint of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Tint {
                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;
                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;
                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;
                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;
                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;
                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;
                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;
            }

            /**
             * [description]
             * @param gameObject [description]
             */
            function ToJSON(gameObject: Phaser.GameObjects.GameObject): JSONGameObject;

            /**
             * Provides methods used for getting and setting the position, scale and rotation of a Game Object.
             */
            interface Transform {
                /**
                 * The x position of this Game Object.
                 */
                x: number;
                /**
                 * The y position of this Game Object.
                 */
                y: number;
                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;
                /**
                 * The w position of this Game Object.
                 */
                w: number;
                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;
                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;
                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;
                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;
                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;
                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;
                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;
                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;
            }

            /**
             * [description]
             */
            class TransformMatrix {
                /**
                 * 
                 * @param a The Scale X value. Default 1.
                 * @param b The Shear Y value. Default 0.
                 * @param c The Shear X value. Default 0.
                 * @param d The Scale Y value. Default 1.
                 * @param tx The Translate X value. Default 0.
                 * @param ty The Translate Y value. Default 0.
                 */
                constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);

                /**
                 * [description]
                 */
                matrix: Float32Array;

                /**
                 * [description]
                 */
                decomposedMatrix: object;

                /**
                 * [description]
                 */
                a: number;

                /**
                 * [description]
                 */
                b: number;

                /**
                 * [description]
                 */
                c: number;

                /**
                 * [description]
                 */
                d: number;

                /**
                 * [description]
                 */
                tx: number;

                /**
                 * [description]
                 */
                ty: number;

                /**
                 * [description]
                 */
                rotation: number;

                /**
                 * [description]
                 */
                scaleX: number;

                /**
                 * [description]
                 */
                scaleY: number;

                /**
                 * [description]
                 */
                loadIdentity(): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                translate(x: number, y: number): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                scale(x: number, y: number): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param radian [description]
                 */
                rotate(radian: number): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param rhs [description]
                 */
                multiply(rhs: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param a The Scale X value.
                 * @param b The Shear Y value.
                 * @param c The Shear X value.
                 * @param d The Scale Y value.
                 * @param tx The Translate X value.
                 * @param ty The Translate Y value.
                 */
                transform(a: number, b: number, c: number, d: number, tx: number, ty: number): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param point [description]
                 */
                transformPoint(x: number, y: number, point: Phaser.Geom.Point | Phaser.Math.Vector2 | object): Phaser.Geom.Point | Phaser.Math.Vector2 | object;

                /**
                 * [description]
                 */
                invert(): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 * @param a [description]
                 * @param b [description]
                 * @param c [description]
                 * @param d [description]
                 * @param tx [description]
                 * @param ty [description]
                 */
                setTransform(a: number, b: number, c: number, d: number, tx: number, ty: number): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * [description]
                 */
                decomposeMatrix(): object;

                /**
                 * Identity + Translate + Rotate + Scale
                 * @param x [description]
                 * @param y [description]
                 * @param rotation [description]
                 * @param scaleX [description]
                 * @param scaleY [description]
                 */
                applyITRS(x: number, y: number, rotation: number, scaleX: number, scaleY: number): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Destroys this Transform Matrix.
                 */
                destroy(): void;

            }

            /**
             * Provides methods used for setting the visibility of a Game Object.
             * Should be applied as a mixin and not used directly.
             */
            interface Visible {
                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;
                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;
            }

        }

        /**
         * A Container Game Object.
         * 
         * 
         * 
         * A Container, as the name implies, can 'contain' other types of Game Object.
         * 
         * When a Game Object is added to a Container, the Container becomes responsible for the rendering of it.
         * 
         * By default it will be removed from the Display List and instead added to the Containers own internal list.
         * 
         * 
         * 
         * The position of the Game Object automatically becomes relative to the position of the Container.
         * 
         * 
         * 
         * When the Container is rendered, all of its children are rendered as well, in the order in which they exist
         * 
         * within the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.
         * 
         * 
         * 
         * If you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will
         * 
         * automatically influence all children as well.
         * 
         * 
         * 
         * Containers can include other Containers for deeply nested transforms.
         * 
         * 
         * 
         * Containers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.
         * 
         * The masks do not 'stack up'. Only a Container on the root of the display list will use its mask.
         * 
         * 
         * 
         * Containers can be enabled for input. Because they do not have a texture you need to provide a shape for them
         * 
         * to use as their hit area. Container children can also be enabled for input, independent of the Container.
         * 
         * 
         * 
         * Containers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,
         * 
         * if Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,
         * 
         * if the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children
         * 
         * with physics do not factor in the Container due to the excessive extra calculations needed. Please structure
         * 
         * your game to work around this.
         * 
         * 
         * 
         * It's important to understand the impact of using Containers. They add additional processing overhead into
         * 
         * every one of their children. The deeper you nest them, the more the cost escalates. This is especially true
         * 
         * for input events. You also loose the ability to set the display depth of Container children in the same
         * 
         * flexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost
         * 
         * every time you create one, try to structure your game around avoiding that where possible.
         */
        class Container extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world. Default 0.
             * @param y The vertical position of this Game Object in the world. Default 0.
             * @param children An optional array of Game Objects to add to this Container.
             */
            constructor(scene: Phaser.Scene, x?: number, y?: number, children?: Phaser.GameObjects.GameObject[]);

            /**
             * An array holding the children of this Container.
             */
            list: Phaser.GameObjects.GameObject[];

            /**
             * Does this Container exclusively manage its children?
             * 
             * The default is `true` which means a child added to this Container cannot
             * belong in another Container, which includes the Scene display list.
             * 
             * If you disable this then this Container will no longer exclusively manage its children.
             * This allows you to create all kinds of interesting graphical effects, such as replicating
             * Game Objects without reparenting them all over the Scene.
             * However, doing so will prevent children from receiving any kind of input event or have
             * their physics bodies work by default, as they're no longer a single entity on the
             * display list, but are being replicated where-ever this Container is.
             */
            exclusive: boolean;

            /**
             * Containers can have an optional maximum size. If set to anything above 0 it
             * will constrict the addition of new Game Objects into the Container, capping off
             * the maximum limit the Container can grow in size to.
             */
            maxSize: integer;

            /**
             * The cursor position.
             */
            position: integer;

            /**
             * Internal Transform Matrix used for local space conversion.
             */
            localTransform: Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The property key to sort by.
             */
            _sortKey: string;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            originX: number;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            originY: number;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            displayOriginX: number;

            /**
             * Internal value to allow Containers to be used for input and physics.
             * Do not change this value. It has no effect other than to break things.
             */
            displayOriginY: number;

            /**
             * Does this Container exclusively manage its children?
             * 
             * The default is `true` which means a child added to this Container cannot
             * belong in another Container, which includes the Scene display list.
             * 
             * If you disable this then this Container will no longer exclusively manage its children.
             * This allows you to create all kinds of interesting graphical effects, such as replicating
             * Game Objects without reparenting them all over the Scene.
             * However, doing so will prevent children from receiving any kind of input event or have
             * their physics bodies work by default, as they're no longer a single entity on the
             * display list, but are being replicated where-ever this Container is.
             * @param value The exclusive state of this Container. Default true.
             */
            setExclusive(value?: boolean): Phaser.GameObjects.Container;

            /**
             * Gets the bounds of this Container. It works by iterating all children of the Container,
             * getting their respective bounds, and then working out a min-max rectangle from that.
             * It does not factor in if the children render or not, all are included.
             * 
             * Depending on the quantity of children in this Container it could be a really expensive call,
             * so cache it and only poll it as needed.
             * 
             * The values are stored and returned in a Rectangle object.
             * @param output A Geom.Rectangle object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds(output?: Phaser.Geom.Rectangle): Phaser.Geom.Rectangle;

            /**
             * Takes a Point-like object, such as a Vector2, Geom.Point or object with public x and y properties,
             * and transforms it into the space of this Container, then returns it in the output object.
             * @param source The Source Point to be transformed.
             * @param output A destination object to store the transformed point in. If none given a Vector2 will be created and returned.
             */
            pointToContainer(source: object | Phaser.Geom.Point | Phaser.Math.Vector2, output?: object | Phaser.Geom.Point | Phaser.Math.Vector2): object | Phaser.Geom.Point | Phaser.Math.Vector2;

            /**
             * Returns the world transform matrix as used for Bounds checks.
             * The returned matrix is a temporal and shouldn't be stored.
             */
            getBoundsTransformMatrix(): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Adds the given Game Object, or array of Game Objects, to this Container.
             * 
             * Each Game Object must be unique within the Container.
             * @param child The Game Object, or array of Game Objects, to add to the Container.
             */
            add(child: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): Phaser.GameObjects.Container;

            /**
             * Adds the given Game Object, or array of Game Objects, to this Container at the specified position.
             * 
             * Existing Game Objects in the Container are shifted up.
             * 
             * Each Game Object must be unique within the Container.
             * @param child The Game Object, or array of Game Objects, to add to the Container.
             * @param index The position to insert the Game Object/s at. Default 0.
             */
            addAt(child: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], index?: integer): Phaser.GameObjects.Container;

            /**
             * Returns the Game Object at the given position in this Container.
             * @param index The position to get the Game Object from.
             */
            getAt(index: integer): Phaser.GameObjects.GameObject;

            /**
             * Returns the index of the given Game Object in this Container.
             * @param child The Game Object to search for in this Container.
             */
            getIndex(child: Phaser.GameObjects.GameObject): integer;

            /**
             * Sort the contents of this Container so the items are in order based on the given property.
             * For example: `sort('alpha')` would sort the elements based on the value of their `alpha` property.
             * @param property The property to lexically sort by.
             */
            sort(property: string): Phaser.GameObjects.Container;

            /**
             * Searches for the first instance of a child with its `name` property matching the given argument.
             * Should more than one child have the same name only the first is returned.
             * @param name The name to search for.
             */
            getByName(name: string): Phaser.GameObjects.GameObject;

            /**
             * Returns a random Game Object from this Container.
             * @param startIndex An optional start index. Default 0.
             * @param length An optional length, the total number of elements (from the startIndex) to choose from.
             */
            getRandom(startIndex?: integer, length?: integer): Phaser.GameObjects.GameObject;

            /**
             * Gets the first Game Object in this Container.
             * 
             * You can also specify a property and value to search for, in which case it will return the first
             * Game Object in this Container with a matching property and / or value.
             * 
             * For example: `getFirst('visible', true)` would return the first Game Object that had its `visible` property set.
             * 
             * You can limit the search to the `startIndex` - `endIndex` range.
             * @param property The property to test on each Game Object in the Container.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            getFirst(property?: string, value?: any, startIndex?: integer, endIndex?: integer): Phaser.GameObjects.GameObject;

            /**
             * Returns all Game Objects in this Container.
             * 
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             * 
             * For example: `getAll('body')` would return only Game Objects that have a body property.
             * 
             * You can also specify a value to compare the property to:
             * 
             * `getAll('visible', true)` would return only Game Objects that have their visible property set to `true`.
             * 
             * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 Game Objects.
             * @param property The property to test on each Game Object in the Container.
             * @param value If property is set then the `property` must strictly equal this value to be included in the results.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            getAll(property?: string, value?: any, startIndex?: integer, endIndex?: integer): Phaser.GameObjects.GameObject[];

            /**
             * Returns the total number of Game Objects in this Container that have a property
             * matching the given value.
             * 
             * For example: `count('visible', true)` would count all the elements that have their visible property set.
             * 
             * You can optionally limit the operation to the `startIndex` - `endIndex` range.
             * @param property [description]
             * @param value [description]
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            count(property: string, value: any, startIndex?: integer, endIndex?: integer): integer;

            /**
             * Swaps the position of two Game Objects in this Container.
             * Both Game Objects must belong to this Container.
             * @param child1 The first Game Object to swap.
             * @param child2 The second Game Object to swap.
             */
            swap(child1: Phaser.GameObjects.GameObject, child2: Phaser.GameObjects.GameObject): Phaser.GameObjects.Container;

            /**
             * Moves a Game Object to a new position within this Container.
             * 
             * The Game Object must already be a child of this Container.
             * 
             * The Game Object is removed from its old position and inserted into the new one.
             * Therefore the Container size does not change. Other children will change position accordingly.
             * @param child The Game Object to move.
             * @param index The new position of the Game Object in this Container.
             */
            moveTo(child: Phaser.GameObjects.GameObject, index: integer): Phaser.GameObjects.Container;

            /**
             * Removes the given Game Object, or array of Game Objects, from this Container.
             * 
             * The Game Objects must already be children of this Container.
             * 
             * You can also optionally call `destroy` on each Game Object that is removed from the Container.
             * @param child The Game Object, or array of Game Objects, to be removed from the Container.
             * @param destroyChild Optionally call `destroy` on each child successfully removed from this Container. Default false.
             */
            remove(child: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], destroyChild?: boolean): Phaser.GameObjects.Container;

            /**
             * Removes the Game Object at the given position in this Container.
             * 
             * You can also optionally call `destroy` on the Game Object, if one is found.
             * @param index The index of the Game Object to be removed.
             * @param destroyChild Optionally call `destroy` on the Game Object if successfully removed from this Container. Default false.
             */
            removeAt(index: integer, destroyChild?: boolean): Phaser.GameObjects.Container;

            /**
             * Removes the Game Objects between the given positions in this Container.
             * 
             * You can also optionally call `destroy` on each Game Object that is removed from the Container.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             * @param destroyChild Optionally call `destroy` on each Game Object successfully removed from this Container. Default false.
             */
            removeBetween(startIndex?: integer, endIndex?: integer, destroyChild?: boolean): Phaser.GameObjects.Container;

            /**
             * Removes all Game Objects from this Container.
             * 
             * You can also optionally call `destroy` on each Game Object that is removed from the Container.
             * @param destroyChild Optionally call `destroy` on each Game Object successfully removed from this Container. Default false.
             */
            removeAll(destroyChild?: boolean): Phaser.GameObjects.Container;

            /**
             * Brings the given Game Object to the top of this Container.
             * This will cause it to render on-top of any other objects in the Container.
             * @param child The Game Object to bring to the top of the Container.
             */
            bringToTop(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.Container;

            /**
             * Sends the given Game Object to the bottom of this Container.
             * This will cause it to render below any other objects in the Container.
             * @param child The Game Object to send to the bottom of the Container.
             */
            sendToBack(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.Container;

            /**
             * Moves the given Game Object up one place in this Container, unless it's already at the top.
             * @param child The Game Object to be moved in the Container.
             */
            moveUp(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.Container;

            /**
             * Moves the given Game Object down one place in this Container, unless it's already at the bottom.
             * @param child The Game Object to be moved in the Container.
             */
            moveDown(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.Container;

            /**
             * Reverses the order of all Game Objects in this Container.
             */
            reverse(): Phaser.GameObjects.Container;

            /**
             * Shuffles the all Game Objects in this Container using the Fisher-Yates implementation.
             */
            shuffle(): Phaser.GameObjects.Container;

            /**
             * Replaces a Game Object in this Container with the new Game Object.
             * The new Game Object cannot already be a child of this Container.
             * @param oldChild The Game Object in this Container that will be replaced.
             * @param newChild The Game Object to be added to this Container.
             * @param destroyChild Optionally call `destroy` on the Game Object if successfully removed from this Container. Default false.
             */
            replace(oldChild: Phaser.GameObjects.GameObject, newChild: Phaser.GameObjects.GameObject, destroyChild?: boolean): Phaser.GameObjects.Container;

            /**
             * Returns `true` if the given Game Object is a direct child of this Container.
             * 
             * This check does not scan nested Containers.
             * @param child The Game Object to check for within this Container.
             */
            exists(child: Phaser.GameObjects.GameObject): boolean;

            /**
             * Sets the property to the given value on all Game Objects in this Container.
             * 
             * Optionally you can specify a start and end index. For example if this Container had 100 Game Objects,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 Game Objects.
             * @param property The property that must exist on the Game Object.
             * @param value The value to get the property to.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default Container.length.
             */
            setAll(property: string, value: any, startIndex?: integer, endIndex?: integer): Phaser.GameObjects.Container;

            /**
             * Passes all Game Objects in this Container to the given callback.
             * 
             * A copy of the Container is made before passing each entry to your callback.
             * This protects against the callback itself modifying the Container.
             * 
             * If you know for sure that the callback will not change the size of this Container
             * then you can use the more performant `Container.iterate` method instead.
             * @param callback The function to call.
             * @param context Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            each(callback: Function, context?: object, ...args: any[]): Phaser.GameObjects.Container;

            /**
             * Passes all Game Objects in this Container to the given callback.
             * 
             * Only use this method when you absolutely know that the Container will not be modified during
             * the iteration, i.e. by removing or adding to its contents.
             * @param callback The function to call.
             * @param context Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            iterate(callback: Function, context?: object, ...args: any[]): Phaser.GameObjects.Container;

            /**
             * The number of Game Objects inside this Container.
             */
            length: integer;

            /**
             * Returns the first Game Object within the Container, or `null` if it is empty.
             * 
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            first: Phaser.GameObjects.GameObject;

            /**
             * Returns the last Game Object within the Container, or `null` if it is empty.
             * 
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            last: Phaser.GameObjects.GameObject;

            /**
             * Returns the next Game Object within the Container, or `null` if it is empty.
             * 
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            next: Phaser.GameObjects.GameObject;

            /**
             * Returns the previous Game Object within the Container, or `null` if it is empty.
             * 
             * You can move the cursor by calling `Container.next` and `Container.previous`.
             */
            previous: Phaser.GameObjects.GameObject;

            /**
             * Destroys this Container, removing it from the Display List.
             * 
             * If `Container.exclusive` is `true` then it will also destroy all children.
             * 
             * Use this to remove a Container from your game if you don't ever plan to use it again.
             * As long as no reference to it exists within your own code it should become free for
             * garbage collection.
             * 
             * If you just want to temporarily disable an object then look at using the
             * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
             */
            destroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * [description]
         */
        class DisplayList extends Phaser.Structs.List<Phaser.GameObjects.GameObject> {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * [description]
             */
            sortChildrenFlag: boolean;

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * Force a sort of the display list on the next call to depthSort.
             */
            queueDepthSort(): void;

            /**
             * Immediately sorts the display list if the flag is set.
             */
            depthSort(): void;

            /**
             * [description]
             * @param childA [description]
             * @param childB [description]
             */
            sortByDepth(childA: Phaser.GameObjects.GameObject, childB: Phaser.GameObjects.GameObject): integer;

            /**
             * Given an array of Game Objects, sort the array and return it,
             * so that the objects are in index order with the lowest at the bottom.
             * @param gameObjects [description]
             */
            sortGameObjects(gameObjects: Phaser.GameObjects.GameObject[]): any[];

            /**
             * Note that the given array is sorted in place, even though it isn't returned directly it will still be updated.
             * @param gameObjects [description]
             */
            getTopGameObject(gameObjects: Phaser.GameObjects.GameObject[]): Phaser.GameObjects.GameObject;

        }

        /**
         * The base class that all Game Objects extend.
         * 
         * You don't create GameObjects directly and they cannot be added to the display list.
         * 
         * Instead, use them as the base for your own custom classes.
         */
        class GameObject extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs.
             * @param type A textual representation of the type of Game Object, i.e. `sprite`.
             */
            constructor(scene: Phaser.Scene, type: string);

            /**
             * The Scene to which this Game Object belongs.
             * Game Objects can only belong to one Scene.
             */
            protected scene: Phaser.Scene;

            /**
             * A textual representation of this Game Object, i.e. `sprite`.
             * Used internally by Phaser but is available for your own custom classes to populate.
             */
            type: string;

            /**
             * The parent Container of this Game Object, if it has one.
             */
            parentContainer: Phaser.GameObjects.Container;

            /**
             * The name of this Game Object.
             * Empty by default and never populated by Phaser, this is left for developers to use.
             */
            name: string;

            /**
             * The active state of this Game Object.
             * A Game Object with an active state of `true` is processed by the Scenes UpdateList, if added to it.
             * An active object is one which is having its logic and internal systems updated.
             */
            active: boolean;

            /**
             * The Tab Index of the Game Object.
             * Reserved for future use by plugins and the Input Manager.
             */
            tabIndex: integer;

            /**
             * A Data Manager.
             * It allows you to store, query and get key/value paired information specific to this Game Object.
             * `null` by default. Automatically created if you use `getData` or `setData` or `setDataEnabled`.
             */
            data: Phaser.Data.DataManager;

            /**
             * The flags that are compared against `RENDER_MASK` to determine if this Game Object will render or not.
             * The bits are 0001 | 0010 | 0100 | 1000 set by the components Visible, Alpha, Transform and Texture respectively.
             * If those components are not used by your custom class then you can use this bitmask as you wish.
             */
            renderFlags: integer;

            /**
             * A bitmask that controls if this Game Object is drawn by a Camera or not.
             * Not usually set directly. Instead call `Camera.ignore`.
             */
            cameraFilter: number;

            /**
             * If this Game Object is enabled for input then this property will contain an InteractiveObject instance.
             * Not usually set directly. Instead call `GameObject.setInteractive()`.
             */
            input: Phaser.Input.InteractiveObject;

            /**
             * If this Game Object is enabled for physics then this property will contain a reference to a Physics Body.
             */
            body: any;

            /**
             * This Game Object will ignore all calls made to its destroy method if this flag is set to `true`.
             * This includes calls that may come from a Group, Container or the Scene itself.
             * While it allows you to persist a Game Object across Scenes, please understand you are entirely
             * responsible for managing references to and from this Game Object.
             */
            ignoreDestroy: boolean;

            /**
             * Sets the `active` property of this Game Object and returns this Game Object for further chaining.
             * A Game Object with its `active` property set to `true` will be updated by the Scenes UpdateList.
             * @param value True if this Game Object should be set as active, false if not.
             */
            setActive(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the `name` property of this Game Object and returns this Game Object for further chaining.
             * The `name` property is not populated by Phaser and is presented for your own use.
             * @param value The name to be given to this Game Object.
             */
            setName(value: string): Phaser.GameObjects.GameObject;

            /**
             * Adds a DataManager to this object.
             */
            setDataEnabled(): Phaser.GameObjects.GameObject;

            /**
             * This is a quick chainable alias to the `DataProxy.set` method.
             * It allows you to set a key and value in this Game Objects data store.
             * @param key The key of the property to be stored.
             * @param value The value to store with the key. Can be a string, number, array or object.
             */
            setData(key: string, value: any): Phaser.GameObjects.GameObject;

            /**
             * This is a quick alias to the `DataProxy.get` method to remain consistent with `setData`.
             * @param key The key of the property to be retrieved.
             */
            getData(key: string): any;

            /**
             * Pass this Game Object to the Input Manager to enable it for Input.
             * @param shape A geometric shape that defines the hit area for the Game Object. If not specified a Rectangle will be used.
             * @param callback A callback to be invoked when the Game Object is interacted with.
             * @param dropZone Should this Game Object be treated as a drop zone target? Default false.
             */
            setInteractive(shape?: any, callback?: HitAreaCallback, dropZone?: boolean): Phaser.GameObjects.GameObject;

            /**
             * To be overridden by custom GameObjects. Allows base objects to be used in a Pool.
             */
            update(): void;

            /**
             * Returns a JSON representation of the Game Object.
             */
            toJSON(): JSONGameObject;

            /**
             * Compares the renderMask with the renderFlags to see if this Game Object will render or not.
             */
            willRender(): boolean;

            /**
             * Returns an array containing the display list index of either this Game Object, or if it has one,
             * its parent Container. It then iterates up through all of the parent containers until it hits the
             * root of the display list (which is index 0 in the returned array).
             * 
             * Used internally by the InputPlugin but also useful if you wish to find out the display depth of
             * this Game Object and all of its ancestors.
             */
            getIndexList(): integer[];

            /**
             * Destroys this Game Object removing it from the Display List and Update List and
             * severing all ties to parent resources.
             * 
             * Also removes itself from the Input Manager and Physics Manager if previously enabled.
             * 
             * Use this to remove a Game Object from your game if you don't ever plan to use it again.
             * As long as no reference to it exists within your own code it should become free for
             * garbage collection by the browser.
             * 
             * If you just want to temporarily disable an object then look at using the
             * Game Object Pool instead of destroying it, as destroyed objects cannot be resurrected.
             */
            destroy(): void;

            /**
             * The bitmask that `GameObject.renderFlags` is compared against to determine if the Game Object will render or not.
             */
            static readonly RENDER_MASK: integer;

        }

        /**
         * The Game Object Creator is a Scene plugin that allows you to quickly create many common
         * 
         * types of Game Objects and return them. Unlike the Game Object Factory, they are not automatically
         * 
         * added to the Scene.
         * 
         * 
         * 
         * Game Objects directly register themselves with the Creator and inject their own creation
         * 
         * methods into the class.
         */
        class GameObjectCreator {
            /**
             * 
             * @param scene The Scene to which this Game Object Factory belongs.
             */
            constructor(scene: Phaser.Scene);

            /**
             * Creates a new Dynamic Bitmap Text Game Object and returns it.
             * 
             * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
             * @param config [description]
             */
            dynamicBitmapText(config: BitmapTextConfig): Phaser.GameObjects.DynamicBitmapText;

            /**
             * Creates a new Bitmap Text Game Object and returns it.
             * 
             * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
             * @param config [description]
             */
            bitmapText(config: BitmapTextConfig): Phaser.GameObjects.BitmapText;

            /**
             * Creates a new Blitter Game Object and returns it.
             * 
             * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
             * @param config [description]
             */
            blitter(config: object): Phaser.GameObjects.Blitter;

            /**
             * Creates a new Container Game Object and returns it.
             * 
             * Note: This method will only be available if the Container Game Object has been built into Phaser.
             * @param config [description]
             */
            container(config: object): Phaser.GameObjects.Container;

            /**
             * The Scene to which this Game Object Creator belongs.
             */
            protected scene: Phaser.Scene;

            /**
             * A reference to the Scene.Systems.
             */
            protected systems: Phaser.Scenes.Systems;

            /**
             * A reference to the Scene Display List.
             */
            protected displayList: Phaser.GameObjects.DisplayList;

            /**
             * A reference to the Scene Update List.
             */
            protected "updateList;": Phaser.GameObjects.UpdateList;

            /**
             * Creates a new Graphics Game Object and returns it.
             * 
             * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
             * @param config [description]
             */
            graphics(config?: object): Phaser.GameObjects.Graphics;

            /**
             * Creates a new Group Game Object and returns it.
             * 
             * Note: This method will only be available if the Group Game Object has been built into Phaser.
             * @param config [description]
             */
            group(config: GroupConfig): Phaser.GameObjects.Group;

            /**
             * Creates a new Image Game Object and returns it.
             * 
             * Note: This method will only be available if the Image Game Object has been built into Phaser.
             * @param config [description]
             */
            image(config: object): Phaser.GameObjects.Image;

            /**
             * Creates a new Mesh Game Object and returns it.
             * 
             * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
             * @param config [description]
             */
            mesh(config: object): Phaser.GameObjects.Mesh;

            /**
             * Creates a new Particle Emitter Manager Game Object and returns it.
             * 
             * Note: This method will only be available if the Particles Game Object has been built into Phaser.
             * @param config [description]
             */
            particles(config: object): Phaser.GameObjects.Particles.ParticleEmitterManager;

            /**
             * Creates a new Quad Game Object and returns it.
             * 
             * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.
             * @param config [description]
             */
            quad(config: object): Phaser.GameObjects.Quad;

            /**
             * Creates a new Render Texture Game Object and returns it.
             * 
             * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
             * @param config [description]
             */
            renderTexture(config: RenderTextureConfig): Phaser.GameObjects.RenderTexture;

            /**
             * Creates a new Sprite Game Object and returns it.
             * 
             * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
             * @param config [description]
             */
            sprite(config: object): Phaser.GameObjects.Sprite;

            /**
             * Creates a new Sprite3D Game Object and returns it.
             * 
             * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.
             * @param config [description]
             */
            sprite3D(config: object): Phaser.GameObjects.Sprite3D;

            /**
             * Creates a new Text Game Object and returns it.
             * 
             * Note: This method will only be available if the Text Game Object has been built into Phaser.
             * @param config [description]
             */
            text(config: object): Phaser.GameObjects.Text;

            /**
             * Creates a new TileSprite Game Object and returns it.
             * 
             * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
             * @param config [description]
             */
            tileSprite(config: TileSprite): Phaser.GameObjects.TileSprite;

            /**
             * Creates a new Zone Game Object and returns it.
             * 
             * Note: This method will only be available if the Zone Game Object has been built into Phaser.
             * @param config [description]
             */
            zone(config: object): Phaser.GameObjects.Zone;

            /**
             * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
             * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
             * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
             * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
             * @param config The config options for the Tilemap.
             */
            tilemap(config?: TilemapConfig): Phaser.Tilemaps.Tilemap;

            /**
             * Creates a new Tween object and returns it.
             * 
             * Note: This method will only be available if Tweens have been built into Phaser.
             * @param config The Tween configuration.
             */
            tween(config: object): Phaser.Tweens.Tween;

        }

        /**
         * The Game Object Factory is a Scene plugin that allows you to quickly create many common
         * 
         * types of Game Objects and have them automatically registered with the Scene.
         * 
         * 
         * 
         * Game Objects directly register themselves with the Factory and inject their own creation
         * 
         * methods into the class.
         */
        class GameObjectFactory {
            /**
             * 
             * @param scene The Scene to which this Game Object Factory belongs.
             */
            constructor(scene: Phaser.Scene);

            /**
             * Creates a new Path Object.
             * @param x The horizontal position of this Path.
             * @param y The vertical position of this Path.
             */
            path(x: number, y: number): Phaser.Curves.Path;

            /**
             * Creates a new Dynamic Bitmap Text Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Dynamic Bitmap Text Game Object has been built into Phaser.
             * @param x The x position of the Game Object.
             * @param y The y position of the Game Object.
             * @param font [description]
             * @param text [description]
             * @param size [description]
             */
            dynamicBitmapText(x: number, y: number, font: string, text?: string | string[], size?: number): Phaser.GameObjects.DynamicBitmapText;

            /**
             * Creates a new Bitmap Text Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Bitmap Text Game Object has been built into Phaser.
             * @param x The x position of the Game Object.
             * @param y The y position of the Game Object.
             * @param font [description]
             * @param text [description]
             * @param size [description]
             */
            bitmapText(x: number, y: number, font: string, text?: string | string[], size?: number): Phaser.GameObjects.BitmapText;

            /**
             * Creates a new Blitter Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Blitter Game Object has been built into Phaser.
             * @param x The x position of the Game Object.
             * @param y The y position of the Game Object.
             * @param key The key of the Texture the Blitter object will use.
             * @param frame The default Frame children of the Blitter will use.
             */
            blitter(x: number, y: number, key: string, frame?: string | integer): Phaser.GameObjects.Blitter;

            /**
             * Creates a new Container Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Container Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param children An optional array of Game Objects to add to this Container.
             */
            container(x: number, y: number, children?: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): Phaser.GameObjects.Container;

            /**
             * The Scene to which this Game Object Factory belongs.
             */
            protected scene: Phaser.Scene;

            /**
             * A reference to the Scene.Systems.
             */
            protected systems: Phaser.Scenes.Systems;

            /**
             * A reference to the Scene Display List.
             */
            protected displayList: Phaser.GameObjects.DisplayList;

            /**
             * A reference to the Scene Update List.
             */
            protected "updateList;": Phaser.GameObjects.UpdateList;

            /**
             * Adds an existing Game Object to this Scene.
             * 
             * If the Game Object renders, it will be added to the Display List.
             * If it has a `preUpdate` method, it will be added to the Update List.
             * @param child The child to be added to this Scene.
             */
            existing(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.GameObject;

            /**
             * Creates a new Graphics Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Graphics Game Object has been built into Phaser.
             * @param config [description]
             */
            graphics(config?: object): Phaser.GameObjects.Graphics;

            /**
             * Creates a new Group Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Group Game Object has been built into Phaser.
             * @param children [description]
             * @param config [description]
             */
            group(children: Phaser.GameObjects.GameObject[] | GroupConfig, config?: GroupConfig): Phaser.GameObjects.Group;

            /**
             * Creates a new Image Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Image Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            image(x: number, y: number, texture: string, frame?: string | integer): Phaser.GameObjects.Image;

            /**
             * Creates a new Mesh Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Mesh Game Object and WebGL support have been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param vertices An array containing the vertices data for this Mesh.
             * @param uv An array containing the uv data for this Mesh.
             * @param colors An array containing the color data for this Mesh.
             * @param alphas An array containing the alpha data for this Mesh.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            mesh(x: number, y: number, vertices: number[], uv: number[], colors: number[], alphas: number[], texture: string, frame?: string | integer): Phaser.GameObjects.Mesh;

            /**
             * Creates a new Particle Emitter Manager Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Particles Game Object has been built into Phaser.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame [description]
             * @param emitters [description]
             */
            particles(texture: string, frame?: string | integer | object, emitters?: object): Phaser.GameObjects.Particles.ParticleEmitterManager;

            /**
             * Creates a new PathFollower Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the PathFollower Game Object has been built into Phaser.
             * @param path The Path this PathFollower is connected to.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            follower(path: Phaser.Curves.Path, x: number, y: number, texture: string, frame?: string | integer): Phaser.GameObjects.PathFollower;

            /**
             * Creates a new Quad Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Quad Game Object and WebGL support have been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            quad(x: number, y: number, texture: string, frame?: string | integer): Phaser.GameObjects.Quad;

            /**
             * Creates a new Render Texture Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Render Texture Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Render Texture. Default 32.
             * @param height The height of the Render Texture. Default 32.
             */
            renderTexture(x: number, y: number, width?: integer, height?: integer): Phaser.GameObjects.RenderTexture;

            /**
             * Creates a new Sprite Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Sprite Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            sprite(x: number, y: number, texture: string, frame?: string | integer): Phaser.GameObjects.Sprite;

            /**
             * Creates a new Sprite3D Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Sprite3D Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object.
             * @param y The vertical position of this Game Object.
             * @param z The z position of this Game Object.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            sprite3D(x: number, y: number, z: number, texture: string, frame?: string | integer): Phaser.GameObjects.Sprite3D;

            /**
             * Creates a new Text Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Text Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param text The text this Text object will display.
             * @param style The Text style configuration object.
             */
            text(x: number, y: number, text: string | string[], style?: object): Phaser.GameObjects.Text;

            /**
             * Creates a new TileSprite Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the TileSprite Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object.
             * @param height The height of the Game Object.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            tileSprite(x: number, y: number, width: number, height: number, texture: string, frame?: string | integer): Phaser.GameObjects.TileSprite;

            /**
             * Creates a new Zone Game Object and adds it to the Scene.
             * 
             * Note: This method will only be available if the Zone Game Object has been built into Phaser.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object.
             * @param height The height of the Game Object.
             */
            zone(x: number, y: number, width: number, height: number): Phaser.GameObjects.Zone;

            /**
             * Creates a Tilemap from the given key or data, or creates a blank Tilemap if no key/data provided.
             * When loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing
             * from a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map
             * data. For an empty map, you should specify tileWidth, tileHeight, width & height.
             * @param key The key in the Phaser cache that corresponds to the loaded tilemap data.
             * @param tileWidth The width of a tile in pixels. Pass in `null` to leave as the
             * default. Default 32.
             * @param tileHeight The height of a tile in pixels. Pass in `null` to leave as the
             * default. Default 32.
             * @param width The width of the map in tiles. Pass in `null` to leave as the
             * default. Default 10.
             * @param height The height of the map in tiles. Pass in `null` to leave as the
             * default. Default 10.
             * @param data Instead of loading from the cache, you can also load directly from
             * a 2D array of tile indexes. Pass in `null` for no data.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the
             * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set. Default false.
             */
            tilemap(key?: string, tileWidth?: integer, tileHeight?: integer, width?: integer, height?: integer, data?: integer[][], insertNull?: boolean): Phaser.Tilemaps.Tilemap;

            /**
             * Creates a new Tween object.
             * 
             * Note: This method will only be available Tweens have been built into Phaser.
             * @param config The Tween configuration.
             */
            tween(config: object): Phaser.Tweens.Tween;

        }

        /**
         * [description]
         */
        class Graphics extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible, Phaser.GameObjects.Components.ScrollFactor {
            /**
             * 
             * @param scene [description]
             * @param options [description]
             */
            constructor(scene: Phaser.Scene, options: object);

            /**
             * [description]
             */
            displayOriginX: number;

            /**
             * [description]
             */
            displayOriginY: number;

            /**
             * [description]
             */
            commandBuffer: any[];

            /**
             * [description]
             */
            defaultFillColor: number;

            /**
             * [description]
             */
            defaultFillAlpha: number;

            /**
             * [description]
             */
            defaultStrokeWidth: number;

            /**
             * [description]
             */
            defaultStrokeColor: number;

            /**
             * [description]
             */
            defaultStrokeAlpha: number;

            /**
             * [description]
             * @param options [description]
             */
            setDefaultStyles(options: object): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param lineWidth [description]
             * @param color [description]
             * @param alpha [description] Default 1.
             */
            lineStyle(lineWidth: number, color: number, alpha?: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param color [description]
             * @param alpha [description] Default 1.
             */
            fillStyle(color: number, alpha?: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            beginPath(): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            closePath(): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            fillPath(): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            strokePath(): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param circle [description]
             */
            fillCircleShape(circle: Phaser.Geom.Circle): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param circle [description]
             */
            strokeCircleShape(circle: Phaser.Geom.Circle): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param radius [description]
             */
            fillCircle(x: number, y: number, radius: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param radius [description]
             */
            strokeCircle(x: number, y: number, radius: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param rect [description]
             */
            fillRectShape(rect: Phaser.Geom.Rectangle): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param rect [description]
             */
            strokeRectShape(rect: Phaser.Geom.Rectangle): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param height [description]
             */
            fillRect(x: number, y: number, width: number, height: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param height [description]
             */
            strokeRect(x: number, y: number, width: number, height: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param point [description]
             * @param size [description] Default 1.
             */
            fillPointShape(point: Phaser.Geom.Point | Phaser.Math.Vector2 | object, size?: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param size [description] Default 1.
             */
            fillPoint(x: number, y: number, size?: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param triangle [description]
             */
            fillTriangleShape(triangle: Phaser.Geom.Triangle): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param triangle [description]
             */
            strokeTriangleShape(triangle: Phaser.Geom.Triangle): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x0 [description]
             * @param y0 [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            fillTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x0 [description]
             * @param y0 [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            strokeTriangle(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param line [description]
             */
            strokeLineShape(line: Phaser.Geom.Line): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            lineBetween(x1: number, y1: number, x2: number, y2: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            lineTo(x: number, y: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            moveTo(x: number, y: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param rgb [description]
             */
            lineFxTo(x: number, y: number, width: number, rgb: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param rgb [description]
             */
            moveFxTo(x: number, y: number, width: number, rgb: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param points [description]
             * @param autoClose [description] Default false.
             * @param endIndex [description]
             */
            strokePoints(points: any[] | Phaser.Geom.Point[], autoClose?: boolean, endIndex?: integer): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param points [description]
             * @param autoClose [description] Default false.
             * @param endIndex [description]
             */
            fillPoints(points: any[] | Phaser.Geom.Point[], autoClose?: boolean, endIndex?: integer): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param ellipse [description]
             * @param smoothness [description] Default 32.
             */
            strokeEllipseShape(ellipse: Phaser.Geom.Ellipse, smoothness?: integer): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param height [description]
             * @param smoothness [description] Default 32.
             */
            strokeEllipse(x: number, y: number, width: number, height: number, smoothness?: integer): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param ellipse [description]
             * @param smoothness [description] Default 32.
             */
            fillEllipseShape(ellipse: Phaser.Geom.Ellipse, smoothness?: integer): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param height [description]
             * @param smoothness [description] Default 32.
             */
            fillEllipse(x: number, y: number, width: number, height: number, smoothness?: integer): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param radius [description]
             * @param startAngle [description]
             * @param endAngle [description]
             * @param anticlockwise [description]
             */
            arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise: boolean): Phaser.GameObjects.Graphics;

            /**
             * Creates a pie-chart slice shape centered at `x`, `y` with the given radius.
             * You must define the start and end angle of the slice.
             * 
             * Setting the `anticlockwise` argument to `true` creates a shape similar to Pacman.
             * Setting it to `false` creates a shape like a slice of pie.
             * 
             * This method will begin a new path and close the path at the end of it.
             * To display the actual slice you need to call either `strokePath` or `fillPath` after it.
             * @param x The horizontal center of the slice.
             * @param y The vertical center of the slice.
             * @param radius The radius of the slice.
             * @param startAngle The start angle of the slice, given in radians.
             * @param endAngle The end angle of the slice, given in radians.
             * @param anticlockwise Draw the slice piece anticlockwise or clockwise? Default false.
             */
            slice(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            save(): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            restore(): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            translate(x: number, y: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            scale(x: number, y: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             * @param radians [description]
             */
            rotate(radians: number): Phaser.GameObjects.Graphics;

            /**
             * [description]
             */
            clear(): Phaser.GameObjects.Graphics;

            /**
             * If key is a string it'll generate a new texture using it and add it into the
             * Texture Manager (assuming no key conflict happens).
             * 
             * If key is a Canvas it will draw the texture to that canvas context. Note that it will NOT
             * automatically upload it to the GPU in WebGL mode.
             * @param key [description]
             * @param width [description]
             * @param height [description]
             */
            generateTexture(key: string | HTMLCanvasElement, width?: integer, height?: integer): Phaser.GameObjects.Graphics;

            /**
             * A Camera used specifically by the Graphics system for rendering to textures.
             */
            static TargetCamera: Phaser.Cameras.Scene2D.Camera;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

        }

        /**
         * A Group is a way for you to create, manipulate, or recycle similar Game Objects.
         * 
         * 
         * 
         * Group membership is non-exclusive. A Game Object can belong to several groups, one group, or none.
         * 
         * 
         * 
         * Groups themselves aren't displayable, and can't be positioned, rotated, scaled, or hidden.
         */
        class Group {
            /**
             * 
             * @param scene The scene this group belongs to.
             * @param children Game objects to add to this group; or the `config` argument.
             * @param config Settings for this group. If `key` is set, Phaser.GameObjects.Group#createMultiple is also called with these settings.
             */
            constructor(scene: Phaser.Scene, children?: Phaser.GameObjects.GameObject[] | GroupConfig, config?: GroupConfig | GroupCreateConfig);

            /**
             * This scene this group belongs to.
             */
            scene: Phaser.Scene;

            /**
             * Members of this group.
             */
            children: Phaser.Structs.Set<Phaser.GameObjects.GameObject>;

            /**
             * A flag identifying this object as a group.
             */
            isParent: boolean;

            /**
             * The class to create new group members from.
             */
            classType: object;

            /**
             * Whether this group runs its {@link Phaser.GameObjects.Group#preUpdate} method
             * (which may update any members).
             */
            active: boolean;

            /**
             * The maximum size of this group, if used as a pool. -1 is no limit.
             */
            maxSize: integer;

            /**
             * A default texture key to use when creating new group members.
             * 
             * This is used in {@link Phaser.GameObjects.Group#create}
             * but not in {@link Phaser.GameObjects.Group#createMultiple}.
             */
            defaultKey: string;

            /**
             * A default texture frame to use when creating new group members.
             */
            defaultFrame: string | integer;

            /**
             * Whether to call the update method of any members.
             */
            runChildUpdate: boolean;

            /**
             * A function to be called when adding or creating group members.
             */
            createCallback: GroupCallback;

            /**
             * A function to be called when removing group members.
             */
            removeCallback: GroupCallback;

            /**
             * A function to be called when creating several group members at once.
             */
            createMultipleCallback: GroupMultipleCreateCallback;

            /**
             * Creates a new Game Object and adds it to this group, unless the group {@link Phaser.GameObjects.Group#isFull is full}.
             * 
             * Calls {@link Phaser.GameObjects.Group#createCallback}.
             * @param x The horizontal position of the new Game Object in the world. Default 0.
             * @param y The vertical position of the new Game Object in the world. Default 0.
             * @param key The texture key of the new Game Object. Default defaultKey.
             * @param frame The texture frame of the new Game Object. Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of the new Game Object. Default true.
             * @param active The {@link Phaser.GameObjects.GameObject#active} state of the new Game Object. Default true.
             */
            create(x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean, active?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Creates several Game Objects and adds them to this group.
             * 
             * If the group becomes {@link Phaser.GameObjects.Group#isFull}, no further Game Objects are created.
             * 
             * Calls {@link Phaser.GameObjects.Group#createMultipleCallback}
             * and {@link Phaser.GameObjects.Group#createCallback}.
             * @param config Creation settings. This can be a single configuration object or an array of such objects, which will be applied in turn.
             */
            createMultiple(config: GroupCreateConfig | GroupCreateConfig[]): Phaser.GameObjects.GameObject[];

            /**
             * A helper for {@link Phaser.GameObjects.Group#createMultiple}.
             * @param options Creation settings.
             */
            createFromConfig(options: GroupCreateConfig): Phaser.GameObjects.GameObject[];

            /**
             * Updates any group members, if {@link Phaser.GameObjects.Group#runChildUpdate} is enabled.
             * @param time The current timestamp.
             * @param delta The delta time elapsed since the last frame.
             */
            preUpdate(time: number, delta: number): void;

            /**
             * Adds a Game Object to this group.
             * 
             * Calls {@link Phaser.GameObjects.Group#createCallback}.
             * @param child The Game Object to add.
             * @param addToScene Also add the Game Object to the scene. Default false.
             */
            add(child: Phaser.GameObjects.GameObject, addToScene?: boolean): Phaser.GameObjects.Group;

            /**
             * Adds several Game Objects to this group.
             * 
             * Calls {@link Phaser.GameObjects.Group#createCallback}.
             * @param children The Game Objects to add.
             * @param addToScene Also add the Game Objects to the scene. Default false.
             */
            addMultiple(children: Phaser.GameObjects.GameObject[], addToScene?: boolean): Phaser.GameObjects.Group;

            /**
             * Removes a member of this Group and optionally removes it from the Scene and / or destroys it.
             * 
             * Calls {@link Phaser.GameObjects.Group#removeCallback}.
             * @param child The Game Object to remove.
             * @param removeFromScene Optionally remove the Group member from the Scene it belongs to. Default false.
             * @param destroyChild Optionally call destroy on the removed Group member. Default false.
             */
            remove(child: Phaser.GameObjects.GameObject, removeFromScene?: boolean, destroyChild?: boolean): Phaser.GameObjects.Group;

            /**
             * Removes all members of this Group and optionally removes them from the Scene and / or destroys them.
             * 
             * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
             * @param removeFromScene Optionally remove each Group member from the Scene. Default false.
             * @param destroyChild Optionally call destroy on the removed Group members. Default false.
             */
            clear(removeFromScene?: boolean, destroyChild?: boolean): Phaser.GameObjects.Group;

            /**
             * Tests if a Game Object is a member of this group.
             * @param child A Game Object.
             */
            contains(child: Phaser.GameObjects.GameObject): boolean;

            /**
             * All members of the group.
             */
            getChildren(): Phaser.GameObjects.GameObject[];

            /**
             * The number of members of the group.
             */
            getLength(): integer;

            /**
             * Scans the Group, from top to bottom, for the first member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirst(state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Scans the Group, from top to bottom, for the nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param nth The nth matching Group member to search for.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirstNth(nth: integer, state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Scans the Group for the last member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getLast(state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Scans the Group for the last nth member that has an {@link Phaser.GameObjects.GameObject#active} state matching the argument,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no matching member is found and `createIfNull` is true and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param nth The nth matching Group member to search for.
             * @param state The {@link Phaser.GameObjects.GameObject#active} value to match. Default false.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getLastNth(nth: integer, state?: boolean, createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no inactive member is found and the group isn't full then it will create a new Game Object using `x`, `y`, `key`, `frame`, and `visible`.
             * The new Game Object will have its active state set to `true`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            get(x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `true`,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no active member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirstAlive(createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Scans the group for the first member that has an {@link Phaser.GameObjects.GameObject#active} state set to `false`,
             * assigns `x` and `y`, and returns the member.
             * 
             * If no inactive member is found and `createIfNull` is `true` and the group isn't full then it will create a new one using `x`, `y`, `key`, `frame`, and `visible`.
             * The new Game Object will have an active state set to `true`.
             * Unless a new member is created, `key`, `frame`, and `visible` are ignored.
             * @param createIfNull Create a new Game Object if no matching members are found, using the following arguments. Default false.
             * @param x The horizontal position of the Game Object in the world.
             * @param y The vertical position of the Game Object in the world.
             * @param key The texture key assigned to a new Game Object (if one is created). Default defaultKey.
             * @param frame A texture frame assigned to a new Game Object (if one is created). Default defaultFrame.
             * @param visible The {@link Phaser.GameObjects.Components.Visible#visible} state of a new Game Object (if one is created). Default true.
             */
            getFirstDead(createIfNull?: boolean, x?: number, y?: number, key?: string, frame?: string | integer, visible?: boolean): Phaser.GameObjects.GameObject;

            /**
             * {@link Phaser.GameObjects.Components.Animation#play Plays} an animation for all members of this group.
             * @param key The string-based key of the animation to play.
             * @param startFrame Optionally start the animation playing from this frame index. Default 0.
             */
            playAnimation(key: string, startFrame?: string): Phaser.GameObjects.Group;

            /**
             * Whether this group's size at its {@link Phaser.GameObjects.Group#maxSize maximum}.
             */
            isFull(): boolean;

            /**
             * Counts the number of active (or inactive) group members.
             * @param value Count active (true) or inactive (false) group members. Default true.
             */
            countActive(value?: boolean): integer;

            /**
             * Counts the number of in-use (active) group members.
             */
            getTotalUsed(): integer;

            /**
             * The difference of {@link Phaser.GameObjects.Group#maxSize} and the number of active group members.
             * 
             * This represents the number of group members that could be created or reactivated before reaching the size limit.
             */
            getTotalFree(): integer;

            /**
             * Sets the depth of each group member.
             * @param value The amount to set the property to.
             * @param step This is added to the `value` amount, multiplied by the iteration counter.
             */
            setDepth(value: number, step: number): Phaser.GameObjects.Group;

            /**
             * Deactivates a member of this group.
             * @param gameObject A member of this group.
             */
            kill(gameObject: Phaser.GameObjects.GameObject): void;

            /**
             * Deactivates and hides a member of this group.
             * @param gameObject A member of this group.
             */
            killAndHide(gameObject: Phaser.GameObjects.GameObject): void;

            /**
             * Toggles (flips) the visible state of each member of this group.
             */
            toggleVisible(): Phaser.GameObjects.Group;

            /**
             * Empties this group and removes it from the scene.
             * 
             * Does not call {@link Phaser.GameObjects.Group#removeCallback}.
             * @param destroyChildren Also {@link Phaser.GameObjects.GameObject#destroy} each group member. Default false.
             */
            destroy(destroyChildren?: boolean): void;

        }

        /**
         * An Image Game Object.
         * 
         * 
         * 
         * An Image is a light-weight Game Object useful for the display of static images in your game,
         * 
         * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
         * 
         * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
         * 
         * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
         */
        class Image extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: Phaser.Geom.Rectangle): Phaser.Geom.Rectangle;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * [description]
         */
        class Light {
            /**
             * 
             * @param x The horizontal position of the light.
             * @param y The vertical position of the light.
             * @param radius The radius of the light.
             * @param r The red color. A value between 0 and 1.
             * @param g The green color. A value between 0 and 1.
             * @param b The blue color. A value between 0 and 1.
             * @param intensity The intensity of the light.
             */
            constructor(x: number, y: number, radius: number, r: number, g: number, b: number, intensity: number);

            /**
             * [description]
             */
            x: number;

            /**
             * [description]
             */
            y: number;

            /**
             * [description]
             */
            radius: number;

            /**
             * [description]
             */
            r: number;

            /**
             * [description]
             */
            g: number;

            /**
             * [description]
             */
            b: number;

            /**
             * [description]
             */
            intensity: number;

            /**
             * [description]
             */
            scrollFactorX: number;

            /**
             * [description]
             */
            scrollFactorY: number;

            /**
             * [description]
             * @param x The horizontal position of the light.
             * @param y The vertical position of the light.
             * @param radius The radius of the light.
             * @param r The red color. A value between 0 and 1.
             * @param g The green color. A value between 0 and 1.
             * @param b The blue color. A value between 0 and 1.
             * @param intensity The intensity of the light.
             */
            set(x: number, y: number, radius: number, r: number, g: number, b: number, intensity: number): Phaser.GameObjects.Light;

            /**
             * [description]
             * @param x The horizontal scroll factor of the light.
             * @param y The vertical scroll factor of the light.
             */
            setScrollFactor(x: number, y: number): Phaser.GameObjects.Light;

            /**
             * [description]
             * @param rgb [description]
             */
            setColor(rgb: number): Phaser.GameObjects.Light;

            /**
             * [description]
             * @param intensity [description]
             */
            setIntensity(intensity: number): Phaser.GameObjects.Light;

            /**
             * [description]
             * @param x The horizontal position of the light.
             * @param y The vertical position of the light.
             */
            setPosition(x: number, y: number): Phaser.GameObjects.Light;

            /**
             * [description]
             * @param radius [description]
             */
            setRadius(radius: number): Phaser.GameObjects.Light;

        }

        /**
         * [description]
         */
        class LightsManager {
            /**
             * [description]
             */
            lightPool: Phaser.GameObjects.Light[];

            /**
             * [description]
             */
            lights: Phaser.GameObjects.Light[];

            /**
             * [description]
             */
            culledLights: Phaser.GameObjects.Light[];

            /**
             * [description]
             */
            ambientColor: Object;

            /**
             * [description]
             */
            active: boolean;

            /**
             * [description]
             */
            enable(): Phaser.GameObjects.LightsManager;

            /**
             * [description]
             */
            disable(): Phaser.GameObjects.LightsManager;

            /**
             * [description]
             * @param camera [description]
             */
            cull(camera: Phaser.Cameras.Scene2D.Camera): Phaser.GameObjects.Light[];

            /**
             * [description]
             * @param callback [description]
             */
            forEachLight(callback: LightForEach): Phaser.GameObjects.LightsManager;

            /**
             * [description]
             * @param rgb [description]
             */
            setAmbientColor(rgb: number): Phaser.GameObjects.LightsManager;

            /**
             * Returns the maximum number of Lights allowed to appear at once.
             */
            getMaxVisibleLights(): integer;

            /**
             * [description]
             */
            getLightCount(): integer;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param radius [description]
             * @param rgb [description]
             * @param intensity [description]
             */
            addLight(x: number, y: number, radius: number, rgb: number, intensity: number): Phaser.GameObjects.Light;

            /**
             * [description]
             * @param light [description]
             */
            removeLight(light: Phaser.GameObjects.Light): Phaser.GameObjects.LightsManager;

            /**
             * [description]
             */
            shutdown(): void;

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * [description]
         */
        class LightsPlugin extends Phaser.GameObjects.LightsManager {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * [description]
             */
            boot(): void;

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * A Mesh Game Object.
         */
        class Mesh extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible, Phaser.GameObjects.Components.ScrollFactor {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param vertices An array containing the vertices data for this Mesh.
             * @param uv An array containing the uv data for this Mesh.
             * @param colors An array containing the color data for this Mesh.
             * @param alphas An array containing the alpha data for this Mesh.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, vertices: number[], uv: number[], colors: number[], alphas: number[], texture: string, frame?: string | integer);

            /**
             * [description]
             */
            vertices: Float32Array;

            /**
             * [description]
             */
            uv: Float32Array;

            /**
             * [description]
             */
            colors: Uint32Array;

            /**
             * [description]
             */
            alphas: Float32Array;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

        }

        namespace Particles {
            /**
             * [description]
             */
            class EmitterOp {
                /**
                 * 
                 * @param config [description]
                 * @param key [description]
                 * @param defaultValue [description]
                 * @param emitOnly [description] Default false.
                 */
                constructor(config: object, key: string, defaultValue: number, emitOnly?: boolean);

                /**
                 * [description]
                 */
                propertyKey: string;

                /**
                 * [description]
                 */
                propertyValue: number;

                /**
                 * [description]
                 */
                defaultValue: number;

                /**
                 * [description]
                 */
                steps: number;

                /**
                 * [description]
                 */
                counter: number;

                /**
                 * [description]
                 */
                start: number;

                /**
                 * [description]
                 */
                end: number;

                /**
                 * [description]
                 */
                ease: Function;

                /**
                 * [description]
                 */
                emitOnly: boolean;

                /**
                 * [description]
                 */
                onEmit: EmitterOpOnEmitCallback;

                /**
                 * [description]
                 */
                onUpdate: EmitterOpOnUpdateCallback;

                /**
                 * [description]
                 * @param config [description]
                 * @param newKey [description]
                 */
                loadConfig(config?: object, newKey?: string): void;

                /**
                 * [description]
                 */
                toJSON(): object;

                /**
                 * [description]
                 * @param value [description]
                 */
                onChange(value: number): Phaser.GameObjects.Particles.EmitterOp;

                /**
                 * [description]
                 */
                setMethods(): Phaser.GameObjects.Particles.EmitterOp;

                /**
                 * [description]
                 * @param object [description]
                 * @param key [description]
                 */
                has(object: object, key: string): boolean;

                /**
                 * [description]
                 * @param object [description]
                 * @param key1 [description]
                 * @param key2 [description]
                 */
                hasBoth(object: object, key1: string, key2: string): boolean;

                /**
                 * [description]
                 * @param object [description]
                 * @param key1 [description]
                 * @param key2 [description]
                 */
                hasEither(object: object, key1: string, key2: string): boolean;

                /**
                 * The returned value sets what the property will be at the START of the particles life, on emit.
                 * @param particle [description]
                 * @param key [description]
                 * @param value [description]
                 */
                defaultEmit(particle: Phaser.GameObjects.Particles.Particle, key: string, value: number): number;

                /**
                 * The returned value updates the property for the duration of the particles life.
                 * @param particle [description]
                 * @param key [description]
                 * @param t The T value (between 0 and 1)
                 * @param value [description]
                 */
                defaultUpdate(particle: Phaser.GameObjects.Particles.Particle, key: string, t: number, value: number): number;

                /**
                 * [description]
                 */
                staticValueEmit(): number;

                /**
                 * [description]
                 */
                staticValueUpdate(): number;

                /**
                 * [description]
                 */
                randomStaticValueEmit(): number;

                /**
                 * [description]
                 * @param particle [description]
                 * @param key [description]
                 */
                randomRangedValueEmit(particle: Phaser.GameObjects.Particles.Particle, key: string): number;

                /**
                 * [description]
                 */
                steppedEmit(): number;

                /**
                 * [description]
                 * @param particle [description]
                 * @param key [description]
                 */
                easedValueEmit(particle: Phaser.GameObjects.Particles.Particle, key: string): number;

                /**
                 * [description]
                 * @param particle [description]
                 * @param key [description]
                 * @param t The T value (between 0 and 1)
                 */
                easeValueUpdate(particle: Phaser.GameObjects.Particles.Particle, key: string, t: number): number;

            }

            /**
             * [description]
             */
            class GravityWell {
                /**
                 * 
                 * @param x The x coordinate of the Gravity Well, in world space. Default 0.
                 * @param y The y coordinate of the Gravity Well, in world space. Default 0.
                 * @param power The power of the Gravity Well. Default 0.
                 * @param epsilon [description] Default 100.
                 * @param gravity The gravitational force of this Gravity Well. Default 50.
                 */
                constructor(x?: number | GravityWellConfig, y?: number, power?: number, epsilon?: number, gravity?: number);

                /**
                 * The x coordinate of the Gravity Well, in world space.
                 */
                x: number;

                /**
                 * The y coordinate of the Gravity Well, in world space.
                 */
                y: number;

                /**
                 * The active state of the Gravity Well. An inactive Gravity Well will not influence any particles.
                 */
                active: boolean;

                /**
                 * The power of the Gravity Well.
                 */
                power: number;

                /**
                 * [description]
                 */
                epsilon: number;

                /**
                 * Takes a Particle and updates it based on the properties of this Gravity Well.
                 * @param particle The Particle to update.
                 * @param delta The delta time in ms.
                 * @param step The delta value divided by 1000.
                 */
                update(particle: Phaser.GameObjects.Particles.Particle, delta: number, step: number): void;

            }

            /**
             * [description]
             */
            class Particle {
                /**
                 * 
                 * @param emitter The Emitter to which this Particle belongs.
                 */
                constructor(emitter: Phaser.GameObjects.Particles.ParticleEmitter);

                /**
                 * The Emitter to which this Particle belongs.
                 * 
                 * A Particle can only belong to a single Emitter and is created, updated and destroyed via it.
                 */
                emitter: Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * [description]
                 */
                index: number;

                /**
                 * The x coordinate of this Particle.
                 */
                x: number;

                /**
                 * The y coordinate of this Particle.
                 */
                y: number;

                /**
                 * The x velocity of this Particle.
                 */
                velocityX: number;

                /**
                 * The y velocity of this Particle.
                 */
                velocityY: number;

                /**
                 * The x acceleration of this Particle.
                 */
                accelerationX: number;

                /**
                 * The y acceleration of this Particle.
                 */
                accelerationY: number;

                /**
                 * The maximum horizontal velocity this Particle can travel at.
                 */
                maxVelocityX: number;

                /**
                 * The maximum vertical velocity this Particle can travel at.
                 */
                maxVelocityY: number;

                /**
                 * The bounciness, or restitution, of this Particle.
                 */
                bounce: number;

                /**
                 * The horizontal scale of this Particle.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Particle.
                 */
                scaleY: number;

                /**
                 * The alpha value of this Particle.
                 */
                alpha: number;

                /**
                 * The angle of this Particle in degrees.
                 */
                angle: number;

                /**
                 * The angle of this Particle in radians.
                 */
                rotation: number;

                /**
                 * The tint applied to this Particle.
                 */
                tint: number;

                /**
                 * [description]
                 */
                color: number;

                /**
                 * The lifespan of this Particle in ms.
                 */
                life: number;

                /**
                 * The current life of this Particle in ms.
                 */
                lifeCurrent: number;

                /**
                 * The delay applied to this Particle upon emission, in ms.
                 */
                delayCurrent: number;

                /**
                 * The normalized lifespan T value.
                 */
                lifeT: number;

                /**
                 * The data used by the ease equation.
                 */
                data: object;

                /**
                 * Checks to see if this Particle is alive and updating.
                 */
                isAlive(): boolean;

                /**
                 * Starts this Particle from the given coordinates.
                 * @param x The x coordinate to launch this Particle from.
                 * @param y The y coordinate to launch this Particle from.
                 */
                fire(x: number, y: number): void;

                /**
                 * An internal method that calculates the velocity of the Particle.
                 * @param emitter The Emitter that is updating this Particle.
                 * @param delta The delta time in ms.
                 * @param step The delta value divided by 1000.
                 * @param processors [description]
                 */
                computeVelocity(emitter: Phaser.GameObjects.Particles.ParticleEmitter, delta: number, step: number, processors: any[]): void;

                /**
                 * Checks if this Particle is still within the bounds defined by the given Emitter.
                 * 
                 * If not, and depending on the Emitter collision flags, the Particle may either stop or rebound.
                 * @param emitter The Emitter to check the bounds against.
                 */
                checkBounds(emitter: Phaser.GameObjects.Particles.ParticleEmitter): void;

                /**
                 * The main update method for this Particle.
                 * 
                 * Updates its life values, computes the velocity and repositions the Particle.
                 * @param delta The delta time in ms.
                 * @param step The delta value divided by 1000.
                 * @param processors An optional array of update processors.
                 */
                update(delta: number, step: number, processors: any[]): boolean;

            }

            /**
             * [description]
             */
            class ParticleEmitter implements Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param manager The Emitter Manager this Emitter belongs to.
                 * @param config [description]
                 */
                constructor(manager: Phaser.GameObjects.Particles.ParticleEmitterManager, config: object);

                /**
                 * The Emitter Manager this Emitter belongs to.
                 */
                manager: Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * [description]
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * [description]
                 */
                frames: Phaser.Textures.Frame[];

                /**
                 * [description]
                 */
                defaultFrame: Phaser.Textures.Frame;

                /**
                 * [description]
                 */
                configFastMap: object;

                /**
                 * [description]
                 */
                configOpMap: object;

                /**
                 * The name of this Game Object.
                 * 
                 * Empty by default and never populated by Phaser, this is left for developers to use.
                 */
                name: string;

                /**
                 * The Particle Class which will be emitted by this Emitter.
                 */
                particleClass: Phaser.GameObjects.Particles.Particle;

                /**
                 * [description]
                 */
                x: number;

                /**
                 * [description]
                 */
                y: number;

                /**
                 * A radial emitter will emit particles in all directions between angle min and max,
                 * using speed as the value. If set to false then this acts as a point Emitter.
                 * A point emitter will emit particles only in the direction derived from the speedX and speedY values.
                 */
                radial: boolean;

                /**
                 * [description]
                 */
                gravityX: number;

                /**
                 * [description]
                 */
                gravityY: number;

                /**
                 * [description]
                 */
                acceleration: boolean;

                /**
                 * [description]
                 */
                accelerationX: number;

                /**
                 * [description]
                 */
                accelerationY: number;

                /**
                 * [description]
                 */
                maxVelocityX: number;

                /**
                 * [description]
                 */
                maxVelocityY: number;

                /**
                 * [description]
                 */
                speedX: number;

                /**
                 * [description]
                 */
                speedY: number;

                /**
                 * [description]
                 */
                moveTo: boolean;

                /**
                 * [description]
                 */
                moveToX: number;

                /**
                 * [description]
                 */
                moveToY: number;

                /**
                 * [description]
                 */
                bounce: number;

                /**
                 * [description]
                 */
                scaleX: number;

                /**
                 * [description]
                 */
                scaleY: number;

                /**
                 * [description]
                 */
                tint: integer;

                /**
                 * [description]
                 */
                alpha: number;

                /**
                 * [description]
                 */
                lifespan: number;

                /**
                 * [description]
                 */
                angle: number;

                /**
                 * [description]
                 */
                rotate: number;

                /**
                 * [description]
                 */
                emitCallback: ParticleEmitterCallback;

                /**
                 * [description]
                 */
                emitCallbackScope: any;

                /**
                 * [description]
                 */
                deathCallback: ParticleDeathCallback;

                /**
                 * [description]
                 */
                deathCallbackScope: any;

                /**
                 * Set to hard limit the amount of particle objects this emitter is allowed to create.
                 * 0 means unlimited.
                 */
                maxParticles: number;

                /**
                 * How many particles are emitted each time the emitter updates.
                 */
                quantity: number;

                /**
                 * How many ms to wait after emission before the particles start updating.
                 */
                delay: number;

                /**
                 * How often a particle is emitted in ms (if emitter is a constant / flow emitter)
                 * If emitter is an explosion emitter this value will be -1.
                 * Anything > -1 sets this to be a flow emitter.
                 */
                frequency: number;

                /**
                 * Controls if the emitter is currently emitting particles.
                 * Already alive particles will continue to update until they expire.
                 */
                on: boolean;

                /**
                 * Newly emitted particles are added to the top of the particle list, i.e. rendered above those already alive.
                 * Set to false to send them to the back.
                 */
                particleBringToTop: boolean;

                /**
                 * [description]
                 */
                timeScale: number;

                /**
                 * [description]
                 */
                emitZone: object;

                /**
                 * [description]
                 */
                deathZone: object;

                /**
                 * [description]
                 */
                bounds: Phaser.Geom.Rectangle;

                /**
                 * [description]
                 */
                collideLeft: boolean;

                /**
                 * [description]
                 */
                collideRight: boolean;

                /**
                 * [description]
                 */
                collideTop: boolean;

                /**
                 * [description]
                 */
                collideBottom: boolean;

                /**
                 * [description]
                 */
                active: boolean;

                /**
                 * [description]
                 */
                visible: boolean;

                /**
                 * [description]
                 */
                blendMode: integer;

                /**
                 * [description]
                 */
                follow: Phaser.GameObjects.Particles.Particle;

                /**
                 * [description]
                 */
                followOffset: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                trackVisible: boolean;

                /**
                 * [description]
                 */
                currentFrame: number;

                /**
                 * [description]
                 */
                randomFrame: boolean;

                /**
                 * [description]
                 */
                frameQuantity: number;

                /**
                 * [description]
                 * @param config [description]
                 */
                fromJSON(config: object): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param output [description]
                 */
                toJSON(output: object): object;

                /**
                 * [description]
                 * @param target [description]
                 * @param offsetX [description] Default 0.
                 * @param offsetY [description] Default 0.
                 * @param trackVisible [description] Default false.
                 */
                startFollow(target: Phaser.GameObjects.Particles.Particle, offsetX?: number, offsetY?: number, trackVisible?: boolean): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                stopFollow(): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                getFrame(): Phaser.Textures.Frame;

                /**
                 * [description]
                 * @param frames [description]
                 * @param pickRandom [description] Default true.
                 * @param quantity [description] Default 1.
                 */
                setFrame(frames: any[] | string | integer | object, pickRandom?: boolean, quantity?: integer): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setRadial(value: boolean): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setPosition(x: number, y: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setBounds(x: number | object, y: number, width: number, height: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSpeedX(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSpeedY(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSpeed(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setScaleX(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setScaleY(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setScale(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravityX(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravityY(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setGravity(x: number, y: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAlpha(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setEmitterAngle(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngle(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param value [description]
                 */
                setLifespan(value: number): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param quantity [description]
                 */
                setQuantity(quantity: integer): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param frequency [description]
                 * @param quantity [description]
                 */
                setFrequency(frequency: number, quantity?: integer): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * The zone must have a function called `getPoint` that takes a particle object and sets
                 * its x and y properties accordingly then returns that object.
                 * @param zoneConfig [description]
                 */
                setEmitZone(zoneConfig?: object): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param zoneConfig [description]
                 */
                setDeathZone(zoneConfig?: object): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param particleCount [description]
                 */
                reserve(particleCount: integer): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                getAliveParticleCount(): integer;

                /**
                 * [description]
                 */
                getDeadParticleCount(): integer;

                /**
                 * [description]
                 */
                getParticleCount(): integer;

                /**
                 * [description]
                 */
                atLimit(): boolean;

                /**
                 * [description]
                 * @param callback [description]
                 * @param context [description]
                 */
                onParticleEmit(callback: ParticleEmitterCallback, context?: any): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param callback [description]
                 * @param context [description]
                 */
                onParticleDeath(callback: ParticleDeathCallback, context?: any): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                killAll(): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param callback [description]
                 * @param thisArg [description]
                 */
                forEachAlive(callback: ParticleEmitterCallback, thisArg: any): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param callback [description]
                 * @param thisArg [description]
                 */
                forEachDead(callback: ParticleEmitterCallback, thisArg: any): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                start(): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                pause(): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                resume(): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 */
                depthSort(): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param frequency [description]
                 * @param count [description] Default 1.
                 */
                flow(frequency: number, count?: integer): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * [description]
                 * @param count The amount of Particles to emit.
                 * @param x The x coordinate to emit the Particles from.
                 * @param y The y coordinate to emit the Particles from.
                 */
                explode(count: integer, x: number, y: number): Phaser.GameObjects.Particles.Particle;

                /**
                 * [description]
                 * @param x The x coordinate to emit the Particles from.
                 * @param y The y coordinate to emit the Particles from.
                 * @param count The amount of Particles to emit.
                 */
                emitParticleAt(x: number, y: number, count: integer): Phaser.GameObjects.Particles.Particle;

                /**
                 * [description]
                 * @param count The amount of Particles to emit.
                 * @param x The x coordinate to emit the Particles from.
                 * @param y The y coordinate to emit the Particles from.
                 */
                emitParticle(count: integer, x: number, y: number): Phaser.GameObjects.Particles.Particle;

                /**
                 * [description]
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                preUpdate(time: integer, delta: number): void;

                /**
                 * [description]
                 * @param a [description]
                 * @param b [description]
                 */
                depthSortCallback(a: object, b: object): integer;

                /**
                 * [description]
                 * @param a [description]
                 * @param b [description]
                 */
                indexSortCallback(a: object, b: object): integer;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

            }

            /**
             * [description]
             */
            class ParticleEmitterManager extends Phaser.GameObjects.GameObject {
                /**
                 * 
                 * @param scene [description]
                 * @param texture [description]
                 * @param frame [description]
                 * @param emitters [description]
                 */
                constructor(scene: Phaser.Scene, texture: string, frame: string | integer, emitters: Phaser.GameObjects.Particles.ParticleEmitter[]);

                /**
                 * [description]
                 */
                timeScale: number;

                /**
                 * [description]
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * [description]
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * [description]
                 */
                frameNames: Phaser.Textures.Frame[];

                /**
                 * A list of Emitters being managed by this Emitter Manager.
                 */
                emitters: Phaser.Structs.List<Phaser.GameObjects.Particles.ParticleEmitter>;

                /**
                 * A list of Gravity Wells being managed by this Emitter Manager.
                 */
                wells: Phaser.Structs.List<Phaser.GameObjects.Particles.GravityWell>;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setFrame(frame?: string | integer): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * [description]
                 * @param frames [description]
                 * @param emitter [description]
                 */
                setEmitterFrames(frames: Phaser.Textures.Frame | Phaser.Textures.Frame[], emitter: Phaser.GameObjects.Particles.ParticleEmitter): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * Adds an existing Particle Emitter to this Manager.
                 * @param emitter The Particle Emitter to add to this Emitter Manager.
                 */
                addEmitter(emitter: Phaser.GameObjects.Particles.ParticleEmitter): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * Creates a new Particle Emitter object, adds it to this Manager and returns a reference to it.
                 * @param config [description]
                 */
                createEmitter(config: object): Phaser.GameObjects.Particles.ParticleEmitter;

                /**
                 * Adds an existing Gravity Well object to this Manager.
                 * @param well The Gravity Well to add to this Emitter Manager.
                 */
                addGravityWell(well: Phaser.GameObjects.Particles.GravityWell): Phaser.GameObjects.Particles.GravityWell;

                /**
                 * Creates a new Gravity Well, adds it to this Manager and returns a reference to it.
                 * @param config [description]
                 */
                createGravityWell(config: object): Phaser.GameObjects.Particles.GravityWell;

                /**
                 * [description]
                 * @param count [description]
                 * @param x [description]
                 * @param y [description]
                 */
                emitParticle(count: integer, x: number, y: number): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param count [description]
                 */
                emitParticleAt(x: number, y: number, count: integer): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * Pauses this Emitter Manager.
                 * 
                 * This has the effect of pausing all emitters, and all particles of those emitters, currently under its control.
                 * 
                 * The particles will still render, but they will not have any of their logic updated.
                 */
                pause(): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * Resumes this Emitter Manager, should it have been previously paused.
                 */
                resume(): Phaser.GameObjects.Particles.ParticleEmitterManager;

                /**
                 * [description]
                 */
                getProcessors(): Phaser.GameObjects.Particles.GravityWell[];

                /**
                 * [description]
                 * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
                 * @param delta The delta time, in ms, elapsed since the last frame.
                 */
                preUpdate(time: integer, delta: number): void;

            }

            namespace Zones {
                /**
                 * A Death Zone.
                 * 
                 * 
                 * 
                 * A Death Zone is a special type of zone that will kill a Particle as soon as it either enters, or leaves, the zone.
                 * 
                 * 
                 * 
                 * The zone consists of a `source` which could be a Geometric shape, such as a Rectangle or Ellipse, or your own
                 * 
                 * object as long as it includes a `contains` method for which the Particles can be tested against.
                 */
                class DeathZone {
                    /**
                     * 
                     * @param source An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
                     * @param killOnEnter Should the Particle be killed when it enters the zone? `true` or leaves it? `false`
                     */
                    constructor(source: object, killOnEnter: boolean);

                    /**
                     * An object instance that has a `contains` method that returns a boolean when given `x` and `y` arguments.
                     * This could be a Geometry shape, such as `Phaser.Geom.Circle`, or your own custom object.
                     */
                    source: object;

                    /**
                     * Set to `true` if the Particle should be killed if it enters this zone.
                     * Set to `false` to kill the Particle if it leaves this zone.
                     */
                    killOnEnter: boolean;

                    /**
                     * Checks if the given Particle will be killed or not by this zone.
                     * @param particle The Particle to be checked against this zone.
                     */
                    willKill(particle: Phaser.GameObjects.Particles.Particle): boolean;

                }

                /**
                 * [description]
                 */
                class EdgeZone {
                    /**
                     * 
                     * @param source [description]
                     * @param quantity [description]
                     * @param stepRate [description]
                     * @param yoyo [description] Default false.
                     * @param seamless [description] Default true.
                     */
                    constructor(source: object, quantity: number, stepRate: number, yoyo?: boolean, seamless?: boolean);

                    /**
                     * [description]
                     */
                    source: object;

                    /**
                     * [description]
                     */
                    points: Phaser.Geom.Point[];

                    /**
                     * [description]
                     */
                    quantity: number;

                    /**
                     * [description]
                     */
                    stepRate: number;

                    /**
                     * [description]
                     */
                    yoyo: boolean;

                    /**
                     * [description]
                     */
                    counter: number;

                    /**
                     * [description]
                     */
                    seamless: boolean;

                    /**
                     * [description]
                     */
                    updateSource(): Phaser.GameObjects.Particles.Zones.EdgeZone;

                    /**
                     * [description]
                     * @param source [description]
                     */
                    changeSource(source: object): Phaser.GameObjects.Particles.Zones.EdgeZone;

                    /**
                     * [description]
                     * @param particle [description]
                     */
                    getPoint(particle: Phaser.GameObjects.Particles.Particle): void;

                }

                /**
                 * [description]
                 */
                class RandomZone {
                    /**
                     * 
                     * @param source [description]
                     */
                    constructor(source: object);

                    /**
                     * [description]
                     */
                    source: object;

                    /**
                     * [description]
                     * @param particle [description]
                     */
                    getPoint(particle: Phaser.GameObjects.Particles.Particle): void;

                }

            }

        }

        /**
         * A PathFollower Game Object.
         * 
         * 
         * 
         * A PathFollower is a Sprite Game Object with some extra helpers to allow it to follow a Path automatically.
         * 
         * 
         * 
         * Anything you can do with a standard Sprite can be done with this PathFollower, such as animate it, tint it,
         * 
         * scale it and so on.
         * 
         * 
         * 
         * PathFollowers are bound to a single Path at any one time and can traverse the length of the Path, from start
         * 
         * to finish, forwards or backwards, or from any given point on the Path to its end. They can optionally rotate
         * 
         * to face the direction of the path, be offset from the path coordinates or rotate independently of the Path.
         */
        class PathFollower extends Phaser.GameObjects.Sprite {
            /**
             * 
             * @param scene [description]
             * @param path The Path this PathFollower is following. It can only follow one Path at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, path: Phaser.Curves.Path, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * The Path this PathFollower is following. It can only follow one Path at a time.
             */
            path: Phaser.Curves.Path;

            /**
             * Should the PathFollower automatically rotate to point in the direction of the Path?
             */
            rotateToPath: boolean;

            /**
             * [description]
             */
            pathRotationVerticalAdjust: boolean;

            /**
             * If the PathFollower is rotating to match the Path (@see Phaser.GameObjects.PathFollower#rotateToPath)
             * this value is added to the rotation value. This allows you to rotate objects to a path but control
             * the angle of the rotation as well.
             */
            pathRotationOffset: number;

            /**
             * An additional vector to add to the PathFollowers position, allowing you to offset it from the
             * Path coordinates.
             */
            pathOffset: Phaser.Math.Vector2;

            /**
             * [description]
             */
            pathVector: Phaser.Math.Vector2;

            /**
             * [description]
             */
            pathTween: Phaser.Tweens.Tween;

            /**
             * [description]
             */
            pathConfig: PathConfig;

            /**
             * [description]
             * @param path The Path this PathFollower is following. It can only follow one Path at a time.
             * @param config [description]
             */
            setPath(path: Phaser.Curves.Path, config?: PathConfig): Phaser.GameObjects.PathFollower;

            /**
             * [description]
             * @param value [description]
             * @param offset Rotation offset in degrees. Default 0.
             * @param verticalAdjust [description] Default false.
             */
            setRotateToPath(value: number, offset?: number, verticalAdjust?: boolean): Phaser.GameObjects.PathFollower;

            /**
             * Is this PathFollower actively following a Path or not?
             * To be considered as `isFollowing` it must be currently moving on a Path, and not paused.
             */
            isFollowing(): boolean;

            /**
             * Starts this PathFollower following its given Path.
             * @param config [description] Default {}.
             * @param startAt [description] Default 0.
             */
            startFollow(config?: number | PathConfig, startAt?: number): Phaser.GameObjects.PathFollower;

            /**
             * Pauses this PathFollower. It will still continue to render, but it will remain motionless at the
             * point on the Path at which you paused it.
             */
            pauseFollow(): Phaser.GameObjects.PathFollower;

            /**
             * Resumes a previously paused PathFollower.
             * If the PathFollower was not paused this has no effect.
             */
            resumeFollow(): Phaser.GameObjects.PathFollower;

            /**
             * Stops this PathFollower from following the path any longer.
             * This will invoke any 'stop' conditions that may exist on the Path, or for the follower.
             */
            stopFollow(): Phaser.GameObjects.PathFollower;

            /**
             * Internal update handler that advances this PathFollower along the path.
             * Called automatically by the Scene step, should not typically be called directly.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time, in ms, elapsed since the last frame.
             */
            protected preUpdate(time: integer, delta: number): void;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * A Quad Game Object.
         * 
         * 
         * 
         * A Quad is a Mesh Game Object pre-configured with two triangles arranged into a rectangle, with a single
         * 
         * texture spread across them.
         * 
         * 
         * 
         * You can manipulate the corner points of the quad via the getters and setters such as `topLeftX`, and also
         * 
         * change their alpha and color values. The quad itself can be moved by adjusting the `x` and `y` properties.
         */
        class Quad extends Phaser.GameObjects.Mesh {
            /**
             * 
             * @param scene [description]
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * The top-left x vertex of this Quad.
             */
            topLeftX: number;

            /**
             * The top-left y vertex of this Quad.
             */
            topLeftY: number;

            /**
             * The top-right x vertex of this Quad.
             */
            topRightX: number;

            /**
             * The top-right y vertex of this Quad.
             */
            topRightY: number;

            /**
             * The bottom-left x vertex of this Quad.
             */
            bottomLeftX: number;

            /**
             * The bottom-left y vertex of this Quad.
             */
            bottomLeftY: number;

            /**
             * The bottom-right x vertex of this Quad.
             */
            bottomRightX: number;

            /**
             * The bottom-right y vertex of this Quad.
             */
            bottomRightY: number;

            /**
             * The top-left alpha value of this Quad.
             */
            topLeftAlpha: number;

            /**
             * The top-right alpha value of this Quad.
             */
            topRightAlpha: number;

            /**
             * The bottom-left alpha value of this Quad.
             */
            bottomLeftAlpha: number;

            /**
             * The bottom-right alpha value of this Quad.
             */
            bottomRightAlpha: number;

            /**
             * The top-left color value of this Quad.
             */
            topLeftColor: number;

            /**
             * The top-right color value of this Quad.
             */
            topRightColor: number;

            /**
             * The bottom-left color value of this Quad.
             */
            bottomLeftColor: number;

            /**
             * The bottom-right color value of this Quad.
             */
            bottomRightColor: number;

            /**
             * Sets the top-left vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setTopLeft(x: number, y: number): Phaser.GameObjects.Quad;

            /**
             * Sets the top-right vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setTopRight(x: number, y: number): Phaser.GameObjects.Quad;

            /**
             * Sets the bottom-left vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setBottomLeft(x: number, y: number): Phaser.GameObjects.Quad;

            /**
             * Sets the bottom-right vertex position of this Quad.
             * @param x The horizontal coordinate of the vertex.
             * @param y The vertical coordinate of the vertex.
             */
            setBottomRight(x: number, y: number): Phaser.GameObjects.Quad;

            /**
             * Resets the positions of the four corner vertices of this Quad.
             */
            resetPosition(): Phaser.GameObjects.Quad;

            /**
             * Resets the alpha values used by this Quad back to 1.
             */
            resetAlpha(): Phaser.GameObjects.Quad;

            /**
             * Resets the color values used by this Quad back to 0xffffff.
             */
            resetColors(): Phaser.GameObjects.Quad;

            /**
             * Resets the position, alpha and color values used by this Quad.
             */
            reset(): Phaser.GameObjects.Quad;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

        }

        /**
         * A Render Texture.
         */
        class RenderTexture extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.MatrixStack, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Render Texture. Default 32.
             * @param height The height of the Render Texture. Default 32.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, width?: integer, height?: integer);

            /**
             * A reference to either the Canvas or WebGL Renderer that the Game instance is using.
             */
            renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

            /**
             * [description]
             */
            globalTint: number;

            /**
             * [description]
             */
            globalAlpha: number;

            /**
             * [description]
             */
            destroy(): void;

            /**
             * [description]
             * @param tint [description]
             */
            setGlobalTint(tint: integer): Phaser.GameObjects.RenderTexture;

            /**
             * [description]
             * @param alpha [description]
             */
            setGlobalAlpha(alpha: number): Phaser.GameObjects.RenderTexture;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * [description]
             */
            initMatrixStack(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            save(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            restore(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            loadIdentity(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             * @param c [description]
             * @param d [description]
             * @param tx [description]
             * @param ty [description]
             */
            transform(a: number, b: number, c: number, d: number, tx: number, ty: number): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             * @param c [description]
             * @param d [description]
             * @param tx [description]
             * @param ty [description]
             */
            setTransform(a: number, b: number, c: number, d: number, tx: number, ty: number): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            translate(x: number, y: number): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            scale(x: number, y: number): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param t The angle of rotation, in radians.
             */
            rotate(t: number): Phaser.GameObjects.GameObject;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * A Sprite Game Object.
         * 
         * 
         * 
         * A Sprite Game Object is used for the display of both static and animated images in your game.
         * 
         * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
         * 
         * and animated.
         * 
         * 
         * 
         * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
         * 
         * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
         * 
         * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
         */
        class Sprite extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, texture: string, frame?: string | integer);

            /**
             * [description]
             */
            anims: Phaser.GameObjects.Components.Animation;

            /**
             * [description]
             * @param time [description]
             * @param delta [description]
             */
            protected preUpdate(time: number, delta: number): void;

            /**
             * [description]
             * @param key [description]
             * @param ignoreIfPlaying [description] Default false.
             * @param startFrame [description] Default 0.
             */
            play(key: string, ignoreIfPlaying?: boolean, startFrame?: integer): Phaser.GameObjects.Sprite;

            /**
             * [description]
             */
            toJSON(): JSONGameObject;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * A Sprite 3D Game Object.
         * 
         * 
         * 
         * The Sprite 3D object is an encapsulation of a standard Sprite object, with additional methods to allow
         * 
         * it to be rendered by a 3D Camera. The Sprite can be positioned anywhere within 3D space.
         */
        class Sprite3D extends Phaser.GameObjects.GameObject {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The x position of this Game Object.
             * @param y The y position of this Game Object.
             * @param z The z position of this Game Object.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, z: number, texture: string, frame?: string | integer);

            /**
             * [description]
             */
            gameObject: Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            position: Phaser.Math.Vector4;

            /**
             * [description]
             */
            size: Phaser.Math.Vector2;

            /**
             * [description]
             */
            scale: Phaser.Math.Vector2;

            /**
             * [description]
             */
            adjustScaleX: boolean;

            /**
             * [description]
             */
            adjustScaleY: boolean;

            /**
             * [description]
             * @param camera The 3D Camera onto which to project this Sprite.
             */
            project(camera: Phaser.Cameras.Sprite3D.Camera): void;

            /**
             * [description]
             * @param value [description]
             */
            setVisible(value: boolean): Phaser.GameObjects.Sprite3D;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             */
            z: number;

        }

        /**
         * [description]
         */
        class Text extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param text The text this Text object will display.
             * @param style The text style configuration object.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, text: string | string[], style: object);

            /**
             * Returns an object containing dimensions of the Text object.
             * @param text The Text object to get the size from.
             * @param size [description]
             * @param lines [description]
             */
            static GetTextSize(text: Phaser.GameObjects.Text, size: number, lines: any[]): object;

            /**
             * Calculates the ascent, descent and fontSize of a given font style.
             * @param textStyle The TextStyle object to measure.
             */
            static MeasureText(textStyle: Phaser.GameObjects.Text.TextStyle): object;

            /**
             * The canvas element that the text is rendered to.
             */
            canvas: HTMLCanvasElement;

            /**
             * The context of the canvas element that the text is rendered to.
             */
            context: CanvasRenderingContext2D;

            /**
             * [description]
             */
            style: Phaser.GameObjects.Text.TextStyle;

            /**
             * [description]
             */
            autoRound: boolean;

            /**
             * The Regular Expression that is used to split the text up into lines, in
             * multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
             * You can change this RegExp to be anything else that you may need.
             */
            splitRegExp: object;

            /**
             * [description]
             */
            text: string;

            /**
             * [description]
             */
            resolution: number;

            /**
             * Specify a padding value which is added to the line width and height when calculating the Text size.
             * Allows you to add extra spacing if the browser is unable to accurately determine the true font dimensions.
             */
            padding: Object;

            /**
             * [description]
             */
            width: number;

            /**
             * [description]
             */
            height: number;

            /**
             * [description]
             */
            canvasTexture: HTMLCanvasElement;

            /**
             * [description]
             */
            dirty: boolean;

            /**
             * [description]
             */
            initRTL(): void;

            /**
             * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
             * bounds.
             * @param text The text to perform word wrap detection against.
             */
            runWordWrap(text: string): string;

            /**
             * Advanced wrapping algorithm that will wrap words as the line grows longer than its horizontal
             * bounds. Consecutive spaces will be collapsed and replaced with a single space. Lines will be
             * trimmed of white space before processing. Throws an error if wordWrapWidth is less than a
             * single character.
             * @param text The text to perform word wrap detection against.
             * @param context [description]
             * @param wordWrapWidth [description]
             */
            advancedWordWrap(text: string, context: CanvasRenderingContext2D, wordWrapWidth: number): string;

            /**
             * Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal
             * bounds. Spaces are not collapsed and whitespace is not trimmed.
             * @param text The text to perform word wrap detection against.
             * @param context [description]
             * @param wordWrapWidth [description]
             */
            basicWordWrap(text: string, context: CanvasRenderingContext2D, wordWrapWidth: number): string;

            /**
             * Runs the given text through this Text objects word wrapping and returns the results as an
             * array, where each element of the array corresponds to a wrapped line of text.
             * @param text The text for which the wrapping will be calculated. If unspecified, the Text objects current text will be used.
             */
            getWrappedText(text: string): string[];

            /**
             * [description]
             * @param value The string, or array of strings, to be set as the content of this Text object.
             */
            setText(value: string | string[]): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param style [description]
             */
            setStyle(style: object): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param font [description]
             */
            setFont(font: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param family [description]
             */
            setFontFamily(family: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param size [description]
             */
            setFontSize(size: number): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param style [description]
             */
            setFontStyle(style: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param width [description]
             * @param height [description]
             */
            setFixedSize(width: number, height: number): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param color [description]
             */
            setBackgroundColor(color: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param color [description]
             */
            setFill(color: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param color [description]
             */
            setColor(color: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param color [description]
             * @param thickness [description]
             */
            setStroke(color: string, thickness: number): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param color [description]
             * @param blur [description]
             * @param shadowStroke [description]
             * @param shadowFill [description]
             */
            setShadow(x: number, y: number, color: string, blur: number, shadowStroke: boolean, shadowFill: boolean): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            setShadowOffset(x: number, y: number): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param color [description]
             */
            setShadowColor(color: string): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param blur [description]
             */
            setShadowBlur(blur: number): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param enabled [description]
             */
            setShadowStroke(enabled: boolean): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param enabled [description]
             */
            setShadowFill(enabled: boolean): Phaser.GameObjects.Text;

            /**
             * Set the width (in pixels) to use for wrapping lines. Pass in null to remove wrapping by width.
             * @param width The maximum width of a line in pixels. Set to null to remove wrapping.
             * @param useAdvancedWrap Whether or not to use the advanced wrapping
             * algorithm. If true, spaces are collapsed and whitespace is trimmed from lines. If false,
             * spaces and whitespace are left as is. Default false.
             */
            setWordWrapWidth(width: number, useAdvancedWrap?: boolean): Phaser.GameObjects.Text;

            /**
             * Set a custom callback for wrapping lines. Pass in null to remove wrapping by callback.
             * @param callback A custom function that will be responsible for wrapping the
             * text. It will receive two arguments: text (the string to wrap), textObject (this Text
             * instance). It should return the wrapped lines either as an array of lines or as a string with
             * newline characters in place to indicate where breaks should happen.
             * @param scope The scope that will be applied when the callback is invoked. Default null.
             */
            setWordWrapCallback(callback: TextStyleWordWrapCallback, scope?: object): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param align [description]
             */
            setAlign(align: string): Phaser.GameObjects.Text;

            /**
             * 'left' can be an object.
             * If only 'left' and 'top' are given they are treated as 'x' and 'y'
             * @param left [description]
             * @param top [description]
             * @param right [description]
             * @param bottom [description]
             */
            setPadding(left: number | object, top: number, right: number, bottom: number): Phaser.GameObjects.Text;

            /**
             * [description]
             * @param max [description] Default 0.
             */
            setMaxLines(max?: integer): Phaser.GameObjects.Text;

            /**
             * [description]
             */
            updateText(): Phaser.GameObjects.Text;

            /**
             * [description]
             */
            getTextMetrics(): object;

            /**
             * [description]
             */
            toJSON(): JSONGameObject;

            /**
             * [description]
             */
            preDestroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * [description]
         */
        class TileSprite extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object.
             * @param height The height of the Game Object.
             * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
             * @param frame An optional frame from the Texture this Game Object is rendering with.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, width: number, height: number, texture: string, frame?: string | integer);

            /**
             * [description]
             */
            tilePositionX: number;

            /**
             * [description]
             */
            tilePositionY: number;

            /**
             * [description]
             */
            dirty: boolean;

            /**
             * [description]
             */
            tileTexture: WebGLTexture;

            /**
             * [description]
             */
            renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer;

            /**
             * The next power of two value from the width of the Frame.
             */
            potWidth: integer;

            /**
             * The next power of two value from the height of the Frame.
             */
            potHeight: integer;

            /**
             * [description]
             */
            canvasPattern: CanvasPattern;

            /**
             * [description]
             */
            canvasBuffer: HTMLCanvasElement;

            /**
             * [description]
             */
            canvasBufferCtx: CanvasRenderingContext2D;

            /**
             * Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.
             * @param x The x position of this sprite's tiling texture.
             * @param y The y position of this sprite's tiling texture.
             */
            setTilePosition(x?: number, y?: number): Phaser.GameObjects.TileSprite;

            /**
             * [description]
             */
            updateTileTexture(): void;

            /**
             * [description]
             */
            destroy(): void;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object to be that of the given Frame.
             * @param frame The frame to base the size of this Game Object on.
             */
            setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The Texture this Game Object is using to render with.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The Texture Frame this Game Object is using to render with.
             */
            frame: Phaser.Textures.Frame;

            /**
             * Sets the texture and frame this Game Object will use to render with.
             * 
             * Textures are referenced by their string-based keys, as stored in the Texture Manager.
             * @param key The key of the texture to be used, as stored in the Texture Manager.
             * @param frame The name or index of the frame within the Texture.
             */
            setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Sets the frame this Game Object will use to render with.
             * 
             * The Frame has to belong to the current Texture being used.
             * 
             * It can be either a string or an index.
             * 
             * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
             * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
             * @param frame The name or index of the frame within the Texture.
             * @param updateSize Should this call adjust the size of the Game Object? Default true.
             * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
             */
            setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

            /**
             * Clears all tint values associated with this Game Object.
             * Immediately sets the alpha levels back to 0xffffff (no tint)
             */
            clearTint(): Phaser.GameObjects.GameObject;

            /**
             * Sets the tint values for this Game Object.
             * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
             * @param topRight The tint being applied to the top-right of the Game Object.
             * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
             * @param bottomRight The tint being applied to the bottom-right of the Game Object.
             */
            setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

            /**
             * The tint value being applied to the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopLeft: integer;

            /**
             * The tint value being applied to the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintTopRight: integer;

            /**
             * The tint value being applied to the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomLeft: integer;

            /**
             * The tint value being applied to the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            tintBottomRight: integer;

            /**
             * The tint value being applied to the whole of the Game Object.
             */
            tint: integer;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * [description]
         */
        class UpdateList {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * [description]
             * @param child [description]
             */
            add(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param time [description]
             * @param delta [description]
             */
            preUpdate(time: number, delta: number): void;

            /**
             * [description]
             * @param time [description]
             * @param delta [description]
             */
            update(time: number, delta: number): void;

            /**
             * [description]
             * @param child [description]
             */
            remove(child: Phaser.GameObjects.GameObject): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            removeAll(): Phaser.GameObjects.UpdateList;

            /**
             * The Scene that owns this plugin is shutting down.
             * We need to kill and reset all internal properties as well as stop listening to Scene events.
             */
            shutdown(): void;

            /**
             * The Scene that owns this plugin is being destroyed.
             * We need to shutdown and then kill off all external references.
             */
            destroy(): void;

        }

        /**
         * A Zone Game Object.
         * 
         * 
         * 
         * A Zone is a non-rendering rectangular Game Object that has a position and size.
         * 
         * It has no texture and never displays, but does live on the display list and
         * 
         * can be moved, scaled and rotated like any other Game Object.
         * 
         * 
         * 
         * Its primary use is for creating Drop Zones and Input Hit Areas and it has a couple of helper methods
         * 
         * specifically for this. It is also useful for object overlap checks, or as a base for your own
         * 
         * non-displaying Game Objects.
         * 
         * The default origin is 0.5, the center of the Zone, the same as with Game Objects.
         */
        class Zone extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene [description]
             * @param x The horizontal position of this Game Object in the world.
             * @param y The vertical position of this Game Object in the world.
             * @param width The width of the Game Object. Default 1.
             * @param height The height of the Game Object. Default 1.
             */
            constructor(scene: Phaser.Scene, x: number, y: number, width?: number, height?: number);

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The Blend Mode of the Game Object.
             * Although a Zone never renders, it still has a blend mode to allow it to fit seamlessly into
             * display lists without causing a batch flush.
             */
            blendMode: integer;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             * @param resizeInput If this Zone has a Rectangle for a hit area this argument will resize the hit area as well. Default true.
             */
            setSize(width: number, height: number, resizeInput?: boolean): Phaser.GameObjects.Zone;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.Zone;

            /**
             * Sets this Zone to be a Circular Drop Zone.
             * The circle is centered on this Zones `x` and `y` coordinates.
             * @param radius The radius of the Circle that will form the Drop Zone.
             */
            setCircleDropZone(radius: number): Phaser.GameObjects.Zone;

            /**
             * Sets this Zone to be a Rectangle Drop Zone.
             * The rectangle is centered on this Zones `x` and `y` coordinates.
             * @param width The width of the rectangle drop zone.
             * @param height The height of the rectangle drop zone.
             */
            setRectangleDropZone(width: number, height: number): Phaser.GameObjects.Zone;

            /**
             * Allows you to define your own Geometry shape to be used as a Drop Zone.
             * @param shape A Geometry shape instance, such as Phaser.Geom.Ellipse, or your own custom shape.
             * @param callback A function that will return `true` if the given x/y coords it is sent are within the shape.
             */
            setDropZone(shape: object, callback: HitAreaCallback): Phaser.GameObjects.Zone;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

    }

    namespace Geom {
        /**
         * A Circle object.
         * 
         * 
         * 
         * This is a geometry object, containing numerical values and related methods to inspect and modify them.
         * 
         * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.
         * 
         * To render a Circle you should look at the capabilities of the Graphics class.
         */
        class Circle {
            /**
             * 
             * @param x The x position of the center of the circle. Default 0.
             * @param y The y position of the center of the circle. Default 0.
             * @param radius The radius of the circle. Default 0.
             */
            constructor(x?: number, y?: number, radius?: number);

            /**
             * Calculates the area of the circle.
             * @param circle The Circle to get the area of.
             */
            static Area(circle: Phaser.Geom.Circle): number;

            /**
             * The x position of the center of the circle.
             */
            x: number;

            /**
             * The y position of the center of the circle.
             */
            y: number;

            /**
             * Check to see if the Circle contains the given x / y coordinates.
             * @param x The x coordinate to check within the circle.
             * @param y The y coordinate to check within the circle.
             */
            contains(x: number, y: number): boolean;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Circle
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            getPoint<O extends Phaser.Geom.Point>(position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,
             * based on the given quantity or stepRate values.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            getPoints<O extends Phaser.Geom.Point[]>(quantity: integer, stepRate?: number, output?: O): O;

            /**
             * Returns a uniformly distributed random point from anywhere within the Circle.
             * @param point A Point or point-like object to set the random `x` and `y` values in.
             */
            getRandomPoint<O extends Phaser.Geom.Point>(point?: O): O;

            /**
             * Sets the x, y and radius of this circle.
             * @param x The x position of the center of the circle. Default 0.
             * @param y The y position of the center of the circle. Default 0.
             * @param radius The radius of the circle. Default 0.
             */
            setTo(x?: number, y?: number, radius?: number): Phaser.Geom.Circle;

            /**
             * Sets this Circle to be empty with a radius of zero.
             * Does not change its position.
             */
            setEmpty(): Phaser.Geom.Circle;

            /**
             * Sets the position of this Circle.
             * @param x The x position of the center of the circle. Default 0.
             * @param y The y position of the center of the circle. Default 0.
             */
            setPosition(x?: number, y?: number): Phaser.Geom.Circle;

            /**
             * Checks to see if the Circle is empty: has a radius of zero.
             */
            isEmpty(): boolean;

            /**
             * The radius of the Circle.
             */
            radius: number;

            /**
             * The diameter of the Circle.
             */
            diameter: number;

            /**
             * The left position of the Circle.
             */
            left: number;

            /**
             * The right position of the Circle.
             */
            right: number;

            /**
             * The top position of the Circle.
             */
            top: number;

            /**
             * The bottom position of the Circle.
             */
            bottom: number;

            /**
             * Returns the circumference of the given Circle.
             * @param circle The Circle to get the circumference of.
             */
            static Circumference(circle: Phaser.Geom.Circle): number;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
             * @param circle The Circle to get the circumference point on.
             * @param angle The angle from the center of the Circle to the circumference to return the point from. Given in radians.
             * @param out A Point, or point-like object, to store the results in. If not given a Point will be created.
             */
            static CircumferencePoint<O extends Phaser.Geom.Point>(circle: Phaser.Geom.Circle, angle: number, out?: O): O;

            /**
             * Creates a new Circle instance based on the values contained in the given source.
             * @param source The Circle to be cloned. Can be an instance of a Circle or a circle-like object, with x, y and radius properties.
             */
            static Clone(source: Phaser.Geom.Circle | object): Phaser.Geom.Circle;

            /**
             * Check to see if the Circle contains the given x / y coordinates.
             * @param circle The Circle to check.
             * @param x The x coordinate to check within the circle.
             * @param y The y coordinate to check within the circle.
             */
            static Contains(circle: Phaser.Geom.Circle, x: number, y: number): boolean;

            /**
             * Check to see if the Circle contains the given Point object.
             * @param circle The Circle to check.
             * @param point The Point object to check if it's within the Circle or not.
             */
            static ContainsPoint(circle: Phaser.Geom.Circle, point: Phaser.Geom.Point | object): boolean;

            /**
             * Check to see if the Circle contains all four points of the given Rectangle object.
             * @param circle The Circle to check.
             * @param rect The Rectangle object to check if it's within the Circle or not.
             */
            static ContainsRect(circle: Phaser.Geom.Circle, rect: Phaser.Geom.Rectangle | object): boolean;

            /**
             * Copies the `x`, `y` and `radius` properties from the `source` Circle
             * into the given `dest` Circle, then returns the `dest` Circle.
             * @param source The source Circle to copy the values from.
             * @param dest The destination Circle to copy the values to.
             */
            static CopyFrom<O extends Phaser.Geom.Circle>(source: Phaser.Geom.Circle, dest: O): O;

            /**
             * Compares the `x`, `y` and `radius` properties of the two given Circles.
             * Returns `true` if they all match, otherwise returns `false`.
             * @param circle The first Circle to compare.
             * @param toCompare The second Circle to compare.
             */
            static Equals(circle: Phaser.Geom.Circle, toCompare: Phaser.Geom.Circle): boolean;

            /**
             * Returns the bounds of the Circle object.
             * @param circle The Circle to get the bounds from.
             * @param out A Rectangle, or rectangle-like object, to store the circle bounds in. If not given a new Rectangle will be created.
             */
            static GetBounds<O extends Phaser.Geom.Rectangle>(circle: Phaser.Geom.Circle, out?: O): O;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Circle
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param circle The Circle to get the circumference point on.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            static GetPoint<O extends Phaser.Geom.Point>(circle: Phaser.Geom.Circle, position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,
             * based on the given quantity or stepRate values.
             * @param circle The Circle to get the points from.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            static GetPoints(circle: Phaser.Geom.Circle, quantity: integer, stepRate?: number, output?: any[]): Phaser.Geom.Point[];

            /**
             * Offsets the Circle by the values given.
             * @param circle The Circle to be offset (translated.)
             * @param x The amount to horizontally offset the Circle by.
             * @param y The amount to vertically offset the Circle by.
             */
            static Offset<O extends Phaser.Geom.Circle>(circle: O, x: number, y: number): O;

            /**
             * Offsets the Circle by the values given in the `x` and `y` properties of the Point object.
             * @param circle The Circle to be offset (translated.)
             * @param point The Point object containing the values to offset the Circle by.
             */
            static OffsetPoint<O extends Phaser.Geom.Circle>(circle: O, point: Phaser.Geom.Point | object): O;

            /**
             * Returns a uniformly distributed random point from anywhere within the given Circle.
             * @param circle The Circle to get a random point from.
             * @param out A Point or point-like object to set the random `x` and `y` values in.
             */
            static Random<O extends Phaser.Geom.Point>(circle: Phaser.Geom.Circle, out?: O): O;

        }

        /**
         * An Ellipse object.
         * 
         * 
         * 
         * This is a geometry object, containing numerical values and related methods to inspect and modify them.
         * 
         * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.
         * 
         * To render an Ellipse you should look at the capabilities of the Graphics class.
         */
        class Ellipse {
            /**
             * 
             * @param x The x position of the center of the ellipse. Default 0.
             * @param y The y position of the center of the ellipse. Default 0.
             * @param width The width of the ellipse. Default 0.
             * @param height The height of the ellipse. Default 0.
             */
            constructor(x?: number, y?: number, width?: number, height?: number);

            /**
             * Calculates the area of the Ellipse.
             * @param ellipse The Ellipse to get the area of.
             */
            static Area(ellipse: Phaser.Geom.Ellipse): number;

            /**
             * Returns the circumference of the given Ellipse.
             * @param ellipse The Ellipse to get the circumference of.
             */
            static Circumference(ellipse: Phaser.Geom.Ellipse): number;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse based on the given angle.
             * @param ellipse The Ellipse to get the circumference point on.
             * @param angle The angle from the center of the Ellipse to the circumference to return the point from. Given in radians.
             * @param out A Point, or point-like object, to store the results in. If not given a Point will be created.
             */
            static CircumferencePoint<O extends Phaser.Geom.Point>(ellipse: Phaser.Geom.Ellipse, angle: number, out?: O): O;

            /**
             * Creates a new Ellipse instance based on the values contained in the given source.
             * @param source The Ellipse to be cloned. Can be an instance of an Ellipse or a ellipse-like object, with x, y, width and height properties.
             */
            static Clone(source: Phaser.Geom.Ellipse): Phaser.Geom.Ellipse;

            /**
             * Check to see if the Ellipse contains the given x / y coordinates.
             * @param ellipse The Ellipse to check.
             * @param x The x coordinate to check within the ellipse.
             * @param y The y coordinate to check within the ellipse.
             */
            static Contains(ellipse: Phaser.Geom.Ellipse, x: number, y: number): boolean;

            /**
             * Check to see if the Ellipse contains the given Point object.
             * @param ellipse The Ellipse to check.
             * @param point The Point object to check if it's within the Circle or not.
             */
            static ContainsPoint(ellipse: Phaser.Geom.Ellipse, point: Phaser.Geom.Point | object): boolean;

            /**
             * Check to see if the Ellipse contains all four points of the given Rectangle object.
             * @param ellipse [description]
             * @param rect The Rectangle object to check if it's within the Ellipse or not.
             */
            static ContainsRect(ellipse: Phaser.Geom.Ellipse, rect: Phaser.Geom.Rectangle | object): boolean;

            /**
             * Copies the `x`, `y`, `width` and `height` properties from the `source` Ellipse
             * into the given `dest` Ellipse, then returns the `dest` Ellipse.
             * @param source The source Ellipse to copy the values from.
             * @param dest The destination Ellipse to copy the values to.
             */
            static CopyFrom<O extends Phaser.Geom.Ellipse>(source: Phaser.Geom.Ellipse, dest: O): O;

            /**
             * The x position of the center of the ellipse.
             */
            x: number;

            /**
             * The y position of the center of the ellipse.
             */
            y: number;

            /**
             * The width of the ellipse.
             */
            width: number;

            /**
             * The height of the ellipse.
             */
            height: number;

            /**
             * Check to see if the Ellipse contains the given x / y coordinates.
             * @param x The x coordinate to check within the ellipse.
             * @param y The y coordinate to check within the ellipse.
             */
            contains(x: number, y: number): boolean;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            getPoint<O extends Phaser.Geom.Point>(position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,
             * based on the given quantity or stepRate values.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.
             * @param output An array to insert the points in to. If not provided a new array will be created.
             */
            getPoints(quantity: integer, stepRate?: number, output?: any[]): Phaser.Geom.Point[];

            /**
             * Returns a uniformly distributed random point from anywhere within the given Ellipse.
             * @param point A Point or point-like object to set the random `x` and `y` values in.
             */
            getRandomPoint<O extends Phaser.Geom.Point>(point?: O): O;

            /**
             * Sets the x, y, width and height of this ellipse.
             * @param x The x position of the center of the ellipse.
             * @param y The y position of the center of the ellipse.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             */
            setTo(x: number, y: number, width: number, height: number): Phaser.Geom.Ellipse;

            /**
             * Sets this Ellipse to be empty with a width and height of zero.
             * Does not change its position.
             */
            setEmpty(): Phaser.Geom.Ellipse;

            /**
             * Sets the position of this Ellipse.
             * @param x The x position of the center of the ellipse.
             * @param y The y position of the center of the ellipse.
             */
            setPosition(x: number, y: number): Phaser.Geom.Ellipse;

            /**
             * Sets the size of this Ellipse.
             * Does not change its position.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse. Default width.
             */
            setSize(width: number, height?: number): Phaser.Geom.Ellipse;

            /**
             * Checks to see if the Ellipse is empty: has a width or height equal to zero.
             */
            isEmpty(): boolean;

            /**
             * Returns the minor radius of the ellipse. Also known as the Semi Minor Axis.
             */
            getMinorRadius(): number;

            /**
             * Returns the major radius of the ellipse. Also known as the Semi Major Axis.
             */
            getMajorRadius(): number;

            /**
             * The left position of the Ellipse.
             */
            left: number;

            /**
             * The right position of the Ellipse.
             */
            right: number;

            /**
             * The top position of the Ellipse.
             */
            top: number;

            /**
             * The bottom position of the Ellipse.
             */
            bottom: number;

            /**
             * Compares the `x`, `y`, `width` and `height` properties of the two given Ellipses.
             * Returns `true` if they all match, otherwise returns `false`.
             * @param ellipse The first Ellipse to compare.
             * @param toCompare The second Ellipse to compare.
             */
            static Equals(ellipse: Phaser.Geom.Ellipse, toCompare: Phaser.Geom.Ellipse): boolean;

            /**
             * Returns the bounds of the Ellipse object.
             * @param ellipse The Ellipse to get the bounds from.
             * @param out A Rectangle, or rectangle-like object, to store the ellipse bounds in. If not given a new Rectangle will be created.
             */
            static GetBounds<O extends Phaser.Geom.Rectangle>(ellipse: Phaser.Geom.Ellipse, out?: O): O;

            /**
             * Returns a Point object containing the coordinates of a point on the circumference of the Ellipse
             * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point
             * at 180 degrees around the circle.
             * @param ellipse The Ellipse to get the circumference point on.
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the ellipse.
             * @param out An object to store the return values in. If not given a Point object will be created.
             */
            static GetPoint<O extends Phaser.Geom.Point>(ellipse: Phaser.Geom.Ellipse, position: number, out?: O): O;

            /**
             * Returns an array of Point objects containing the coordinates of the points around the circumference of the Ellipse,
             * based on the given quantity or stepRate values.
             * @param ellipse The Ellipse to get the points from.
             * @param quantity The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.
             * @param stepRate Sets the quantity by getting the circumference of the ellipse and dividing it by the stepRate.
             * @param out An array to insert the points in to. If not provided a new array will be created.
             */
            static GetPoints<O extends Phaser.Geom.Point[]>(ellipse: Phaser.Geom.Ellipse, quantity: integer, stepRate?: number, out?: O): O;

            /**
             * Offsets the Ellipse by the values given.
             * @param ellipse The Ellipse to be offset (translated.)
             * @param x The amount to horizontally offset the Ellipse by.
             * @param y The amount to vertically offset the Ellipse by.
             */
            static Offset<O extends Phaser.Geom.Ellipse>(ellipse: O, x: number, y: number): O;

            /**
             * Offsets the Ellipse by the values given in the `x` and `y` properties of the Point object.
             * @param ellipse The Ellipse to be offset (translated.)
             * @param point The Point object containing the values to offset the Ellipse by.
             */
            static OffsetPoint<O extends Phaser.Geom.Ellipse>(ellipse: O, point: Phaser.Geom.Point | object): O;

            /**
             * Returns a uniformly distributed random point from anywhere within the given Ellipse.
             * @param ellipse The Ellipse to get a random point from.
             * @param out A Point or point-like object to set the random `x` and `y` values in.
             */
            static Random<O extends Phaser.Geom.Point>(ellipse: Phaser.Geom.Ellipse, out?: O): O;

        }

        namespace Intersects {
            /**
             * [description]
             * @param circleA [description]
             * @param circleB [description]
             */
            function CircleToCircle(circleA: Phaser.Geom.Circle, circleB: Phaser.Geom.Circle): boolean;

            /**
             * [description]
             * @param circle [description]
             * @param rect [description]
             */
            function CircleToRectangle(circle: Phaser.Geom.Circle, rect: Phaser.Geom.Rectangle): boolean;

            /**
             * [description]
             * @param rectA [description]
             * @param rectB [description]
             * @param output [description]
             */
            function GetRectangleIntersection<O extends Phaser.Geom.Rectangle>(rectA: Phaser.Geom.Rectangle, rectB: Phaser.Geom.Rectangle, output?: O): O;

            /**
             * [description]
             * @param line [description]
             * @param circle [description]
             * @param nearest [description]
             */
            function LineToCircle(line: Phaser.Geom.Line, circle: Phaser.Geom.Circle, nearest?: Phaser.Geom.Point): boolean;

            /**
             * [description]
             * @param line1 [description]
             * @param line2 [description]
             * @param out [description]
             */
            function LineToLine(line1: Phaser.Geom.Line, line2: Phaser.Geom.Line, out?: Phaser.Geom.Point): boolean;

            /**
             * Checks for intersection between the Line and a Rectangle shape, or a rectangle-like
             * object, with public `x`, `y`, `right` and `bottom` properties, such as a Sprite or Body.
             * 
             * An intersection is considered valid if:
             * 
             * The line starts within, or ends within, the Rectangle.
             * The line segment intersects one of the 4 rectangle edges.
             * 
             * The for the purposes of this function rectangles are considered 'solid'.
             * @param line [description]
             * @param rect [description]
             */
            function LineToRectangle(line: Phaser.Geom.Line, rect: Phaser.Geom.Rectangle | object): boolean;

            /**
             * [description]
             * @param point [description]
             * @param line [description]
             */
            function PointToLine(point: Phaser.Geom.Point, line: Phaser.Geom.Line): boolean;

            /**
             * [description]
             * @param point [description]
             * @param line [description]
             */
            function PointToLineSegment(point: Phaser.Geom.Point, line: Phaser.Geom.Line): boolean;

            /**
             * [description]
             * @param rectA [description]
             * @param rectB [description]
             */
            function RectangleToRectangle(rectA: Phaser.Geom.Rectangle, rectB: Phaser.Geom.Rectangle): boolean;

            /**
             * [description]
             * @param rect [description]
             * @param triangle [description]
             */
            function RectangleToTriangle(rect: Phaser.Geom.Rectangle, triangle: Phaser.Geom.Triangle): boolean;

            /**
             * [description]
             * @param rect [description]
             * @param left [description]
             * @param right [description]
             * @param top [description]
             * @param bottom [description]
             * @param tolerance [description] Default 0.
             */
            function RectangleToValues(rect: Phaser.Geom.Rectangle, left: number, right: number, top: number, bottom: number, tolerance?: number): boolean;

            /**
             * [description]
             * @param triangle [description]
             * @param circle [description]
             */
            function TriangleToCircle(triangle: Phaser.Geom.Triangle, circle: Phaser.Geom.Circle): boolean;

            /**
             * [description]
             * @param triangle [description]
             * @param line [description]
             */
            function TriangleToLine(triangle: Phaser.Geom.Triangle, line: Phaser.Geom.Line): boolean;

            /**
             * [description]
             * @param triangleA [description]
             * @param triangleB [description]
             */
            function TriangleToTriangle(triangleA: Phaser.Geom.Triangle, triangleB: Phaser.Geom.Triangle): boolean;

        }

        /**
         * Defines a Line segment, a part of a line between two endpoints.
         */
        class Line {
            /**
             * 
             * @param x1 The x coordinate of the lines starting point. Default 0.
             * @param y1 The y coordinate of the lines starting point. Default 0.
             * @param x2 The x coordinate of the lines ending point. Default 0.
             * @param y2 The y coordinate of the lines ending point. Default 0.
             */
            constructor(x1?: number, y1?: number, x2?: number, y2?: number);

            /**
             * [description]
             * @param line [description]
             */
            static Angle(line: Phaser.Geom.Line): number;

            /**
             * Using Bresenham's line algorithm this will return an array of all coordinates on this line.
             * The start and end points are rounded before this runs as the algorithm works on integers.
             * @param line [description]
             * @param stepRate [description] Default 1.
             * @param results [description]
             */
            static BresenhamPoints(line: Phaser.Geom.Line, stepRate?: integer, results?: any[]): any[];

            /**
             * [description]
             * @param line [description]
             * @param x [description]
             * @param y [description]
             */
            static CenterOn(line: Phaser.Geom.Line, x: number, y: number): Phaser.Geom.Line;

            /**
             * [description]
             * @param source [description]
             */
            static Clone(source: Phaser.Geom.Line): Phaser.Geom.Line;

            /**
             * [description]
             * @param source [description]
             * @param dest [description]
             */
            static CopyFrom<O extends Phaser.Geom.Line>(source: Phaser.Geom.Line, dest: O): O;

            /**
             * [description]
             * @param line [description]
             * @param toCompare [description]
             */
            static Equals(line: Phaser.Geom.Line, toCompare: Phaser.Geom.Line): boolean;

            /**
             * [description]
             * @param line [description]
             * @param out [description]
             */
            static GetMidPoint<O extends Phaser.Geom.Point>(line: Phaser.Geom.Line, out?: O): O;

            /**
             * [description]
             * @param line [description]
             * @param out [description]
             */
            static GetNormal<O extends Phaser.Geom.Point>(line: Phaser.Geom.Line, out?: O): O;

            /**
             * [description]
             * @param line [description]
             * @param position A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.
             * @param out [description]
             */
            static GetPoint<O extends Phaser.Geom.Point>(line: Phaser.Geom.Line, position: number, out?: O): O;

            /**
             * [description]
             * @param line [description]
             * @param quantity [description]
             * @param stepRate [description]
             * @param out [description]
             */
            static GetPoints<O extends Phaser.Geom.Point[]>(line: Phaser.Geom.Line, quantity: integer, stepRate?: integer, out?: O): O;

            /**
             * [description]
             * @param line [description]
             */
            static Height(line: Phaser.Geom.Line): number;

            /**
             * [description]
             * @param line [description]
             */
            static Length(line: Phaser.Geom.Line): number;

            /**
             * The x coordinate of the lines starting point.
             */
            x1: number;

            /**
             * The y coordinate of the lines starting point.
             */
            y1: number;

            /**
             * The x coordinate of the lines ending point.
             */
            x2: number;

            /**
             * The y coordinate of the lines ending point.
             */
            y2: number;

            /**
             * [description]
             * @param position [description]
             * @param output [description]
             */
            getPoint<O extends Phaser.Geom.Point>(position: number, output?: O): O;

            /**
             * [description]
             * @param quantity [description]
             * @param stepRate [description]
             * @param output [description]
             */
            getPoints<O extends Phaser.Geom.Point>(quantity: integer, stepRate?: integer, output?: O): O;

            /**
             * Get a random Point on the Line.
             * @param point An instance of a Point to be modified.
             */
            getRandomPoint<O extends Phaser.Geom.Point>(point?: O): O;

            /**
             * Set new coordinates for the line endpoints.
             * @param x1 The x coordinate of the lines starting point. Default 0.
             * @param y1 The y coordinate of the lines starting point. Default 0.
             * @param x2 The x coordinate of the lines ending point. Default 0.
             * @param y2 The y coordinate of the lines ending point. Default 0.
             */
            setTo(x1?: number, y1?: number, x2?: number, y2?: number): Phaser.Geom.Line;

            /**
             * Returns a Vector2 object that corresponds to the start of this Line.
             * @param vec2 A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
             */
            getPointA<O extends Phaser.Math.Vector2>(vec2?: O): O;

            /**
             * Returns a Vector2 object that corresponds to the start of this Line.
             * @param vec2 A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.
             */
            getPointB<O extends Phaser.Math.Vector2>(vec2?: O): O;

            /**
             * The left position of the Line.
             */
            left: number;

            /**
             * The right position of the Line.
             */
            right: number;

            /**
             * The top position of the Line.
             */
            top: number;

            /**
             * The bottom position of the Line.
             */
            bottom: number;

            /**
             * [description]
             * @param line [description]
             */
            static NormalAngle(line: Phaser.Geom.Line): number;

            /**
             * [description]
             * @param line [description]
             */
            static NormalX(line: Phaser.Geom.Line): number;

            /**
             * [description]
             * @param line [description]
             */
            static NormalY(line: Phaser.Geom.Line): number;

            /**
             * [description]
             * @param line [description]
             * @param x [description]
             * @param y [description]
             */
            static Offset<O extends Phaser.Geom.Line>(line: O, x: number, y: number): O;

            /**
             * [description]
             * @param line [description]
             */
            static PerpSlope(line: Phaser.Geom.Line): number;

            /**
             * Returns a random point on a given Line.
             * @param line The Line to calculate the random Point on.
             * @param out An instance of a Point to be modified.
             */
            static Random<O extends Phaser.Geom.Point>(line: Phaser.Geom.Line, out?: O): O;

            /**
             * [description]
             * @param lineA [description]
             * @param lineB [description]
             */
            static ReflectAngle(lineA: Phaser.Geom.Line, lineB: Phaser.Geom.Line): number;

            /**
             * [description]
             * @param line [description]
             * @param angle [description]
             */
            static Rotate<O extends Phaser.Geom.Line>(line: O, angle: number): O;

            /**
             * [description]
             * @param line [description]
             * @param point [description]
             * @param angle [description]
             */
            static RotateAroundPoint<O extends Phaser.Geom.Line>(line: O, point: Phaser.Geom.Point | object, angle: number): O;

            /**
             * [description]
             * @param line [description]
             * @param x [description]
             * @param y [description]
             * @param angle [description]
             */
            static RotateAroundXY<O extends Phaser.Geom.Line>(line: O, x: number, y: number, angle: number): O;

            /**
             * [description]
             * @param line [description]
             * @param x [description]
             * @param y [description]
             * @param angle [description]
             * @param length [description]
             */
            static SetToAngle<O extends Phaser.Geom.Line>(line: O, x: number, y: number, angle: number, length: number): O;

            /**
             * [description]
             * @param line [description]
             */
            static Slope(line: Phaser.Geom.Line): number;

            /**
             * [description]
             * @param line [description]
             */
            static Width(line: Phaser.Geom.Line): number;

        }

        /**
         * Defines a Point in 2D space, with an x and y component.
         */
        class Point {
            /**
             * 
             * @param x The x coordinate of this Point. Default 0.
             * @param y The y coordinate of this Point. Default x.
             */
            constructor(x?: number, y?: number);

            /**
             * [description]
             * @param point [description]
             */
            static Ceil<O extends Phaser.Geom.Point>(point: O): O;

            /**
             * [description]
             * @param source [description]
             */
            static Clone(source: Phaser.Geom.Point): Phaser.Geom.Point;

            /**
             * [description]
             * @param source [description]
             * @param dest [description]
             */
            static CopyFrom<O extends Phaser.Geom.Point>(source: Phaser.Geom.Point, dest: O): O;

            /**
             * [description]
             * @param point [description]
             * @param toCompare [description]
             */
            static Equals(point: Phaser.Geom.Point, toCompare: Phaser.Geom.Point): boolean;

            /**
             * [description]
             * @param point [description]
             */
            static Floor<O extends Phaser.Geom.Point>(point: O): O;

            /**
             * [description]
             * @param points [description]
             * @param out [description]
             */
            static GetCentroid<O extends Phaser.Geom.Point>(points: Phaser.Geom.Point[], out?: O): O;

            /**
             * [description]
             * @param point [description]
             */
            static GetMagnitude(point: Phaser.Geom.Point): number;

            /**
             * [description]
             * @param point [description]
             */
            static GetMagnitudeSq(point: Phaser.Geom.Point): number;

            /**
             * Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.
             * @param points [description]
             * @param out [description]
             */
            static GetRectangleFromPoints<O extends Phaser.Geom.Rectangle>(points: Phaser.Geom.Point[], out?: O): O;

            /**
             * [description]
             * @param pointA [description]
             * @param pointB [description]
             * @param t [description] Default 0.
             * @param out [description]
             */
            static Interpolate<O extends Phaser.Geom.Point>(pointA: Phaser.Geom.Point, pointB: Phaser.Geom.Point, t?: number, out?: O): O;

            /**
             * [description]
             * @param point [description]
             */
            static Invert<O extends Phaser.Geom.Point>(point: O): O;

            /**
             * [description]
             * @param point [description]
             * @param out [description]
             */
            static Negative<O extends Phaser.Geom.Point>(point: Phaser.Geom.Point, out?: O): O;

            /**
             * The x coordinate of this Point.
             */
            x: number;

            /**
             * The y coordinate of this Point.
             */
            y: number;

            /**
             * Set the x and y coordinates of the point to the given values.
             * @param x The x coordinate of this Point. Default 0.
             * @param y The y coordinate of this Point. Default x.
             */
            setTo(x?: number, y?: number): Phaser.Geom.Point;

            /**
             * [description]
             * @param pointA [description]
             * @param pointB [description]
             * @param out [description]
             */
            static Project<O extends Phaser.Geom.Point>(pointA: Phaser.Geom.Point, pointB: Phaser.Geom.Point, out?: O): O;

            /**
             * [description]
             * @param pointA [description]
             * @param pointB [description]
             * @param out [description]
             */
            static ProjectUnit<O extends Phaser.Geom.Point>(pointA: Phaser.Geom.Point, pointB: Phaser.Geom.Point, out?: O): O;

            /**
             * [description]
             * @param point [description]
             * @param magnitude [description]
             */
            static SetMagnitude<O extends Phaser.Geom.Point>(point: O, magnitude: number): O;

        }

        /**
         * [description]
         */
        class Polygon {
            /**
             * 
             * @param points [description]
             */
            constructor(points?: Phaser.Geom.Point[]);

            /**
             * [description]
             * @param polygon [description]
             */
            static Clone(polygon: Phaser.Geom.Polygon): Phaser.Geom.Polygon;

            /**
             * [description]
             * @param polygon [description]
             * @param x [description]
             * @param y [description]
             */
            static Contains(polygon: Phaser.Geom.Polygon, x: number, y: number): boolean;

            /**
             * [description]
             * @param polygon [description]
             * @param point [description]
             */
            static ContainsPoint(polygon: Phaser.Geom.Polygon, point: Phaser.Geom.Point): boolean;

            /**
             * [description]
             * @param polygon [description]
             * @param out [description]
             */
            static GetAABB<O extends Phaser.Geom.Rectangle>(polygon: Phaser.Geom.Polygon, out?: O): O;

            /**
             * [description]
             * @param polygon [description]
             * @param output [description]
             */
            static GetNumberArray<O extends number[]>(polygon: Phaser.Geom.Polygon, output?: O): O;

            /**
             * The area of this Polygon.
             */
            area: number;

            /**
             * An array of number pair objects that make up this polygon. I.e. [ {x,y}, {x,y}, {x,y} ]
             */
            points: Phaser.Geom.Point[];

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            contains(x: number, y: number): boolean;

            /**
             * Sets this Polygon to the given points.
             * 
             * The points can be set from a variety of formats:
             * 
             * - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
             * - An array of objects with public x/y properties: `[obj1, obj2, ...]`
             * - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
             * - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
             * 
             * `setTo` may also be called without any arguments to remove all points.
             * @param points [description]
             */
            setTo(points: any[]): Phaser.Geom.Polygon;

            /**
             * Calculates the area of the Polygon. This is available in the property Polygon.area
             */
            calculateArea(): number;

            /**
             * [description]
             * @param polygon [description]
             */
            static Reverse<O extends Phaser.Geom.Polygon>(polygon: O): O;

        }

        /**
         * Encapsulates a 2D rectangle defined by its corner point in the top-left and its extends in x (width) and y (height)
         */
        class Rectangle {
            /**
             * 
             * @param x [description] Default 0.
             * @param y [description] Default 0.
             * @param width [description] Default 0.
             * @param height [description] Default 0.
             */
            constructor(x?: number, y?: number, width?: number, height?: number);

            /**
             * [description]
             * @param rect [description]
             */
            static Area(rect: Phaser.Geom.Rectangle): number;

            /**
             * [description]
             * @param rect [description]
             */
            static Ceil<O extends Phaser.Geom.Rectangle>(rect: O): O;

            /**
             * [description]
             * @param rect [description]
             */
            static CeilAll<O extends Phaser.Geom.Rectangle>(rect: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param x [description]
             * @param y [description]
             */
            static CenterOn<O extends Phaser.Geom.Rectangle>(rect: O, x: number, y: number): O;

            /**
             * [description]
             * @param source [description]
             */
            static Clone(source: Phaser.Geom.Rectangle): Phaser.Geom.Rectangle;

            /**
             * [description]
             * @param rect [description]
             * @param x [description]
             * @param y [description]
             */
            static Contains(rect: Phaser.Geom.Rectangle, x: number, y: number): boolean;

            /**
             * [description]
             * @param rect [description]
             * @param point [description]
             */
            static ContainsPoint(rect: Phaser.Geom.Rectangle, point: Phaser.Geom.Point): boolean;

            /**
             * [description]
             * @param rectA [description]
             * @param rectB [description]
             */
            static ContainsRect(rectA: Phaser.Geom.Rectangle, rectB: Phaser.Geom.Rectangle): boolean;

            /**
             * [description]
             * @param source [description]
             * @param dest [description]
             */
            static CopyFrom<O extends Phaser.Geom.Rectangle>(source: Phaser.Geom.Rectangle, dest: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param out [description]
             */
            static Decompose(rect: Phaser.Geom.Rectangle, out?: any[]): any[];

            /**
             * [description]
             * @param rect [description]
             * @param toCompare [description]
             */
            static Equals(rect: Phaser.Geom.Rectangle, toCompare: Phaser.Geom.Rectangle): boolean;

            /**
             * [description]
             * @param target [description]
             * @param source [description]
             */
            static FitInside<O extends Phaser.Geom.Rectangle>(target: O, source: Phaser.Geom.Rectangle): O;

            /**
             * [description]
             * @param target [description]
             * @param source [description]
             */
            static FitOutside<O extends Phaser.Geom.Rectangle>(target: O, source: Phaser.Geom.Rectangle): O;

            /**
             * [description]
             * @param rect [description]
             */
            static Floor<O extends Phaser.Geom.Rectangle>(rect: O): O;

            /**
             * [description]
             * @param rect [description]
             */
            static FloorAll<O extends Phaser.Geom.Rectangle>(rect: O): O;

            /**
             * [description]
             * @param points [description]
             * @param out [description]
             */
            static FromPoints<O extends Phaser.Geom.Rectangle>(points: any[], out?: O): O;

            /**
             * [description]
             * @param rect [description]
             */
            static GetAspectRatio(rect: Phaser.Geom.Rectangle): number;

            /**
             * [description]
             * @param rect [description]
             * @param out [description]
             */
            static GetCenter<O extends Phaser.Geom.Point>(rect: Phaser.Geom.Rectangle, out?: O): O;

            /**
             * Position is a value between 0 and 1 where 0 = the top-left of the rectangle and 0.5 = the bottom right.
             * @param rectangle [description]
             * @param position [description]
             * @param out [description]
             */
            static GetPoint<O extends Phaser.Geom.Point>(rectangle: Phaser.Geom.Rectangle, position: number, out?: O): O;

            /**
             * [description]
             * @param rectangle [description]
             * @param step [description]
             * @param quantity [description]
             * @param out [description]
             */
            static GetPoints<O extends Phaser.Geom.Point[]>(rectangle: Phaser.Geom.Rectangle, step: number, quantity: integer, out?: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param out [description]
             */
            static GetSize<O extends Phaser.Geom.Point>(rect: Phaser.Geom.Rectangle, out?: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param x [description]
             * @param y [description]
             */
            static Inflate<O extends Phaser.Geom.Rectangle>(rect: O, x: number, y: number): O;

            /**
             * [description]
             * @param rect [description]
             * @param step [description]
             * @param quantity [description]
             * @param out [description]
             */
            static MarchingAnts<O extends Phaser.Geom.Point[]>(rect: Phaser.Geom.Rectangle, step: number, quantity: integer, out?: O): O;

            /**
             * [description]
             * @param target [description]
             * @param points [description]
             */
            static MergePoints<O extends Phaser.Geom.Rectangle>(target: O, points: Phaser.Geom.Point[]): O;

            /**
             * [description]
             * @param target [description]
             * @param source [description]
             */
            static MergeRect<O extends Phaser.Geom.Rectangle>(target: O, source: Phaser.Geom.Rectangle): O;

            /**
             * [description]
             * @param target [description]
             * @param x [description]
             * @param y [description]
             */
            static MergeXY<O extends Phaser.Geom.Rectangle>(target: O, x: number, y: number): O;

            /**
             * [description]
             * @param rect [description]
             * @param x [description]
             * @param y [description]
             */
            static Offset<O extends Phaser.Geom.Rectangle>(rect: O, x: number, y: number): O;

            /**
             * [description]
             * @param rect [description]
             * @param point [description]
             */
            static OffsetPoint<O extends Phaser.Geom.Rectangle>(rect: O, point: Phaser.Geom.Point): O;

            /**
             * [description]
             * @param rectA [description]
             * @param rectB [description]
             */
            static Overlaps(rectA: Phaser.Geom.Rectangle, rectB: Phaser.Geom.Rectangle): boolean;

            /**
             * [description]
             * @param rect [description]
             */
            static Perimeter(rect: Phaser.Geom.Rectangle): number;

            /**
             * [description]
             * @param rectangle [description]
             * @param angle [description]
             * @param out [description]
             */
            static PerimeterPoint<O extends Phaser.Geom.Point>(rectangle: Phaser.Geom.Rectangle, angle: integer, out?: O): O;

            /**
             * [description]
             * @param rect [description]
             * @param out [description]
             */
            static Random<O extends Phaser.Geom.Point>(rect: Phaser.Geom.Rectangle, out: O): O;

            /**
             * [description]
             */
            x: number;

            /**
             * [description]
             */
            y: number;

            /**
             * [description]
             */
            width: number;

            /**
             * [description]
             */
            height: number;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            contains(x: number, y: number): boolean;

            /**
             * [description]
             * @param position [description]
             * @param output [description]
             */
            getPoint<O extends Phaser.Geom.Point>(position: number, output?: O): O;

            /**
             * [description]
             * @param quantity [description]
             * @param stepRate [description]
             * @param output [description]
             */
            getPoints<O extends Phaser.Geom.Point[]>(quantity: integer, stepRate?: number, output?: O): O;

            /**
             * [description]
             * @param point [description]
             */
            getRandomPoint<O extends Phaser.Geom.Point>(point?: O): O;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param height [description]
             */
            setTo(x: number, y: number, width: number, height: number): Phaser.Geom.Rectangle;

            /**
             * [description]
             */
            setEmpty(): Phaser.Geom.Rectangle;

            /**
             * [description]
             * @param x [description]
             * @param y [description] Default x.
             */
            setPosition(x: number, y?: number): Phaser.Geom.Rectangle;

            /**
             * [description]
             * @param width [description]
             * @param height [description] Default width.
             */
            setSize(width: number, height?: number): Phaser.Geom.Rectangle;

            /**
             * [description]
             */
            isEmpty(): boolean;

            /**
             * Returns a Line object that corresponds to the top of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineA<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to the right of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineB<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to the bottom of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineC<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to the left of this Rectangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineD<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * [description]
             */
            left: number;

            /**
             * [description]
             */
            right: number;

            /**
             * [description]
             */
            top: number;

            /**
             * [description]
             */
            bottom: number;

            /**
             * [description]
             */
            centerX: number;

            /**
             * [description]
             */
            centerY: number;

            /**
             * [description]
             * @param rect [description]
             * @param x [description]
             * @param y [description]
             */
            static Scale<O extends Phaser.Geom.Rectangle>(rect: O, x: number, y: number): O;

            /**
             * [description]
             * @param rectA [description]
             * @param rectB [description]
             * @param out [description]
             */
            static Union<O extends Phaser.Geom.Rectangle>(rectA: Phaser.Geom.Rectangle, rectB: Phaser.Geom.Rectangle, out?: O): O;

        }

        /**
         * A triangle is a plane created by connecting three points.
         * 
         * The first two arguments specify the first point, the middle two arguments
         * 
         * specify the second point, and the last two arguments specify the third point.
         */
        class Triangle {
            /**
             * 
             * @param x1 [description] Default 0.
             * @param y1 [description] Default 0.
             * @param x2 [description] Default 0.
             * @param y2 [description] Default 0.
             * @param x3 [description] Default 0.
             * @param y3 [description] Default 0.
             */
            constructor(x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number);

            /**
             * [description]
             * @param triangle [description]
             */
            static Area(triangle: Phaser.Geom.Triangle): number;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param length [description]
             */
            static BuildEquilateral(x: number, y: number, length: number): Phaser.Geom.Triangle;

            /**
             * [description]
             * @param data A flat array of vertice coordinates like [x0,y0, x1,y1, x2,y2, ...]
             * @param holes An array of hole indices if any (e.g. [5, 8] for a 12-vertice input would mean one hole with vertices 5–7 and another with 8–11). Default null.
             * @param scaleX [description] Default 1.
             * @param scaleY [description] Default 1.
             * @param out [description]
             */
            static BuildFromPolygon<O extends Phaser.Geom.Triangle[]>(data: any[], holes?: any[], scaleX?: number, scaleY?: number, out?: O): O;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param width [description]
             * @param height [description]
             */
            static BuildRight(x: number, y: number, width: number, height: number): Phaser.Geom.Triangle;

            /**
             * [description]
             * @param triangle [description]
             * @param x [description]
             * @param y [description]
             * @param centerFunc [description]
             */
            static CenterOn<O extends Phaser.Geom.Triangle>(triangle: O, x: number, y: number, centerFunc?: CenterFunction): O;

            /**
             * [description]
             * @param triangle [description]
             * @param out [description]
             */
            static Centroid<O extends Phaser.Geom.Point>(triangle: Phaser.Geom.Triangle, out?: O): O;

            /**
             * Computes the circumcentre of a triangle. The circumcentre is the centre of
             * the circumcircle, the smallest circle which encloses the triangle. It is also
             * the common intersection point of the perpendicular bisectors of the sides of
             * the triangle, and is the only point which has equal distance to all three
             * vertices of the triangle.
             * @param triangle [description]
             * @param out [description]
             */
            static CircumCenter<O extends Phaser.Math.Vector2>(triangle: Phaser.Geom.Triangle, out?: O): O;

            /**
             * [description]
             * @param triangle [description]
             * @param out [description]
             */
            static CircumCircle<O extends Phaser.Geom.Circle>(triangle: Phaser.Geom.Triangle, out?: O): O;

            /**
             * [description]
             * @param source [description]
             */
            static Clone(source: Phaser.Geom.Triangle): Phaser.Geom.Triangle;

            /**
             * [description]
             * @param triangle [description]
             * @param x [description]
             * @param y [description]
             */
            static Contains(triangle: Phaser.Geom.Triangle, x: number, y: number): boolean;

            /**
             * [description]
             * @param triangle [description]
             * @param points [description]
             * @param returnFirst [description]
             * @param out [description]
             */
            static ContainsArray(triangle: Phaser.Geom.Triangle, points: Phaser.Geom.Point[], returnFirst?: boolean, out?: any[]): Phaser.Geom.Point[];

            /**
             * [description]
             * @param triangle [description]
             * @param point [description]
             */
            static ContainsPoint(triangle: Phaser.Geom.Triangle, point: Phaser.Geom.Point): boolean;

            /**
             * [description]
             * @param source [description]
             * @param dest [description]
             */
            static CopyFrom<O extends Phaser.Geom.Triangle>(source: Phaser.Geom.Triangle, dest: O): O;

            /**
             * [description]
             * @param triangle [description]
             * @param out [description]
             */
            static Decompose(triangle: Phaser.Geom.Triangle, out?: any[]): any[];

            /**
             * [description]
             * @param triangle [description]
             * @param toCompare [description]
             */
            static Equals(triangle: Phaser.Geom.Triangle, toCompare: Phaser.Geom.Triangle): boolean;

            /**
             * [description]
             * @param triangle [description]
             * @param position [description]
             * @param out [description]
             */
            static GetPoint<O extends Phaser.Geom.Point>(triangle: Phaser.Geom.Triangle, position: number, out?: O): O;

            /**
             * [description]
             * @param triangle [description]
             * @param quantity [description]
             * @param stepRate [description]
             * @param out [description]
             */
            static GetPoints<O extends Phaser.Geom.Point>(triangle: Phaser.Geom.Triangle, quantity: integer, stepRate: number, out?: O): O;

            /**
             * [description]
             * @param triangle [description]
             * @param out [description]
             */
            static InCenter<O extends Phaser.Geom.Point>(triangle: Phaser.Geom.Triangle, out?: O): O;

            /**
             * [description]
             * @param triangle [description]
             * @param x [description]
             * @param y [description]
             */
            static Offset<O extends Phaser.Geom.Triangle>(triangle: O, x: number, y: number): O;

            /**
             * [description]
             * @param triangle [description]
             */
            static Perimeter(triangle: Phaser.Geom.Triangle): number;

            /**
             * [description]
             * @param triangle [description]
             * @param out [description]
             */
            static Random<O extends Phaser.Geom.Point>(triangle: Phaser.Geom.Triangle, out?: O): O;

            /**
             * [description]
             * @param triangle [description]
             * @param angle [description]
             */
            static Rotate<O extends Phaser.Geom.Triangle>(triangle: O, angle: number): O;

            /**
             * [description]
             * @param triangle [description]
             * @param point [description]
             * @param angle [description]
             */
            static RotateAroundPoint<O extends Phaser.Geom.Triangle>(triangle: O, point: Phaser.Geom.Point, angle: number): O;

            /**
             * [description]
             * @param triangle [description]
             * @param x [description]
             * @param y [description]
             * @param angle [description]
             */
            static RotateAroundXY<O extends Phaser.Geom.Triangle>(triangle: O, x: number, y: number, angle: number): O;

            /**
             * [description]
             */
            x1: number;

            /**
             * [description]
             */
            y1: number;

            /**
             * [description]
             */
            x2: number;

            /**
             * [description]
             */
            y2: number;

            /**
             * [description]
             */
            x3: number;

            /**
             * [description]
             */
            y3: number;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             */
            contains(x: number, y: number): boolean;

            /**
             * [description]
             * @param position [description]
             * @param output [description]
             */
            getPoint<O extends Phaser.Geom.Point>(position: number, output?: O): O;

            /**
             * [description]
             * @param quantity [description]
             * @param stepRate [description]
             * @param output [description]
             */
            getPoints<O extends Phaser.Geom.Point[]>(quantity: integer, stepRate?: number, output?: O): O;

            /**
             * [description]
             * @param point [description]
             */
            getRandomPoint<O extends Phaser.Geom.Point>(point?: O): O;

            /**
             * [description]
             * @param x1 [description] Default 0.
             * @param y1 [description] Default 0.
             * @param x2 [description] Default 0.
             * @param y2 [description] Default 0.
             * @param x3 [description] Default 0.
             * @param y3 [description] Default 0.
             */
            setTo(x1?: number, y1?: number, x2?: number, y2?: number, x3?: number, y3?: number): Phaser.Geom.Triangle;

            /**
             * Returns a Line object that corresponds to Line A of this Triangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineA<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to Line B of this Triangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineB<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * Returns a Line object that corresponds to Line C of this Triangle.
             * @param line A Line object to set the results in. If `undefined` a new Line will be created.
             */
            getLineC<O extends Phaser.Geom.Line>(line?: O): O;

            /**
             * [description]
             */
            left: number;

            /**
             * [description]
             */
            right: number;

            /**
             * [description]
             */
            top: number;

            /**
             * [description]
             */
            bottom: number;

        }

    }

    namespace Input {
        type InteractiveObject = {
            /**
             * [description]
             */
            gameObject: Phaser.GameObjects.GameObject;
            /**
             * [description]
             */
            enabled: boolean;
            /**
             * [description]
             */
            draggable: boolean;
            /**
             * [description]
             */
            dropZone: boolean;
            /**
             * [description]
             */
            target: Phaser.GameObjects.GameObject;
            /**
             * [description]
             */
            camera: Phaser.Cameras.Scene2D.Camera;
            /**
             * [description]
             */
            hitArea: any;
            /**
             * [description]
             */
            hitAreaCallback: HitAreaCallback;
            /**
             * [description]
             */
            localX: number;
            /**
             * [description]
             */
            localY: number;
            /**
             * [description]
             */
            dragState: 0 | 1 | 2;
            /**
             * [description]
             */
            dragStartX: number;
            /**
             * [description]
             */
            dragStartY: number;
            /**
             * [description]
             */
            dragX: number;
            /**
             * [description]
             */
            dragY: number;
        };

        /**
         * [description]
         * @param gameObject [description]
         * @param hitArea [description]
         * @param hitAreaCallback [description]
         */
        function CreateInteractiveObject(gameObject: Phaser.GameObjects.GameObject, hitArea: any, hitAreaCallback: HitAreaCallback): Phaser.Input.InteractiveObject;

        namespace Gamepad {
            /**
             * [description]
             */
            class Axis {
                /**
                 * 
                 * @param pad [description]
                 * @param index [description]
                 */
                constructor(pad: Phaser.Input.Gamepad.Gamepad, index: integer);

                /**
                 * [description]
                 */
                pad: Phaser.Input.Gamepad.Gamepad;

                /**
                 * [description]
                 */
                events: Phaser.Events.EventEmitter;

                /**
                 * [description]
                 */
                index: integer;

                /**
                 * The raw axis value, between -1 and 1 with 0 being dead center.
                 * Use the method `getValue` to get a normalized value with the threshold applied.
                 */
                value: number;

                /**
                 * Movement tolerance threshold below which axis values are ignored in `getValue`.
                 */
                threshold: number;

                /**
                 * [description]
                 * @param value [description]
                 */
                update(value: number): void;

                /**
                 * Applies threshold to the value and returns it.
                 */
                getValue(): number;

            }

            /**
             * [description]
             */
            class Button {
                /**
                 * 
                 * @param pad [description]
                 * @param index [description]
                 */
                constructor(pad: Phaser.Input.Gamepad.Gamepad, index: integer);

                /**
                 * [description]
                 */
                pad: Phaser.Input.Gamepad.Gamepad;

                /**
                 * [description]
                 */
                events: Phaser.Events.EventEmitter;

                /**
                 * [description]
                 */
                index: integer;

                /**
                 * Between 0 and 1.
                 */
                value: number;

                /**
                 * Can be set for Analogue buttons to enable a 'pressure' threshold before considered as 'pressed'.
                 */
                threshold: number;

                /**
                 * Is the Button being pressed down or not?
                 */
                pressed: boolean;

                /**
                 * [description]
                 * @param data [description]
                 */
                update(data: GamepadButton): void;

            }

            namespace Configs {
                /**
                 * Tatar SNES USB Controller Gamepad Configuration.
                 * USB Gamepad  (STANDARD GAMEPAD Vendor: 0079 Product: 0011)
                 */
                var SNES_USB: object;

                /**
                 * PlayStation DualShock 4 Gamepad Configuration.
                 * Sony PlayStation DualShock 4 (v2) wireless controller
                 */
                var DUALSHOCK_4: object;

                /**
                 * XBox 360 Gamepad Configuration.
                 */
                var XBOX_360: object;

            }

            /**
             * [description]
             */
            class Gamepad {
                /**
                 * 
                 * @param manager [description]
                 * @param id [description]
                 * @param index [description]
                 */
                constructor(manager: Phaser.Input.Gamepad.GamepadManager, id: string, index: number);

                /**
                 * [description]
                 */
                manager: Phaser.Input.Gamepad.GamepadManager;

                /**
                 * [description]
                 */
                id: string;

                /**
                 * [description]
                 */
                index: number;

                /**
                 * [description]
                 */
                connected: boolean;

                /**
                 * [description]
                 */
                timestamp: number;

                /**
                 * [description]
                 */
                buttons: Phaser.Input.Gamepad.Button[];

                /**
                 * [description]
                 */
                axes: Phaser.Input.Gamepad.Axis[];

                /**
                 * [description]
                 * @param data [description]
                 */
                update(data: Gamepad): void;

            }

            /**
             * [description]
             */
            class GamepadManager extends Phaser.Events.EventEmitter {
                /**
                 * 
                 * @param inputManager [description]
                 */
                constructor(inputManager: Phaser.Input.InputManager);

                /**
                 * [description]
                 */
                manager: Phaser.Input.InputManager;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                target: object;

                /**
                 * [description]
                 */
                handler: GamepadHandler;

                /**
                 * [description]
                 */
                gamepads: Phaser.Input.Gamepad.Gamepad[];

                /**
                 * Standard FIFO queue.
                 */
                queue: GamepadEvent[];

                /**
                 * [description]
                 */
                boot(): void;

                /**
                 * [description]
                 */
                startListeners(): void;

                /**
                 * [description]
                 */
                stopListeners(): void;

                /**
                 * [description]
                 */
                disconnectAll(): void;

                /**
                 * [description]
                 * @param pad [description]
                 */
                addPad(pad: Pad): Phaser.Input.Gamepad.Gamepad;

                /**
                 * [description]
                 * @param index [description]
                 * @param pad [description]
                 */
                removePad(index: number, pad: Pad): void;

                /**
                 * [description]
                 * @param pads [description]
                 */
                refreshPads(pads: Pad[]): void;

                /**
                 * [description]
                 */
                getAll(): Phaser.Input.Gamepad.Gamepad[];

                /**
                 * [description]
                 * @param index [description]
                 */
                getPad(index: number): Phaser.Input.Gamepad.Gamepad;

                /**
                 * [description]
                 */
                update(): void;

                /**
                 * [description]
                 */
                destroy(): void;

                /**
                 * The total number of connected game pads.
                 */
                total: number;

            }

        }

        /**
         * [description]
         */
        class InputManager {
            /**
             * 
             * @param game [description]
             * @param config [description]
             */
            constructor(game: Phaser.Game, config: object);

            /**
             * [description]
             */
            game: Phaser.Game;

            /**
             * [description]
             */
            canvas: HTMLCanvasElement;

            /**
             * [description]
             */
            config: object;

            /**
             * [description]
             */
            enabled: boolean;

            /**
             * [description]
             */
            events: Phaser.Events.EventEmitter;

            /**
             * Standard FIFO queue.
             */
            queue: any[];

            /**
             * [description]
             */
            keyboard: Phaser.Input.Keyboard.KeyboardManager;

            /**
             * [description]
             */
            mouse: Phaser.Input.Mouse.MouseManager;

            /**
             * [description]
             */
            touch: Phaser.Input.Touch.TouchManager;

            /**
             * [description]
             */
            gamepad: Phaser.Input.Gamepad.GamepadManager;

            /**
             * [description]
             */
            activePointer: Phaser.Input.Pointer;

            /**
             * [description]
             */
            scale: Object;

            /**
             * If the top-most Scene in the Scene List receives an input it will stop input from
             * propagating any lower down the scene list, i.e. if you have a UI Scene at the top
             * and click something on it, that click will not then be passed down to any other
             * Scene below. Disable this to have input events passed through all Scenes, all the time.
             */
            globalTopOnly: boolean;

            /**
             * [description]
             */
            ignoreEvents: boolean;

            /**
             * [description]
             */
            bounds: Phaser.Geom.Rectangle;

            /**
             * The Boot handler is called by Phaser.Game when it first starts up.
             * The renderer is available by now.
             */
            boot(): void;

            /**
             * [description]
             */
            updateBounds(): void;

            /**
             * [description]
             */
            resize(): void;

            /**
             * [description]
             * @param time [description]
             */
            update(time: number): void;

            /**
             * Will always return an array.
             * Array contains matching Interactive Objects.
             * Array will be empty if no objects were matched.
             * x/y = pointer x/y (un-translated)
             * @param x [description]
             * @param y [description]
             * @param gameObjects [description]
             * @param camera [description]
             * @param output [description]
             */
            hitTest(x: number, y: number, gameObjects: any[], camera: Phaser.Cameras.Scene2D.Camera, output: any[]): any[];

            /**
             * x/y MUST be translated before being passed to this function,
             * unless the gameObject is guaranteed to not be rotated or scaled in any way.
             * @param gameObject [description]
             * @param x [description]
             * @param y [description]
             */
            pointWithinHitArea(gameObject: Phaser.GameObjects.GameObject, x: number, y: number): boolean;

            /**
             * x/y MUST be translated before being passed to this function,
             * unless the gameObject is guaranteed to not be rotated or scaled in any way.
             * @param object [description]
             * @param x [description]
             * @param y [description]
             */
            pointWithinInteractiveObject(object: Phaser.Input.InteractiveObject, x: number, y: number): boolean;

            /**
             * [description]
             * @param pageX [description]
             */
            transformX(pageX: number): number;

            /**
             * [description]
             * @param pageY [description]
             */
            transformY(pageY: number): number;

            /**
             * [description]
             */
            getOffsetX(): number;

            /**
             * [description]
             */
            getOffsetY(): number;

            /**
             * [description]
             */
            getScaleX(): number;

            /**
             * [description]
             */
            getScaleY(): number;

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * [description]
         */
        class InputPlugin extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param scene The Scene that owns this plugin.
             */
            constructor(scene: Phaser.Scene);

            /**
             * The Scene that owns this plugin.
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * [description]
             */
            settings: Phaser.Scenes.Settings.Object;

            /**
             * [description]
             */
            manager: Phaser.Input.InputManager;

            /**
             * [description]
             */
            enabled: boolean;

            /**
             * A reference to this.scene.sys.displayList (set in boot)
             */
            displayList: Phaser.GameObjects.DisplayList;

            /**
             * A reference to the this.scene.sys.cameras (set in boot)
             */
            cameras: null;

            /**
             * [description]
             */
            keyboard: Phaser.Input.Keyboard.KeyboardManager;

            /**
             * [description]
             */
            mouse: Phaser.Input.Mouse.MouseManager;

            /**
             * [description]
             */
            gamepad: Phaser.Input.Gamepad.GamepadManager;

            /**
             * Only fire callbacks and events on the top-most Game Object in the display list (emulating DOM behavior)
             * and ignore any GOs below it, or call them all?
             */
            topOnly: boolean;

            /**
             * How often should the pointer input be checked?
             * Time given in ms
             * Pointer will *always* be checked if it has been moved by the user.
             * This controls how often it will be polled if it hasn't been moved.
             * Set to 0 to poll constantly. Set to -1 to only poll on user movement.
             */
            pollRate: integer;

            /**
             * The distance, in pixels, the pointer has to move while being held down, before it thinks it is being dragged.
             */
            dragDistanceThreshold: number;

            /**
             * The amount of time, in ms, the pointer has to be held down before it thinks it is dragging.
             */
            dragTimeThreshold: number;

            /**
             * [description]
             */
            preUpdate(): void;

            /**
             * [description]
             * @param gameObject [description]
             */
            clear(gameObject: Phaser.GameObjects.GameObject): Phaser.GameObjects.GameObject;

            /**
             * [description]
             * @param gameObject [description]
             */
            disable(gameObject: Phaser.GameObjects.GameObject): void;

            /**
             * [description]
             * @param gameObject [description]
             * @param shape [description]
             * @param callback [description]
             * @param dropZone [description] Default false.
             */
            enable(gameObject: Phaser.GameObjects.GameObject, shape: object, callback: HitAreaCallback, dropZone?: boolean): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param pointer [description]
             */
            hitTestPointer(pointer: Phaser.Input.Pointer): any[];

            /**
             * [description]
             * @param pointer The Pointer to check for events against.
             */
            processDownEvents(pointer: Phaser.Input.Pointer): integer;

            /**
             * [description]
             * @param pointer [description]
             * @param time [description]
             */
            processDragEvents(pointer: number, time: number): integer;

            /**
             * [description]
             * @param pointer The pointer to check for events against.
             */
            processMoveEvents(pointer: Phaser.Input.Pointer): integer;

            /**
             * [description]
             * @param pointer [description]
             */
            processOverOutEvents(pointer: Phaser.Input.Pointer): integer;

            /**
             * [description]
             * @param pointer [description]
             */
            processUpEvents(pointer: Phaser.Input.Pointer): void;

            /**
             * Queues a Game Object for insertion into this Input Manager on the next update.
             * @param child The Game Object to add.
             */
            queueForInsertion(child: Phaser.GameObjects.GameObject): Phaser.Input.InputPlugin;

            /**
             * Queues a Game Object for removal from this Input Manager on the next update.
             * @param child The Game Object to remove.
             */
            queueForRemoval(child: Phaser.GameObjects.GameObject): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to change the draggable state on.
             * @param value Set to `true` if the Game Objects should be made draggable, `false` if they should be unset. Default true.
             */
            setDraggable(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], value?: boolean): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to set the hit area on.
             * @param shape The shape or object to check if the pointer is within for hit area checks.
             * @param callback The 'contains' function to invoke to check if the pointer is within the hit area.
             */
            setHitArea(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], shape?: object, callback?: HitAreaCallback): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to set as having a circle hit area.
             * @param x The center of the circle.
             * @param y The center of the circle.
             * @param radius The radius of the circle.
             * @param callback The hit area callback. If undefined it uses Circle.Contains.
             */
            setHitAreaCircle(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], x: number, y: number, radius: number, callback?: HitAreaCallback): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to set as having an ellipse hit area.
             * @param x The center of the ellipse.
             * @param y The center of the ellipse.
             * @param width The width of the ellipse.
             * @param height The height of the ellipse.
             * @param callback The hit area callback. If undefined it uses Ellipse.Contains.
             */
            setHitAreaEllipse(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], x: number, y: number, width: number, height: number, callback?: HitAreaCallback): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to set as having an ellipse hit area.
             * @param callback The hit area callback. If undefined it uses Rectangle.Contains.
             */
            setHitAreaFromTexture(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], callback?: HitAreaCallback): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to set as having a rectangular hit area.
             * @param x The top-left of the rectangle.
             * @param y The top-left of the rectangle.
             * @param width The width of the rectangle.
             * @param height The height of the rectangle.
             * @param callback The hit area callback. If undefined it uses Rectangle.Contains.
             */
            setHitAreaRectangle(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], x: number, y: number, width: number, height: number, callback?: HitAreaCallback): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param gameObjects An array of Game Objects to set as having a  triangular hit area.
             * @param x1 The x coordinate of the first point of the triangle.
             * @param y1 The y coordinate of the first point of the triangle.
             * @param x2 The x coordinate of the second point of the triangle.
             * @param y2 The y coordinate of the second point of the triangle.
             * @param x3 The x coordinate of the third point of the triangle.
             * @param y3 The y coordinate of the third point of the triangle.
             * @param callback The hit area callback. If undefined it uses Triangle.Contains.
             */
            setHitAreaTriangle(gameObjects: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, callback?: HitAreaCallback): Phaser.Input.InputPlugin;

            /**
             * [description]
             */
            setPollAlways(): Phaser.Input.InputPlugin;

            /**
             * [description]
             */
            setPollOnMove(): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param value [description]
             */
            setPollRate(value: number): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param value [description]
             */
            setGlobalTopOnly(value: boolean): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param value [description]
             */
            setTopOnly(value: boolean): Phaser.Input.InputPlugin;

            /**
             * Given an array of Game Objects, sort the array and return it,
             * so that the objects are in index order with the lowest at the bottom.
             * @param gameObjects [description]
             */
            sortGameObjects(gameObjects: Phaser.GameObjects.GameObject[]): Phaser.GameObjects.GameObject[];

            /**
             * Return the child lowest down the display list (with the smallest index)
             * Will iterate through all parent containers, if present.
             * @param childA The first Game Object to compare.
             * @param childB The second Game Object to compare.
             */
            sortHandlerGO(childA: Phaser.GameObjects.GameObject, childB: Phaser.GameObjects.GameObject): integer;

            /**
             * [description]
             */
            stopPropagation(): Phaser.Input.InputPlugin;

            /**
             * [description]
             * @param time [description]
             * @param delta [description]
             */
            update(time: number, delta: number): void;

            /**
             * The current active input Pointer.
             */
            activePointer: Phaser.Input.Pointer;

            /**
             * The x coordinates of the ActivePointer based on the first camera in the camera list.
             * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
             */
            x: number;

            /**
             * The y coordinates of the ActivePointer based on the first camera in the camera list.
             * This is only safe to use if your game has just 1 non-transformed camera and doesn't use multi-touch.
             */
            y: number;

        }

        namespace Keyboard {
            /**
             * [description]
             * 
             * 
             * 
             * `keys` argument can be:
             * 
             * 
             * 
             * A string (ATARI)
             * 
             * An array of either integers (key codes) or strings, or a mixture of both
             * 
             * An array of objects (such as Key objects) with a public 'keyCode' property
             */
            class KeyCombo {
                /**
                 * 
                 * @param keyboardManager [description]
                 * @param keys [description]
                 * @param config [description]
                 */
                constructor(keyboardManager: Phaser.Input.Keyboard.KeyboardManager, keys: string | integer[] | object[], config?: KeyComboConfig);

                /**
                 * Used internally by the KeyCombo class.
                 * Return `true` if it reached the end of the combo, `false` if not.
                 * @param event [description]
                 * @param combo [description]
                 */
                static AdvanceKeyCombo(event: KeyboardEvent, combo: Phaser.Input.Keyboard.KeyCombo): boolean;

                /**
                 * [description]
                 */
                manager: Phaser.Input.Keyboard.KeyboardManager;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                keyCodes: any[];

                /**
                 * The current keyCode the combo is waiting for.
                 */
                current: integer;

                /**
                 * The current index of the key being waited for in the 'keys' string.
                 */
                index: number;

                /**
                 * The length of this combo (in keycodes)
                 */
                size: number;

                /**
                 * The time the previous key in the combo was matched.
                 */
                timeLastMatched: number;

                /**
                 * Has this Key Combo been matched yet?
                 */
                matched: boolean;

                /**
                 * The time the entire combo was matched.
                 */
                timeMatched: number;

                /**
                 * If they press the wrong key do we reset the combo?
                 */
                resetOnWrongKey: boolean;

                /**
                 * The max delay in ms between each key press. Above this the combo is reset. 0 means disabled.
                 */
                maxKeyDelay: integer;

                /**
                 * If previously matched and they press Key 1 again, will it reset?
                 */
                resetOnMatch: boolean;

                /**
                 * If the combo matches, will it delete itself?
                 */
                deleteOnMatch: boolean;

                /**
                 * [description]
                 */
                onKeyDown: KeyboardKeydownCallback;

                /**
                 * How far complete is this combo? A value between 0 and 1.
                 */
                progress: number;

                /**
                 * [description]
                 */
                destroy(): void;

                /**
                 * Used internally by the KeyCombo class.
                 * @param event [description]
                 * @param combo [description]
                 */
                static ProcessKeyCombo(event: KeyboardEvent, combo: Phaser.Input.Keyboard.KeyCombo): boolean;

                /**
                 * Used internally by the KeyCombo class.
                 * @param combo The KeyCombo to reset.
                 */
                static ResetKeyCombo(combo: Phaser.Input.Keyboard.KeyCombo): Phaser.Input.Keyboard.KeyCombo;

            }

            /**
             * The Keyboard class monitors keyboard input and dispatches keyboard events.
             * 
             * 
             * 
             * _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
             * 
             * See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
             * 
             * 
             * 
             * Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
             * 
             * For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
             * 
             * So please check your extensions before opening Phaser issues.
             */
            class KeyboardManager extends Phaser.Events.EventEmitter {
                /**
                 * 
                 * @param inputManager [description]
                 */
                constructor(inputManager: Phaser.Input.InputManager);

                /**
                 * [description]
                 */
                manager: Phaser.Input.InputManager;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                target: object;

                /**
                 * [description]
                 */
                keys: Phaser.Input.Keyboard.Key[];

                /**
                 * [description]
                 */
                combos: Phaser.Input.Keyboard.KeyCombo[];

                /**
                 * [description]
                 */
                captures: any[];

                /**
                 * [description]
                 */
                queue: KeyboardEvent[];

                /**
                 * [description]
                 */
                handler: KeyboardHandler;

                /**
                 * The Boot handler is called by Phaser.Game when it first starts up.
                 */
                boot(): void;

                /**
                 * [description]
                 */
                startListeners(): void;

                /**
                 * [description]
                 */
                stopListeners(): void;

                /**
                 * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right, and also space and shift.
                 */
                createCursorKeys(): CursorKeys;

                /**
                 * A practical way to create an object containing user selected hotkeys.
                 * 
                 * For example,
                 * 
                 *     addKeys({ 'up': Phaser.Input.Keyboard.KeyCodes.W, 'down': Phaser.Input.Keyboard.KeyCodes.S });
                 * 
                 * would return an object containing properties (`up` and `down`) referring to {@link Phaser.Input.Keyboard.Key} objects.
                 * @param keys [description]
                 */
                addKeys(keys: object): object;

                /**
                 * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
                 * The Key object can then be polled, have events attached to it, etc.
                 * @param keyCode [description]
                 */
                addKey(keyCode: string | integer): Phaser.Input.Keyboard.Key;

                /**
                 * Removes a Key object from the Keyboard manager.
                 * @param keyCode [description]
                 */
                removeKey(keyCode: string | integer): void;

                /**
                 * [description]
                 * @param keyCodes [description]
                 */
                addKeyCapture(keyCodes: string | integer | string[] | integer[]): void;

                /**
                 * [description]
                 * @param keyCodes [description]
                 */
                removeKeyCapture(keyCodes: string | integer | string[] | integer[]): void;

                /**
                 * [description]
                 * @param keys [description]
                 * @param config [description]
                 */
                createCombo(keys: string | integer[] | object[], config: KeyComboConfig): Phaser.Input.Keyboard.KeyCombo;

                /**
                 * [description]
                 */
                update(): void;

                /**
                 * [description]
                 */
                shutdown(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

            /**
             * Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
             * or was pressed down longer ago than then given duration.
             * @param key [description]
             * @param duration [description] Default 50.
             */
            function DownDuration(key: Phaser.Input.Keyboard.Key, duration?: integer): boolean;

            /**
             * The justDown value allows you to test if this Key has just been pressed down or not.
             * When you check this value it will return `true` if the Key is down, otherwise `false`.
             * You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
             * This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.
             * @param key [description]
             */
            function JustDown(key: Phaser.Input.Keyboard.Key): boolean;

            /**
             * The justUp value allows you to test if this Key has just been released or not.
             * When you check this value it will return `true` if the Key is up, otherwise `false`.
             * You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
             * This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.
             * @param key [description]
             */
            function JustUp(key: Phaser.Input.Keyboard.Key): boolean;

            /**
             * A generic Key object which can be passed to the Process functions (and so on)
             * 
             * keycode must be an integer
             */
            class Key {
                /**
                 * 
                 * @param keyCode The keycode of this key.
                 */
                constructor(keyCode: integer);

                /**
                 * The keycode of this key.
                 */
                keyCode: integer;

                /**
                 * The original DOM event.
                 */
                originalEvent: KeyboardEvent;

                /**
                 * Should this Key prevent event propagation?
                 */
                preventDefault: boolean;

                /**
                 * Can this Key be processed?
                 */
                enabled: boolean;

                /**
                 * The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
                 */
                isDown: boolean;

                /**
                 * The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
                 */
                isUp: boolean;

                /**
                 * The down state of the ALT key, if pressed at the same time as this key.
                 */
                altKey: boolean;

                /**
                 * The down state of the CTRL key, if pressed at the same time as this key.
                 */
                ctrlKey: boolean;

                /**
                 * The down state of the SHIFT key, if pressed at the same time as this key.
                 */
                shiftKey: boolean;

                /**
                 * The location of the modifier key. 0 for standard (or unknown), 1 for left, 2 for right, 3 for numpad.
                 */
                location: number;

                /**
                 * The timestamp when the key was last pressed down.
                 */
                timeDown: number;

                /**
                 * The number of milliseconds this key has been held down for.
                 * If the key is down this value holds the duration of that key press and is constantly updated.
                 * If the key is up it holds the duration of the previous down session.
                 */
                duration: number;

                /**
                 * The timestamp when the key was last released.
                 */
                timeUp: number;

                /**
                 * If a key is held down this holds down the number of times the key has 'repeated'.
                 */
                repeats: number;

                /**
                 * Resets this Key object back to its default un-pressed state.
                 */
                static reset(): Phaser.Input.Keyboard.Key;

            }

            /**
             * Keyboard Codes.
             */
            enum KeyCodes {
                BACKSPACE,
                TAB,
                ENTER,
                SHIFT,
                CTRL,
                ALT,
                PAUSE,
                CAPS_LOCK,
                ESC,
                SPACE,
                PAGE_UP,
                PAGE_DOWN,
                END,
                HOME,
                LEFT,
                UP,
                RIGHT,
                DOWN,
                PRINT_SCREEN,
                INSERT,
                DELETE,
                ZERO,
                ONE,
                TWO,
                THREE,
                FOUR,
                FIVE,
                SIX,
                SEVEN,
                EIGHT,
                NINE,
                A,
                B,
                C,
                D,
                E,
                F,
                G,
                H,
                I,
                J,
                K,
                L,
                M,
                N,
                O,
                P,
                Q,
                R,
                S,
                T,
                U,
                V,
                W,
                X,
                Y,
                Z,
                F1,
                F2,
                F3,
                F4,
                F5,
                F6,
                F7,
                F8,
                F9,
                F10,
                F11,
                F12,
                SEMICOLON,
                PLUS,
                COMMA,
                MINUS,
                PERIOD,
                FORWARD_SLASH,
                BACK_SLASH,
                QUOTES,
                BACKTICK,
                OPEN_BRACKET,
                CLOSED_BRACKET,
            }

            /**
             * Used internally by the KeyboardManager.
             * @param key [description]
             * @param event [description]
             */
            function ProcessKeyDown(key: Phaser.Input.Keyboard.Key, event: KeyboardEvent): Phaser.Input.Keyboard.Key;

            /**
             * Used internally by the KeyboardManager.
             * @param key [description]
             * @param event [description]
             */
            function ProcessKeyUp(key: Phaser.Input.Keyboard.Key, event: KeyboardEvent): Phaser.Input.Keyboard.Key;

            /**
             * Returns `true` if the Key was released within the `duration` value given, or `false` if it either isn't up,
             * or was released longer ago than then given duration.
             * @param key [description]
             * @param duration [description] Default 50.
             */
            function UpDuration(key: Phaser.Input.Keyboard.Key, duration?: integer): boolean;

        }

        namespace Mouse {
            /**
             * [description]
             */
            class MouseManager {
                /**
                 * 
                 * @param inputManager [description]
                 */
                constructor(inputManager: Phaser.Input.InputManager);

                /**
                 * [description]
                 */
                manager: Phaser.Input.InputManager;

                /**
                 * If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.
                 */
                capture: boolean;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                target: null;

                /**
                 * [description]
                 */
                handler: MouseHandler;

                /**
                 * If the mouse has been pointer locked successfully this will be set to true.
                 */
                locked: boolean;

                /**
                 * [description]
                 */
                boot(): void;

                /**
                 * [description]
                 */
                disableContextMenu(): Phaser.Input.Mouse.MouseManager;

                /**
                 * If the browser supports it, you can request that the pointer be locked to the browser window.
                 * 
                 * This is classically known as 'FPS controls', where the pointer can't leave the browser until
                 * the user presses an exit key.
                 * 
                 * If the browser successfully enters a locked state, a `POINTER_LOCK_CHANGE_EVENT` will be dispatched,
                 * from the games Input Manager, with an `isPointerLocked` property.
                 * 
                 * It is important to note that pointer lock can only be enabled after an 'engagement gesture',
                 * see: https://w3c.github.io/pointerlock/#dfn-engagement-gesture.
                 */
                requestPointerLock(): void;

                /**
                 * Internal pointerLockChange handler.
                 * @param event The native event from the browser.
                 */
                pointerLockChange(event: MouseHandler): void;

                /**
                 * If the browser supports pointer lock, this will request that the pointer lock is released. If
                 * the browser successfully enters a locked state, a 'POINTER_LOCK_CHANGE_EVENT' will be
                 * dispatched - from the game's input manager - with an `isPointerLocked` property.
                 */
                releasePointerLock(): void;

                /**
                 * [description]
                 */
                startListeners(): void;

                /**
                 * [description]
                 */
                stopListeners(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

        }

        /**
         * [description]
         */
        class Pointer {
            /**
             * 
             * @param manager [description]
             * @param id [description]
             */
            constructor(manager: Phaser.Input.InputManager, id: integer);

            /**
             * [description]
             */
            manager: Phaser.Input.InputManager;

            /**
             * [description]
             */
            id: integer;

            /**
             * [description]
             */
            event: null;

            /**
             * The camera the Pointer interacted with during its last update.
             * A Pointer can only ever interact with one camera at once, which will be the top-most camera
             * in the list should multiple cameras be positioned on-top of each other.
             */
            camera: Phaser.Cameras.Scene2D.Camera;

            /**
             * 0: No button or un-initialized
             * 1: Left button
             * 2: Right button
             * 4: Wheel button or middle button
             * 8: 4th button (typically the "Browser Back" button)
             * 16: 5th button (typically the "Browser Forward" button)
             */
            buttons: number;

            /**
             * [description]
             */
            position: Phaser.Math.Vector2;

            /**
             * X coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.
             */
            downX: number;

            /**
             * Y coordinate of the Pointer when Button 1 (left button), or Touch, was pressed, used for dragging objects.
             */
            downY: number;

            /**
             * Time when Button 1 (left button), or Touch, was pressed, used for dragging objects.
             */
            downTime: number;

            /**
             * X coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.
             */
            upX: number;

            /**
             * Y coordinate of the Pointer when Button 1 (left button), or Touch, was released, used for dragging objects.
             */
            upY: number;

            /**
             * Time when Button 1 (left button), or Touch, was released, used for dragging objects.
             */
            upTime: number;

            /**
             * Is the primary button down? (usually button 0, the left mouse button)
             */
            primaryDown: boolean;

            /**
             * The Drag State of the Pointer:
             * 
             * 0 = Not dragging anything
             * 1 = Being checked if dragging
             * 2 = Dragging something
             */
            dragState: number;

            /**
             * Is _any_ button on this pointer considered as being down?
             */
            isDown: boolean;

            /**
             * [description]
             */
            dirty: boolean;

            /**
             * [description]
             */
            justDown: boolean;

            /**
             * [description]
             */
            justUp: boolean;

            /**
             * [description]
             */
            justMoved: boolean;

            /**
             * Did the previous input event come from a Touch input (true) or Mouse? (false)
             */
            wasTouch: boolean;

            /**
             * If the mouse is locked, the horizontal relative movement of the Pointer in pixels since last frame.
             */
            movementX: number;

            /**
             * If the mouse is locked, the vertical relative movement of the Pointer in pixels since last frame.
             */
            movementY: number;

            /**
             * [description]
             * @param camera [description]
             * @param output [description]
             */
            positionToCamera(camera: Phaser.Cameras.Scene2D.Camera, output?: Phaser.Math.Vector2 | object): Phaser.Math.Vector2 | object;

            /**
             * [description]
             */
            x: number;

            /**
             * [description]
             */
            y: number;

            /**
             * [description]
             */
            reset(): void;

            /**
             * [description]
             * @param event [description]
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             */
            touchmove(event: TouchEvent, time: integer): void;

            /**
             * [description]
             * @param event [description]
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             */
            move(event: MouseEvent, time: integer): void;

            /**
             * [description]
             * @param event [description]
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             */
            down(event: MouseEvent, time: integer): void;

            /**
             * [description]
             * @param event [description]
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             */
            touchstart(event: TouchEvent, time: integer): void;

            /**
             * [description]
             * @param event [description]
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             */
            up(event: MouseEvent, time: integer): void;

            /**
             * [description]
             * @param event [description]
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             */
            touchend(event: TouchEvent, time: integer): void;

            /**
             * [description]
             */
            noButtonDown(): boolean;

            /**
             * [description]
             */
            leftButtonDown(): boolean;

            /**
             * [description]
             */
            rightButtonDown(): boolean;

            /**
             * [description]
             */
            middleButtonDown(): boolean;

            /**
             * [description]
             */
            backButtonDown(): boolean;

            /**
             * [description]
             */
            forwardButtonDown(): boolean;

            /**
             * [description]
             */
            destroy(): void;

        }

        namespace Touch {
            /**
             * [description]
             */
            class TouchManager {
                /**
                 * 
                 * @param inputManager [description]
                 */
                constructor(inputManager: Phaser.Input.InputManager);

                /**
                 * [description]
                 */
                manager: Phaser.Input.InputManager;

                /**
                 * If true the DOM events will have event.preventDefault applied to them, if false they will propagate fully.
                 */
                capture: boolean;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                target: null;

                /**
                 * [description]
                 */
                handler: TouchHandler;

                /**
                 * [description]
                 */
                boot(): void;

                /**
                 * [description]
                 */
                startListeners(): void;

                /**
                 * [description]
                 */
                stopListeners(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

        }

    }

    namespace Loader {
        /**
         * The Loader is idle.
         */
        var LOADER_IDLE: integer;

        /**
         * The Loader is actively loading.
         */
        var LOADER_LOADING: integer;

        /**
         * The Loader is processing files is has loaded.
         */
        var LOADER_PROCESSING: integer;

        /**
         * The Loader has completed loading and processing.
         */
        var LOADER_COMPLETE: integer;

        /**
         * The Loader is shutting down.
         */
        var LOADER_SHUTDOWN: integer;

        /**
         * The Loader has been destroyed.
         */
        var LOADER_DESTROYED: integer;

        /**
         * File is in the load queue but not yet started
         */
        var FILE_PENDING: integer;

        /**
         * File has been started to load by the loader (onLoad called)
         */
        var FILE_LOADING: integer;

        /**
         * File has loaded successfully, awaiting processing
         */
        var FILE_LOADED: integer;

        /**
         * File failed to load
         */
        var FILE_FAILED: integer;

        /**
         * File is being processed (onProcess callback)
         */
        var FILE_PROCESSING: integer;

        /**
         * File is waiting for its linkfile to load.
         */
        var FILE_WAITING_LINKFILE: integer;

        /**
         * The File has errored somehow during processing.
         */
        var FILE_ERRORED: integer;

        /**
         * File has finished processing.
         */
        var FILE_COMPLETE: integer;

        /**
         * File has been destroyed
         */
        var FILE_DESTROYED: integer;

        /**
         * File was populated from local data and doesn't need an HTTP request
         */
        var FILE_POPULATED: integer;

        /**
         * A special Texture Atlas const.
         */
        var TEXTURE_ATLAS_JSON_ARRAY: integer;

        /**
         * A special Texture Atlas const.
         */
        var TEXTURE_ATLAS_JSON_HASH: integer;

        /**
         * [description]
         */
        class File {
            /**
             * 
             * @param fileConfig [description]
             */
            constructor(fileConfig: FileConfig);

            /**
             * The file type string (image, json, etc) for sorting within the Loader.
             */
            type: string;

            /**
             * Unique cache key (unique within its file type)
             */
            key: string;

            /**
             * The URL of the file, not including baseURL.
             */
            url: string;

            /**
             * Set when the Loader calls 'load' on this file.
             */
            src: string;

            /**
             * The merged XHRSettings for this file.
             */
            xhrSettings: XHRSettingsObject;

            /**
             * The LoaderPlugin instance that is loading this file.
             */
            loader: Phaser.Loader.LoaderPlugin;

            /**
             * The XMLHttpRequest instance (as created by XHR Loader) that is loading this File.
             */
            xhrLoader: XMLHttpRequest;

            /**
             * The current state of the file. One of the FILE_CONST values.
             */
            state: integer;

            /**
             * The total size of this file.
             * Set by onProgress and only if loading via XHR.
             */
            bytesTotal: number;

            /**
             * Updated as the file loads.
             * Only set if loading via XHR.
             */
            bytesLoaded: number;

            /**
             * A percentage value between 0 and 1 indicating how much of this file has loaded.
             * Only set if loading via XHR.
             */
            percentComplete: number;

            /**
             * For CORs based loading.
             * If this is undefined then the File will check BaseLoader.crossOrigin and use that (if set)
             */
            crossOrigin: string | undefined;

            /**
             * The processed file data, stored in here after the file has loaded.
             */
            data: any;

            /**
             * A config object that can be used by file types to store transitional data.
             */
            config: object;

            /**
             * If this is a multipart file, i.e. an atlas and its json together, then this is a reference
             * to the linked file. Set and used internally by the Loader.
             */
            linkFile: Phaser.Loader.File;

            /**
             * If this is a multipart file, i.e. an atlas and its json together, then this is a reference
             * to the type of linked association. Set and used internally by the Loader.
             */
            linkType: string;

            /**
             * If this is a link file, is this the parent or the sibbling?
             */
            linkParent: boolean;

            /**
             * If this is a multipart file, i.e. an atlas and its json together, then this is a reference
             * to the linked file. Set and used internally by the Loader.
             * @param fileB The linked file.
             * @param linkType The type of association.
             */
            setLinkFile(fileB: Phaser.Loader.File, linkType: string): void;

            /**
             * Resets the XHRLoader instance.
             */
            resetXHR(): void;

            /**
             * Called by the Loader, starts the actual file downloading.
             * During the load the methods onLoad, onProgress, etc are called based on the XHR events.
             * @param loader The Loader that will load this File.
             */
            load(loader: Phaser.Loader.LoaderPlugin): void;

            /**
             * Called when the file finishes loading, is sent a DOM ProgressEvent.
             * @param event The DOM ProgressEvent that resulted from this load.
             */
            onLoad(event: ProgressEvent): void;

            /**
             * Called if the file errors while loading, is sent a DOM ProgressEvent.
             * @param event The DOM ProgressEvent that resulted from this error.
             */
            onError(event: ProgressEvent): void;

            /**
             * Called during the file load progress. Is sent a DOM ProgressEvent.
             * @param event The DOM ProgressEvent.
             */
            onProgress(event: ProgressEvent): void;

            /**
             * Usually overridden by the FileTypes and is called by Loader.finishedLoading.
             * The callback is Loader.processUpdate
             * @param callback The callback to invoke to process this File.
             */
            onProcess(callback: FileProcessCallback): void;

            /**
             * Called with the File has completed loading.
             * Checks on the state of its linkfile, if set.
             */
            onComplete(): void;

            /**
             * Static method for creating object URL using URL API and setting it as image 'src' attribute.
             * If URL API is not supported (usually on old browsers) it falls back to creating Base64 encoded url using FileReader.
             * @param image Image object which 'src' attribute should be set to object URL.
             * @param blob A Blob object to create an object URL for.
             * @param defaultType Default mime type used if blob type is not available.
             */
            static createObjectURL(image: HTMLImageElement, blob: Blob, defaultType: string): void;

            /**
             * Static method for releasing an existing object URL which was previously created
             * by calling {@link File#createObjectURL} method.
             * @param image Image object which 'src' attribute should be revoked.
             */
            static revokeObjectURL(image: HTMLImageElement): void;

        }

        namespace FileTypes {
            /**
             * An Animation JSON File.
             * @param key The key of the file within the loader.
             * @param url The url to load the file from.
             * @param path The path of the file.
             * @param xhrSettings Optional file specific XHR settings.
             */
            function AnimationJSONFile(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.FileTypes.JSONFile;

            /**
             * An Atlas JSON File.
             * @param key The key of the file within the loader.
             * @param textureURL The url to load the texture file from.
             * @param atlasURL The url to load the atlas file from.
             * @param path The path of the file.
             * @param textureXhrSettings Optional texture file specific XHR settings.
             * @param atlasXhrSettings Optional atlas file specific XHR settings.
             */
            function AtlasJSONFile(key: string, textureURL: string, atlasURL: string, path: string, textureXhrSettings?: XHRSettingsObject, atlasXhrSettings?: XHRSettingsObject): object;

            /**
             * [description]
             */
            class AudioFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 * @param audioContext [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject, audioContext?: AudioContext);

                /**
                 * [description]
                 */
                context: AudioContext;

                /**
                 * [description]
                 * @param callback [description]
                 */
                onProcess(callback: FileProcessCallback): void;

            }

            /**
             * [description]
             */
            class BinaryFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * An Bitmap Font File.
             * @param key The key of the file within the loader.
             * @param textureURL The url to load the texture file from.
             * @param xmlURL The url to load the atlas file from.
             * @param path The path of the file.
             * @param textureXhrSettings Optional texture file specific XHR settings.
             * @param xmlXhrSettings Optional atlas file specific XHR settings.
             */
            function BitmapFontFile(key: string, textureURL: string, xmlURL: string, path: string, textureXhrSettings?: XHRSettingsObject, xmlXhrSettings?: XHRSettingsObject): object;

            /**
             * [description]
             */
            class GLSLFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class HTML5AudioFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param config [description]
                 */
                constructor(key: string, url: string, path: string, config?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class HTMLFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param width [description]
                 * @param height [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, width: number, height: number, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class ImageFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 * @param config [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject, config?: object);

            }

            /**
             * [description]
             */
            class JSONFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class PluginFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class ScriptFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * A Sprite Sheet File.
             * @param key The key of the file within the loader.
             * @param url The url to load the texture file from.
             * @param config Optional texture file specific XHR settings.
             * @param path Optional texture file specific XHR settings.
             * @param xhrSettings Optional atlas file specific XHR settings.
             */
            function SpriteSheetFile(key: string, url: string, config: object, path: string, xhrSettings?: XHRSettingsObject): object;

            /**
             * [description]
             */
            class SVGFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class TextFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * [description]
             */
            class TilemapCSVFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param format [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, format: string, xhrSettings?: XHRSettingsObject);

            }

            /**
             * A Tilemap File.
             * @param key [description]
             * @param url [description]
             * @param path [description]
             * @param format [description]
             * @param xhrSettings [description]
             */
            function TilemapJSONFile(key: string, url: string, path: string, format: string, xhrSettings?: XHRSettingsObject): object;

            /**
             * An Atlas JSON File.
             * @param key The key of the file within the loader.
             * @param textureURL The url to load the texture file from.
             * @param atlasURL The url to load the atlas file from.
             * @param path The path of the file.
             * @param textureXhrSettings Optional texture file specific XHR settings.
             * @param atlasXhrSettings Optional atlas file specific XHR settings.
             */
            function UnityAtlasFile(key: string, textureURL: string, atlasURL: string, path: string, textureXhrSettings?: XHRSettingsObject, atlasXhrSettings?: XHRSettingsObject): object;

            /**
             * [description]
             */
            class XMLFile extends Phaser.Loader.File {
                /**
                 * 
                 * @param key [description]
                 * @param url [description]
                 * @param path [description]
                 * @param xhrSettings [description]
                 */
                constructor(key: string, url: string, path: string, xhrSettings?: XHRSettingsObject);

            }

        }

        /**
         * Given a File and a baseURL value this returns the URL the File will use to download from.
         * @param file The File object.
         * @param baseURL A default base URL.
         */
        function GetURL(file: Phaser.Loader.File, baseURL: string): string;

        /**
         * [description]
         */
        class LoaderPlugin extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * Adds an Animation JSON file to the current load queue.
             * 
             * Note: This method will only be available if the Animation JSON File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key A unique string to be used as the key to reference this file from the Cache. Must be unique within this file type.
             * @param url URL of the file. If `undefined` or `null` the url will be set to `<key>.json`,
             * i.e. if `key` was "alien" then the URL will be "alien.json".
             * @param xhrSettings File specific XHR settings to be used during the load. These settings are merged with the global Loader XHR settings.
             */
            animation(key: string | any[] | object, url?: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Texture Atlas file to the current load queue.
             * 
             * Note: This method will only be available if the Atlas JSON File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key The key of the file within the loader.
             * @param textureURL The url to load the texture file from.
             * @param atlasURL The url to load the atlas file from.
             * @param textureXhrSettings Optional texture file specific XHR settings.
             * @param atlasXhrSettings Optional atlas file specific XHR settings.
             */
            atlas(key: string, textureURL: string, atlasURL: string, textureXhrSettings?: XHRSettingsObject, atlasXhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds an Audio file to the current load queue.
             * 
             * Note: This method will only be available if the Audio File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param urls [description]
             * @param config [description]
             * @param xhrSettings [description]
             */
            audio(key: string, urls: string | string[], config: object, xhrSettings?: object): Phaser.Loader.LoaderPlugin;

            /**
             * Adds an Audio Sprite file to the current load queue.
             * 
             * Note: This method will only be available if the Audio Sprite File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param urls [description]
             * @param json [description]
             * @param config [description]
             * @param audioXhrSettings Optional file specific XHR settings.
             * @param jsonXhrSettings Optional file specific XHR settings.
             */
            audioSprite(key: string, urls: string | string[], json: object, config: object, audioXhrSettings?: XHRSettingsObject, jsonXhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds Binary file to the current load queue.
             * 
             * Note: This method will only be available if the Binary File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            binary(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Bitmap Font file to the current load queue.
             * 
             * Note: This method will only be available if the Bitmap Font File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param textureURL [description]
             * @param xmlURL [description]
             * @param textureXhrSettings [description]
             * @param xmlXhrSettings [description]
             */
            bitmapFont(key: string, textureURL: string, xmlURL: string, textureXhrSettings?: XHRSettingsObject, xmlXhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a GLSL file to the current load queue.
             * 
             * Note: This method will only be available if the GLSL File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            glsl(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds an HTML file to the current load queue.
             * 
             * Note: This method will only be available if the HTML File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param width [description]
             * @param height [description]
             * @param xhrSettings [description]
             */
            html(key: string, url: string, width: number, height: number, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds an Image file to the current load queue.
             * 
             * Note: This method will only be available if the Image File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            image(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a JSON file to the current load queue.
             * 
             * Note: This method will only be available if the JSON File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            json(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Multi File Texture Atlas to the current load queue.
             * 
             * Note: This method will only be available if the Multi Atlas File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param textureURLs [description]
             * @param atlasURLs [description]
             * @param textureXhrSettings [description]
             * @param atlasXhrSettings [description]
             */
            multiatlas(key: string, textureURLs: string[], atlasURLs: string[], textureXhrSettings?: XHRSettingsObject, atlasXhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Plugin file to the current load queue.
             * 
             * Note: This method will only be available if the Plugin File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            plugin(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a JavaScript file to the current load queue.
             * 
             * Note: This method will only be available if the Script File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            script(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Sprite Sheet file to the current load queue.
             * 
             * Note: This method will only be available if the Sprite Sheet File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param config config can include: frameWidth, frameHeight, startFrame, endFrame, margin, spacing.
             * @param xhrSettings [description]
             */
            spritesheet(key: string, url: string, config: object, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds an SVG file to the current load queue.
             * 
             * Note: This method will only be available if the SVG File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            svg(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Text file to the current load queue.
             * 
             * Note: This method will only be available if the Text File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            text(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Tilemap CSV file to the current load queue.
             * 
             * Note: This method will only be available if the Tilemap CSV File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            tilemapCSV(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Tilemap (Tiled JSON Format) file to the current load queue.
             * 
             * Note: This method will only be available if the Tilemap File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            tilemapTiledJSON(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Tilemap (Weltmeister Format) file to the current load queue.
             * 
             * Note: This method will only be available if the Tilemap File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            tilemapWeltmeister(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds a Unity Texture Atlas file to the current load queue.
             * 
             * Note: This method will only be available if the Unity Atlas File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key The key of the file within the loader.
             * @param textureURL The url to load the texture file from.
             * @param atlasURL The url to load the atlas file from.
             * @param textureXhrSettings Optional texture file specific XHR settings.
             * @param atlasXhrSettings Optional atlas file specific XHR settings.
             */
            unityAtlas(key: string, textureURL: string, atlasURL: string, textureXhrSettings?: XHRSettingsObject, atlasXhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * Adds an XML file to the current load queue.
             * 
             * Note: This method will only be available if the XML File type has been built into Phaser.
             * 
             * The file is **not** loaded immediately after calling this method.
             * Instead, the file is added to a queue within the Loader, which is processed automatically when the Loader starts.
             * @param key [description]
             * @param url [description]
             * @param xhrSettings [description]
             */
            xml(key: string, url: string, xhrSettings?: XHRSettingsObject): Phaser.Loader.LoaderPlugin;

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * [description]
             */
            path: string;

            /**
             * [description]
             */
            baseURL: string;

            /**
             * [description]
             */
            enableParallel: boolean;

            /**
             * [description]
             */
            maxParallelDownloads: integer;

            /**
             * xhr specific global settings (can be overridden on a per-file basis)
             */
            xhr: XHRSettingsObject;

            /**
             * [description]
             */
            crossOrigin: string;

            /**
             * [description]
             */
            totalToLoad: number;

            /**
             * [description]
             */
            progress: number;

            /**
             * [description]
             */
            list: Phaser.Structs.Set<Phaser.Loader.File>;

            /**
             * [description]
             */
            inflight: Phaser.Structs.Set<Phaser.Loader.File>;

            /**
             * [description]
             */
            failed: Phaser.Structs.Set<Phaser.Loader.File>;

            /**
             * [description]
             */
            queue: Phaser.Structs.Set<Phaser.Loader.File>;

            /**
             * [description]
             */
            storage: Phaser.Structs.Set<(Phaser.Loader.File|LinkFileObject)>;

            /**
             * [description]
             */
            state: integer;

            /**
             * [description]
             * @param url [description]
             */
            setBaseURL(url: string): Phaser.Loader.LoaderPlugin;

            /**
             * [description]
             * @param path [description]
             */
            setPath(path: string): Phaser.Loader.LoaderPlugin;

            /**
             * [description]
             * @param crossOrigin [description]
             */
            setCORS(crossOrigin: string): Phaser.Loader.LoaderPlugin;

            /**
             * [description]
             * @param file [description]
             */
            addFile(file: Phaser.Loader.File): Phaser.Loader.File;

            /**
             * Is the Loader actively loading (or processing loaded files)
             */
            isLoading(): boolean;

            /**
             * Is the Loader ready to start a new load?
             */
            isReady(): boolean;

            /**
             * [description]
             */
            start(): void;

            /**
             * [description]
             */
            updateProgress(): void;

            /**
             * [description]
             */
            processLoadQueue(): void;

            /**
             * [description]
             * @param file [description]
             */
            loadFile(file: Phaser.Loader.File): void;

            /**
             * [description]
             * @param previousFile [description]
             * @param success [description]
             */
            nextFile(previousFile: Phaser.Loader.File, success: boolean): void;

            /**
             * [description]
             */
            finishedLoading(): void;

            /**
             * Called automatically by the File when it has finished processing.
             * @param file [description]
             */
            processUpdate(file: Phaser.Loader.File): void;

            /**
             * [description]
             * @param file [description]
             */
            removeFromQueue(file: Phaser.Loader.File): void;

            /**
             * [description]
             */
            processComplete(): void;

            /**
             * The Loader has finished.
             */
            processCallback(): void;

            /**
             * [description]
             * @param data [description]
             * @param filename [description] Default file.json.
             */
            saveJSON(data: any, filename?: string): Phaser.Loader.LoaderPlugin;

            /**
             * [description]
             * @param data [description]
             * @param filename [description] Default file.json.
             * @param filetype [description] Default application/json.
             */
            save(data: any, filename?: string, filetype?: string): Phaser.Loader.LoaderPlugin;

            /**
             * [description]
             */
            reset(): void;

            /**
             * [description]
             * @param files [description]
             */
            loadArray(files: LoaderFileObject[]): boolean;

            /**
             * [description]
             * @param file [description]
             */
            file(file: LoaderFileObject): Phaser.Loader.File;

        }

        /**
         * Takes two XHRSettings Objects and creates a new XHRSettings object from them.
         * 
         * The new object is seeded by the values given in the global settings, but any setting in
         * the local object overrides the global ones.
         * @param global The global XHRSettings object.
         * @param local The local XHRSettings object.
         */
        function MergeXHRSettings(global: XHRSettingsObject, local: XHRSettingsObject): XHRSettingsObject;

        /**
         * Creates a new XMLHttpRequest (xhr) object based on the given File and XHRSettings
         * and starts the download of it. It uses the Files own XHRSettings and merges them
         * with the global XHRSettings object to set the xhr values before download.
         * @param file The File to download.
         * @param globalXHRSettings The global XHRSettings object.
         */
        function XHRLoader(file: Phaser.Loader.File, globalXHRSettings: XHRSettingsObject): XMLHttpRequest;

        /**
         * Creates an XHRSettings Object with default values.
         * @param responseType The responseType, such as 'text'. Default ''.
         * @param async Should the XHR request use async or not? Default true.
         * @param user Optional username for the XHR request. Default ''.
         * @param password Optional password for the XHR request. Default ''.
         * @param timeout Optional XHR timeout value. Default 0.
         */
        function XHRSettings(responseType?: XMLHttpRequestResponseType, async?: boolean, user?: string, password?: string, timeout?: integer): XHRSettingsObject;

    }

    namespace Math {
        namespace Angle {
            /**
             * [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            function Between(x1: number, y1: number, x2: number, y2: number): number;

            /**
             * [description]
             * @param point1 [description]
             * @param point2 [description]
             */
            function BetweenPoints(point1: Phaser.Geom.Point | object, point2: Phaser.Geom.Point | object): number;

            /**
             * [description]
             * @param point1 [description]
             * @param point2 [description]
             */
            function BetweenPointsY(point1: Phaser.Geom.Point | object, point2: Phaser.Geom.Point | object): number;

            /**
             * [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            function BetweenY(x1: number, y1: number, x2: number, y2: number): number;

            /**
             * [description]
             * @param angle [description]
             */
            function Normalize(angle: number): number;

            /**
             * [description]
             * @param angle [description]
             */
            function Reverse(angle: number): number;

            /**
             * Rotates `currentAngle` towards `targetAngle`, taking the shortest rotation distance. The `lerp` argument is the amount to rotate by in this call.
             * @param currentAngle The current angle, in radians.
             * @param targetAngle The target angle to rotate to, in radians.
             * @param lerp The lerp value to add to the current angle. Default 0.05.
             */
            function RotateTo(currentAngle: number, targetAngle: number, lerp?: number): number;

            /**
             * Gets the shortest angle between `angle1` and `angle2`.
             * Both angles must be in the range -180 to 180, which is the same clamped
             * range that `sprite.angle` uses, so you can pass in two sprite angles to
             * this method and get the shortest angle back between the two of them.
             * 
             * The angle returned will be in the same range. If the returned angle is
             * greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
             * a clockwise rotation.
             * @param angle1 The first angle in the range -180 to 180.
             * @param angle2 The second angle in the range -180 to 180.
             */
            function ShortestBetween(angle1: number, angle2: number): number;

            /**
             * [description]
             * @param angle [description]
             */
            function Wrap(angle: number): number;

            /**
             * [description]
             * @param angle [description]
             */
            function WrapDegrees(angle: number): number;

        }

        /**
         * [description]
         * @param values [description]
         */
        function Average(values: number[]): number;

        /**
         * [description]
         * @param n [description]
         * @param i [description]
         */
        function Bernstein(n: number, i: number): number;

        /**
         * [description]
         * @param min [description]
         * @param max [description]
         */
        function Between(min: integer, max: integer): integer;

        /**
         * [description]
         * @param t [description]
         * @param p0 [description]
         * @param p1 [description]
         * @param p2 [description]
         * @param p3 [description]
         */
        function CatmullRom(t: number, p0: number, p1: number, p2: number, p3: number): number;

        /**
         * [description]
         * @param value [description]
         * @param place [description] Default 0.
         * @param base [description] Default 10.
         */
        function CeilTo(value: number, place?: number, base?: integer): number;

        /**
         * Force a value within the boundaries by clamping it to the range `min`, `max`.
         * @param value The value to be clamped.
         * @param min The minimum bounds.
         * @param max The maximum bounds.
         */
        function Clamp(value: number, min: number, max: number): number;

        /**
         * The value of PI * 2.
         */
        var PI2: number;

        /**
         * The value of PI * 0.5.
         */
        var TAU: number;

        /**
         * An epsilon value (1.0e-6)
         */
        var EPSILON: number;

        /**
         * For converting degrees to radians (PI / 180)
         */
        var DEG_TO_RAD: number;

        /**
         * For converting radians to degrees (180 / PI)
         */
        var RAD_TO_DEG: number;

        /**
         * An instance of the Random Number Generator.
         */
        var RND: Phaser.Math.RandomDataGenerator;

        /**
         * [description]
         * @param degrees [description]
         */
        function DegToRad(degrees: integer): number;

        /**
         * [description]
         * @param a [description]
         * @param b [description]
         */
        function Difference(a: number, b: number): number;

        namespace Distance {
            /**
             * [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            function Between(x1: number, y1: number, x2: number, y2: number): number;

            /**
             * [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             * @param pow [description]
             */
            function Power(x1: number, y1: number, x2: number, y2: number, pow: number): number;

            /**
             * [description]
             * @param x1 [description]
             * @param y1 [description]
             * @param x2 [description]
             * @param y2 [description]
             */
            function Squared(x1: number, y1: number, x2: number, y2: number): number;

        }

        namespace Easing {
            namespace Back {
                /**
                 * [description]
                 * @param v [description]
                 * @param overshoot [description] Default 1.70158.
                 */
                function In(v: number, overshoot?: number): number;

                /**
                 * [description]
                 * @param v [description]
                 * @param overshoot [description] Default 1.70158.
                 */
                function InOut(v: number, overshoot?: number): number;

                /**
                 * [description]
                 * @param v [description]
                 * @param overshoot [description] Default 1.70158.
                 */
                function Out(v: number, overshoot?: number): number;

            }

            namespace Bounce {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Circular {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Cubic {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Elastic {
                /**
                 * [description]
                 * @param v [description]
                 * @param amplitude [description] Default 0.1.
                 * @param period [description] Default 0.1.
                 */
                function In(v: number, amplitude?: number, period?: number): number;

                /**
                 * [description]
                 * @param v [description]
                 * @param amplitude [description] Default 0.1.
                 * @param period [description] Default 0.1.
                 */
                function InOut(v: number, amplitude?: number, period?: number): number;

                /**
                 * [description]
                 * @param v [description]
                 * @param amplitude [description] Default 0.1.
                 * @param period [description] Default 0.1.
                 */
                function Out(v: number, amplitude?: number, period?: number): number;

            }

            namespace Expo {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Linear {
                /**
                 * [description]
                 * @param v [description]
                 */
                function Linear(v: number): number;

            }

            namespace Quadratic {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Quartic {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Quintic {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Sine {
                /**
                 * [description]
                 * @param v [description]
                 */
                function In(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function InOut(v: number): number;

                /**
                 * [description]
                 * @param v [description]
                 */
                function Out(v: number): number;

            }

            namespace Stepped {
                /**
                 * [description]
                 * @param v [description]
                 * @param steps [description] Default 1.
                 */
                function Stepped(v: number, steps?: number): number;

            }

        }

        /**
         * [description]
         * @param value [description]
         */
        function Factorial(value: number): number;

        /**
         * [description]
         * @param min [description]
         * @param max [description]
         */
        function FloatBetween(min: number, max: number): number;

        /**
         * [description]
         * @param value [description]
         * @param place  Default 0 - [description.
         * @param base [description] Default 10.
         */
        function FloorTo(value: number, place?: integer, base?: integer): number;

        /**
         * Return a value based on the range between `min` and `max` and the percentage given.
         * @param percent A value between 0 and 1 representing the percentage.
         * @param min [description]
         * @param max [description]
         */
        function FromPercent(percent: number, min: number, max?: number): number;

        namespace Fuzzy {
            /**
             * [description]
             * @param value [description]
             * @param epsilon [description] Default 0.0001.
             */
            function Ceil(value: number, epsilon?: number): number;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             * @param epsilon [description] Default 0.0001.
             */
            function Equal(a: number, b: number, epsilon?: number): boolean;

            /**
             * [description]
             * @param value [description]
             * @param epsilon [description] Default 0.0001.
             */
            function Floor(value: number, epsilon?: number): number;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             * @param epsilon [description] Default 0.0001.
             */
            function GreaterThan(a: number, b: number, epsilon?: number): boolean;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             * @param epsilon [description] Default 0.0001.
             */
            function LessThan(a: number, b: number, epsilon?: number): boolean;

        }

        /**
         * [description]
         * @param distance The distance to travel in pixels.
         * @param time The time, in ms, to cover the distance in.
         */
        function GetSpeed(distance: number, time: integer): number;

        namespace Interpolation {
            /**
             * [description]
             * @param v [description]
             * @param k [description]
             */
            function Bezier(v: number, k: number): number;

            /**
             * [description]
             * @param v [description]
             * @param k [description]
             */
            function CatmullRom(v: number, k: number): number;

            /**
             * [description]
             * @param t [description]
             * @param p0 [description]
             * @param p1 [description]
             * @param p2 [description]
             * @param p3 [description]
             */
            function CubicBezier(t: number, p0: number, p1: number, p2: number, p3: number): number;

            /**
             * A Linear Interpolation Method.
             * @param v The input array of values to interpolate between.
             * @param k The percentage of interploation, between 0 and 1.
             */
            function Linear(v: number[], k: number): number;

            /**
             * [description]
             * @param t [description]
             * @param p0 [description]
             * @param p1 [description]
             * @param p2 [description]
             */
            function QuadraticBezier(t: number, p0: number, p1: number, p2: number): number;

        }

        /**
         * [description]
         * @param value [description]
         */
        function IsEven(value: number): boolean;

        /**
         * [description]
         * @param value [description]
         */
        function IsEvenStrict(value: number): boolean;

        /**
         * Calculates a linear (interpolation) value over t.
         * @param p0 The first point
         * @param p1 The second point
         * @param t The percentage between p0 and p1 to return represented as a number between 0 and 1.
         */
        function Linear(p0: number, p1: number, t: number): number;

        /**
         * [description]
         */
        class Matrix3 {
            /**
             * 
             * @param m [description]
             */
            constructor(m?: Phaser.Math.Matrix3);

            /**
             * [description]
             */
            val: Float32Array;

            /**
             * [description]
             */
            clone(): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param src [description]
             */
            set(src: Phaser.Math.Matrix3): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param src [description]
             */
            copy(src: Phaser.Math.Matrix3): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param m [description]
             */
            fromMat4(m: Phaser.Math.Matrix4): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param a [description]
             */
            fromArray(a: any[]): Phaser.Math.Matrix3;

            /**
             * [description]
             */
            identity(): Phaser.Math.Matrix3;

            /**
             * [description]
             */
            transpose(): Phaser.Math.Matrix3;

            /**
             * [description]
             */
            invert(): Phaser.Math.Matrix3;

            /**
             * [description]
             */
            adjoint(): Phaser.Math.Matrix3;

            /**
             * [description]
             */
            determinant(): number;

            /**
             * [description]
             * @param src [description]
             */
            multiply(src: Phaser.Math.Matrix3): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param v [description]
             */
            translate(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param rad [description]
             */
            rotate(rad: number): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param v [description]
             */
            scale(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param q [description]
             */
            fromQuat(q: Phaser.Math.Quaternion): Phaser.Math.Matrix3;

            /**
             * [description]
             * @param m [description]
             */
            normalFromMat4(m: Phaser.Math.Matrix4): Phaser.Math.Matrix3;

        }

        /**
         * [description]
         */
        class Matrix4 {
            /**
             * 
             * @param m [description]
             */
            constructor(m?: Phaser.Math.Matrix4);

            /**
             * [description]
             */
            val: Float32Array;

            /**
             * [description]
             */
            clone(): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param src [description]
             */
            set(src: Phaser.Math.Matrix4): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param src [description]
             */
            copy(src: Phaser.Math.Matrix4): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param a [description]
             */
            fromArray(a: any[]): Phaser.Math.Matrix4;

            /**
             * [description]
             */
            zero(): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param z [description]
             */
            xyz(x: number, y: number, z: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param z [description]
             */
            scaling(x: number, y: number, z: number): Phaser.Math.Matrix4;

            /**
             * [description]
             */
            identity(): Phaser.Math.Matrix4;

            /**
             * [description]
             */
            transpose(): Phaser.Math.Matrix4;

            /**
             * [description]
             */
            invert(): Phaser.Math.Matrix4;

            /**
             * [description]
             */
            adjoint(): Phaser.Math.Matrix4;

            /**
             * [description]
             */
            determinant(): number;

            /**
             * [description]
             * @param src [description]
             */
            multiply(src: Phaser.Math.Matrix4): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param src [description]
             */
            multiplyLocal(src: Phaser.Math.Matrix4): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param v [description]
             */
            translate(v: Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param v [description]
             */
            scale(v: Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param axis [description]
             * @param angle The angle of rotation in radians.
             */
            makeRotationAxis(axis: Phaser.Math.Vector3 | Phaser.Math.Vector4, angle: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param rad [description]
             * @param axis [description]
             */
            rotate(rad: number, axis: Phaser.Math.Vector3): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param rad [description]
             */
            rotateX(rad: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param rad [description]
             */
            rotateY(rad: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param rad [description]
             */
            rotateZ(rad: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param q [description]
             * @param v [description]
             */
            fromRotationTranslation(q: Phaser.Math.Quaternion, v: Phaser.Math.Vector3): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param q [description]
             */
            fromQuat(q: Phaser.Math.Quaternion): Phaser.Math.Matrix4;

            /**
             * Generates a frustum matrix with the given bounds.
             * @param left The left bound of the frustum.
             * @param right The right bound of the frustum.
             * @param bottom The bottom bound of the frustum.
             * @param top The top bound of the frustum.
             * @param near The near bound of the frustum.
             * @param far The far bound of the frustum.
             */
            frustum(left: number, right: number, bottom: number, top: number, near: number, far: number): Phaser.Math.Matrix4;

            /**
             * Generates a perspective projection matrix with the given bounds.
             * perspective fov lh
             * @param fovy Vertical field of view in radians
             * @param aspect Aspect ratio. Typically viewport width  /height.
             * @param near Near bound of the frustum.
             * @param far Far bound of the frustum.
             */
            perspective(fovy: number, aspect: number, near: number, far: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param width [description]
             * @param height [description]
             * @param near Near bound of the frustum.
             * @param far Far bound of the frustum.
             */
            perspectiveLH(width: number, height: number, near: number, far: number): Phaser.Math.Matrix4;

            /**
             * Generates a orthogonal projection matrix with the given bounds.
             * @param left The left bound of the frustum.
             * @param right The right bound of the frustum.
             * @param bottom The bottom bound of the frustum.
             * @param top The top bound of the frustum.
             * @param near The near bound of the frustum.
             * @param far The far bound of the frustum.
             */
            ortho(left: number, right: number, bottom: number, top: number, near: number, far: number): Phaser.Math.Matrix4;

            /**
             * Generates a look-at matrix with the given eye position, focal point, and up axis.
             * @param eye Position of the viewer
             * @param center Point the viewer is looking at
             * @param up vec3 pointing up.
             */
            lookAt(eye: Phaser.Math.Vector3, center: Phaser.Math.Vector3, up: Phaser.Math.Vector3): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param yaw [description]
             * @param pitch [description]
             * @param roll [description]
             */
            yawPitchRoll(yaw: number, pitch: number, roll: number): Phaser.Math.Matrix4;

            /**
             * [description]
             * @param rotation [description]
             * @param position [description]
             * @param scale [description]
             * @param viewMatrix [description]
             * @param projectionMatrix [description]
             */
            setWorldMatrix(rotation: Phaser.Math.Vector3, position: Phaser.Math.Vector3, scale: Phaser.Math.Vector3, viewMatrix?: Phaser.Math.Matrix4, projectionMatrix?: Phaser.Math.Matrix4): Phaser.Math.Matrix4;

        }

        /**
         * [description]
         * @param value [description]
         * @param amount [description]
         * @param max [description]
         */
        function MaxAdd(value: number, amount: number, max: number): number;

        /**
         * [description]
         * @param value [description]
         * @param amount [description]
         * @param min [description]
         */
        function MinSub(value: number, amount: number, min: number): number;

        /**
         * Work out what percentage `value` is of the range between `min` and `max`.
         * If `max` isn't given then it will return the percentage of `value` to `min`.
         * 
         * You can optionally specify an `upperMax` value, which is a mid-way point in the range that represents 100%, after which the % starts to go down to zero again.
         * @param value [description]
         * @param min [description]
         * @param max [description]
         * @param upperMax [description]
         */
        function Percent(value: number, min: number, max?: number, upperMax?: number): number;

        namespace Pow2 {
            /**
             * Returns the nearest power of 2 to the given `value`.
             * @param value [description]
             */
            function GetPowerOfTwo(value: number): integer;

            /**
             * Checks if the given `width` and `height` are a power of two.
             * Useful for checking texture dimensions.
             * @param width The width.
             * @param height The height.
             */
            function IsSizePowerOfTwo(width: number, height: number): boolean;

            /**
             * Tests the value and returns `true` if it is a power of two.
             * @param value The value to check if it's a power of two.
             */
            function IsValuePowerOfTwo(value: number): boolean;

        }

        /**
         * [description]
         */
        class Quaternion {
            /**
             * 
             * @param x [description]
             * @param y [description]
             * @param z [description]
             * @param w [description]
             */
            constructor(x?: number, y?: number, z?: number, w?: number);

            /**
             * The x component of this Quaternion.
             */
            x: number;

            /**
             * The y component of this Quaternion.
             */
            y: number;

            /**
             * The z component of this Quaternion.
             */
            z: number;

            /**
             * The w component of this Quaternion.
             */
            w: number;

            /**
             * [description]
             * @param src [description]
             */
            copy(src: Phaser.Math.Quaternion | Phaser.Math.Vector4): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param x [description] Default 0.
             * @param y [description] Default 0.
             * @param z [description] Default 0.
             * @param w [description] Default 0.
             */
            set(x?: number | object, y?: number, z?: number, w?: number): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param v [description]
             */
            add(v: Phaser.Math.Quaternion | Phaser.Math.Vector4): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param v [description]
             */
            subtract(v: Phaser.Math.Quaternion | Phaser.Math.Vector4): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param scale [description]
             */
            scale(scale: number): Phaser.Math.Quaternion;

            /**
             * [description]
             */
            length(): number;

            /**
             * [description]
             */
            lengthSq(): number;

            /**
             * [description]
             */
            normalize(): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param v [description]
             */
            dot(v: Phaser.Math.Quaternion | Phaser.Math.Vector4): number;

            /**
             * [description]
             * @param v [description]
             * @param t [description] Default 0.
             */
            lerp(v: Phaser.Math.Quaternion | Phaser.Math.Vector4, t?: number): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             */
            rotationTo(a: Phaser.Math.Vector3, b: Phaser.Math.Vector3): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param view [description]
             * @param right [description]
             * @param up [description]
             */
            setAxes(view: Phaser.Math.Vector3, right: Phaser.Math.Vector3, up: Phaser.Math.Vector3): Phaser.Math.Quaternion;

            /**
             * [description]
             */
            identity(): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param axis [description]
             * @param rad [description]
             */
            setAxisAngle(axis: Phaser.Math.Vector3, rad: number): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param b [description]
             */
            multiply(b: Phaser.Math.Quaternion | Phaser.Math.Vector4): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param b [description]
             * @param t [description]
             */
            slerp(b: Phaser.Math.Quaternion | Phaser.Math.Vector4, t: number): Phaser.Math.Quaternion;

            /**
             * [description]
             */
            invert(): Phaser.Math.Quaternion;

            /**
             * [description]
             */
            conjugate(): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param rad [description]
             */
            rotateX(rad: number): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param rad [description]
             */
            rotateY(rad: number): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param rad [description]
             */
            rotateZ(rad: number): Phaser.Math.Quaternion;

            /**
             * [description]
             */
            calculateW(): Phaser.Math.Quaternion;

            /**
             * [description]
             * @param mat [description]
             */
            fromMat3(mat: Phaser.Math.Matrix3): Phaser.Math.Quaternion;

        }

        /**
         * [description]
         * @param radians [description]
         */
        function RadToDeg(radians: number): integer;

        /**
         * [description]
         */
        class RandomDataGenerator {
            /**
             * 
             * @param seeds [description]
             */
            constructor(seeds?: string[]);

            /**
             * [description]
             */
            signs: number[];

            /**
             * [description]
             * @param seeds [description]
             */
            init(seeds: string | string[]): void;

            /**
             * Reset the seed of the random data generator.
             * 
             * _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
             * @param seeds The array of seeds: the `toString()` of each value is used.
             */
            sow(seeds: string[]): void;

            /**
             * Returns a random integer between 0 and 2^32.
             */
            integer(): number;

            /**
             * Returns a random real number between 0 and 1.
             */
            frac(): number;

            /**
             * Returns a random real number between 0 and 2^32.
             */
            real(): number;

            /**
             * Returns a random integer between and including min and max.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            integerInRange(min: number, max: number): number;

            /**
             * Returns a random integer between and including min and max.
             * This method is an alias for RandomDataGenerator.integerInRange.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            between(min: number, max: number): number;

            /**
             * Returns a random real number between min and max.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            realInRange(min: number, max: number): number;

            /**
             * Returns a random real number between -1 and 1.
             */
            normal(): number;

            /**
             * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
             */
            uuid(): string;

            /**
             * Returns a random element from within the given array.
             * @param array The array to pick a random element from.
             */
            pick(array: any[]): any;

            /**
             * Returns a sign to be used with multiplication operator.
             */
            sign(): number;

            /**
             * Returns a random element from within the given array, favoring the earlier entries.
             * @param array The array to pick a random element from.
             */
            weightedPick(array: any[]): any;

            /**
             * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
             * @param min The minimum value in the range.
             * @param max The maximum value in the range.
             */
            timestamp(min: number, max: number): number;

            /**
             * Returns a random angle between -180 and 180.
             */
            angle(): number;

            /**
             * Returns a random rotation in radians, between -3.141 and 3.141
             */
            rotation(): number;

            /**
             * Gets or Sets the state of the generator. This allows you to retain the values
             * that the generator is using between games, i.e. in a game save file.
             * 
             * To seed this generator with a previously saved state you can pass it as the
             * `seed` value in your game config, or call this method directly after Phaser has booted.
             * 
             * Call this method with no parameters to return the current state.
             * 
             * If providing a state it should match the same format that this method
             * returns, which is a string with a header `!rnd` followed by the `c`,
             * `s0`, `s1` and `s2` values respectively, each comma-delimited.
             * @param state Generator state to be set.
             */
            state(state?: string): string;

        }

        /**
         * [description]
         * @param vector [description]
         * @param scale [description]
         */
        function RandomXY(vector: Phaser.Math.Vector2, scale: number): Phaser.Math.Vector2;

        /**
         * [description]
         * @param vec3 [description]
         * @param radius [description] Default 1.
         */
        function RandomXYZ(vec3: Phaser.Math.Vector3, radius?: number): Phaser.Math.Vector3;

        /**
         * [description]
         * @param vec4 [description]
         * @param scale [description] Default 1.
         */
        function RandomXYZW(vec4: Phaser.Math.Vector4, scale?: number): Phaser.Math.Vector4;

        /**
         * [description]
         * @param point [description]
         * @param angle [description]
         */
        function Rotate(point: Phaser.Geom.Point | object, angle: number): Phaser.Geom.Point;

        /**
         * [description]
         * @param point [description]
         * @param x [description]
         * @param y [description]
         * @param angle [description]
         */
        function RotateAround(point: Phaser.Geom.Point | object, x: number, y: number, angle: number): Phaser.Geom.Point;

        /**
         * [description]
         * @param point The Point to be rotated.
         * @param x The horizontal coordinate to rotate around.
         * @param y The vertical coordinate to rotate around.
         * @param angle The angle of rotation in radians.
         * @param distance [description]
         */
        function RotateAroundDistance(point: Phaser.Geom.Point | object, x: number, y: number, angle: number, distance: number): Phaser.Geom.Point;

        /**
         * Rotates a vector in place by axis angle.
         * 
         * This is the same as transforming a point by an 
         * axis-angle quaternion, but it has higher precision.
         * @param vec [description]
         * @param axis [description]
         * @param radians [description]
         */
        function RotateVec3(vec: Phaser.Math.Vector3, axis: Phaser.Math.Vector3, radians: number): Phaser.Math.Vector3;

        /**
         * [description]
         * @param value [description]
         */
        function RoundAwayFromZero(value: number): number;

        /**
         * [description]
         * @param value [description]
         * @param place [description] Default 0.
         * @param base [description] Default 10.
         */
        function RoundTo(value: number, place?: integer, base?: integer): number;

        /**
         * [description]
         * @param length [description]
         * @param sinAmp [description]
         * @param cosAmp [description]
         * @param frequency [description]
         */
        function SinCosTableGenerator(length: number, sinAmp: number, cosAmp: number, frequency: number): SinCosTable;

        /**
         * [description]
         * @param x [description]
         * @param min [description]
         * @param max [description]
         */
        function SmootherStep(x: number, min: number, max: number): number;

        /**
         * [description]
         * @param x [description]
         * @param min [description]
         * @param max [description]
         */
        function SmoothStep(x: number, min: number, max: number): number;

        namespace Snap {
            /**
             * [description]
             * @param value [description]
             * @param gap [description]
             * @param start [description] Default 0.
             */
            function Ceil(value: number, gap: number, start?: number): number;

            /**
             * [description]
             * @param value [description]
             * @param gap [description]
             * @param start [description] Default 0.
             */
            function Floor(value: number, gap: number, start?: number): number;

            /**
             * [description]
             * @param value [description]
             * @param gap [description]
             * @param start [description] Default 0.
             */
            function To(value: number, gap: number, start?: number): number;

        }

        /**
         * Takes the `x` and `y` coordinates and transforms them into the same space as
         * defined by the position, rotation and scale values.
         * @param x The x coordinate to be transformed.
         * @param y The y coordinate to be transformed.
         * @param positionX Horizontal position of the transform point.
         * @param positionY Vertical position of the transform point.
         * @param rotation Rotation of the transform point, in radians.
         * @param scaleX Horizontal scale of the transform point.
         * @param scaleY Vertical scale of the transform point.
         * @param output [description]
         */
        function TransformXY(x: number, y: number, positionX: number, positionY: number, rotation: number, scaleX: number, scaleY: number, output?: Phaser.Math.Vector2 | Phaser.Geom.Point | object): Phaser.Math.Vector2 | Phaser.Geom.Point | object;

        /**
         * [description]
         */
        class Vector2 {
            /**
             * 
             * @param x [description]
             * @param y [description]
             */
            constructor(x?: number, y?: number);

            /**
             * The x component of this Vector.
             */
            x: number;

            /**
             * The y component of this Vector.
             */
            y: number;

            /**
             * [description]
             */
            clone(): Phaser.Math.Vector2;

            /**
             * [description]
             * @param src [description]
             */
            copy(src: Phaser.Math.Vector2): Phaser.Math.Vector2;

            /**
             * [description]
             * @param obj [description]
             */
            setFromObject(obj: Vector2Like): Phaser.Math.Vector2;

            /**
             * [description]
             * @param x [description]
             * @param y [description] Default x.
             */
            set(x: number, y?: number): Phaser.Math.Vector2;

            /**
             * This method is an alias for `Vector2.set`.
             * @param x [description]
             * @param y [description] Default x.
             */
            setTo(x: number, y?: number): Phaser.Math.Vector2;

            /**
             * Sets the `x` and `y` values of this object from a given polar coordinate.
             * @param azimuth The angular coordinate, in radians.
             * @param radius The radial coordinate (length). Default 1.
             */
            setToPolar(azimuth: number, radius?: number): Phaser.Math.Vector2;

            /**
             * [description]
             * @param v [description]
             */
            equals(v: Phaser.Math.Vector2): boolean;

            /**
             * [description]
             */
            angle(): number;

            /**
             * [description]
             * @param src [description]
             */
            add(src: Phaser.Math.Vector2): Phaser.Math.Vector2;

            /**
             * [description]
             * @param src [description]
             */
            subtract(src: Phaser.Math.Vector2): Phaser.Math.Vector2;

            /**
             * [description]
             * @param src [description]
             */
            multiply(src: Phaser.Math.Vector2): Phaser.Math.Vector2;

            /**
             * [description]
             * @param value [description]
             */
            scale(value: number): Phaser.Math.Vector2;

            /**
             * [description]
             * @param src [description]
             */
            divide(src: Phaser.Math.Vector2): Phaser.Math.Vector2;

            /**
             * [description]
             */
            negate(): Phaser.Math.Vector2;

            /**
             * [description]
             * @param src [description]
             */
            distance(src: Phaser.Math.Vector2): number;

            /**
             * [description]
             * @param src [description]
             */
            distanceSq(src: Phaser.Math.Vector2): number;

            /**
             * [description]
             */
            length(): number;

            /**
             * [description]
             */
            lengthSq(): number;

            /**
             * [description]
             */
            normalize(): Phaser.Math.Vector2;

            /**
             * [description]
             */
            normalizeRightHand(): Phaser.Math.Vector2;

            /**
             * [description]
             * @param src [description]
             */
            dot(src: Phaser.Math.Vector2): number;

            /**
             * [description]
             * @param src [description]
             */
            cross(src: Phaser.Math.Vector2): number;

            /**
             * [description]
             * @param src [description]
             * @param t [description] Default 0.
             */
            lerp(src: Phaser.Math.Vector2, t?: number): Phaser.Math.Vector2;

            /**
             * [description]
             * @param mat [description]
             */
            transformMat3(mat: Phaser.Math.Matrix3): Phaser.Math.Vector2;

            /**
             * [description]
             * @param mat [description]
             */
            transformMat4(mat: Phaser.Math.Matrix4): Phaser.Math.Vector2;

            /**
             * [description]
             */
            reset(): Phaser.Math.Vector2;

            /**
             * A static zero Vector2 for use by reference.
             */
            static ZERO(): void;

        }

        /**
         * [description]
         */
        class Vector3 {
            /**
             * 
             * @param x [description]
             * @param y [description]
             * @param z [description]
             */
            constructor(x?: number, y?: number, z?: number);

            /**
             * The x component of this Vector.
             */
            x: number;

            /**
             * The y component of this Vector.
             */
            y: number;

            /**
             * The z component of this Vector.
             */
            z: number;

            /**
             * [description]
             */
            up(): Phaser.Math.Vector3;

            /**
             * [description]
             */
            clone(): Phaser.Math.Vector3;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             */
            crossVectors(a: Phaser.Math.Vector3, b: Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v The Vector3 to compare against.
             */
            equals(v: Phaser.Math.Vector3): boolean;

            /**
             * [description]
             * @param src [description]
             */
            copy(src: Phaser.Math.Vector2 | Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param z [description]
             */
            set(x: number | object, y?: number, z?: number): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             */
            add(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             */
            subtract(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             */
            multiply(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param scale [description]
             */
            scale(scale: number): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             */
            divide(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             */
            negate(): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             */
            distance(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): number;

            /**
             * [description]
             * @param v [description]
             */
            distanceSq(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): number;

            /**
             * [description]
             */
            length(): number;

            /**
             * [description]
             */
            lengthSq(): number;

            /**
             * [description]
             * @param v [description]
             */
            normalize(v: Phaser.Math.Vector2 | Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             */
            dot(v: Phaser.Math.Vector3): number;

            /**
             * [description]
             * @param v [description]
             */
            cross(v: Phaser.Math.Vector3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param v [description]
             * @param t [description] Default 0.
             */
            lerp(v: Phaser.Math.Vector3, t?: number): Phaser.Math.Vector3;

            /**
             * [description]
             * @param mat [description]
             */
            transformMat3(mat: Phaser.Math.Matrix3): Phaser.Math.Vector3;

            /**
             * [description]
             * @param mat [description]
             */
            transformMat4(mat: Phaser.Math.Matrix4): Phaser.Math.Vector3;

            /**
             * [description]
             * @param mat [description]
             */
            transformCoordinates(mat: Phaser.Math.Matrix4): Phaser.Math.Vector3;

            /**
             * [description]
             * @param q [description]
             */
            transformQuat(q: Phaser.Math.Quaternion): Phaser.Math.Vector3;

            /**
             * Multiplies this Vector3 by the specified matrix, applying a W divide. This is useful for projection,
             * e.g. unprojecting a 2D point into 3D space.
             * @param mat [description]
             */
            project(mat: Phaser.Math.Matrix4): Phaser.Math.Vector3;

            /**
             * Unproject this point from 2D space to 3D space.
             * The point should have its x and y properties set to
             * 2D screen space, and the z either at 0 (near plane)
             * or 1 (far plane). The provided matrix is assumed to already
             * be combined, i.e. projection * view * model.
             * 
             * After this operation, this vector's (x, y, z) components will
             * represent the unprojected 3D coordinate.
             * @param viewport Screen x, y, width and height in pixels.
             * @param invProjectionView Combined projection and view matrix.
             */
            unproject(viewport: Phaser.Math.Vector4, invProjectionView: Phaser.Math.Matrix4): Phaser.Math.Vector3;

            /**
             * [description]
             */
            reset(): Phaser.Math.Vector3;

        }

        /**
         * [description]
         */
        class Vector4 {
            /**
             * 
             * @param x [description]
             * @param y [description]
             * @param z [description]
             * @param w [description]
             */
            constructor(x?: number, y?: number, z?: number, w?: number);

            /**
             * The x component of this Vector.
             */
            x: number;

            /**
             * The y component of this Vector.
             */
            y: number;

            /**
             * The z component of this Vector.
             */
            z: number;

            /**
             * The w component of this Vector.
             */
            w: number;

            /**
             * [description]
             */
            clone(): Phaser.Math.Vector4;

            /**
             * [description]
             * @param src [description]
             */
            copy(src: Phaser.Math.Vector4): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            equals(v: Phaser.Math.Vector4): boolean;

            /**
             * [description]
             * @param x [description]
             * @param y [description]
             * @param z [description]
             * @param w [description]
             */
            set(x: number, y: number, z: number, w: number): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            add(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            subtract(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Vector4;

            /**
             * [description]
             * @param scale [description]
             */
            scale(scale: number): Phaser.Math.Vector4;

            /**
             * [description]
             */
            length(): number;

            /**
             * [description]
             */
            lengthSq(): number;

            /**
             * [description]
             */
            normalize(): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            dot(v: Phaser.Math.Vector4): number;

            /**
             * [description]
             * @param v [description]
             * @param t [description] Default 0.
             */
            lerp(v: Phaser.Math.Vector4, t?: number): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            multiply(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            divide(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): Phaser.Math.Vector4;

            /**
             * [description]
             * @param v [description]
             */
            distance(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): number;

            /**
             * [description]
             * @param v [description]
             */
            distanceSq(v: Phaser.Math.Vector2 | Phaser.Math.Vector3 | Phaser.Math.Vector4): number;

            /**
             * [description]
             */
            negate(): Phaser.Math.Vector4;

            /**
             * [description]
             * @param mat [description]
             */
            transformMat4(mat: Phaser.Math.Matrix4): Phaser.Math.Vector4;

            /**
             * [description]
             * @param q [description]
             */
            transformQuat(q: Phaser.Math.Quaternion): Phaser.Math.Vector4;

            /**
             * [description]
             */
            reset(): Phaser.Math.Vector4;

        }

        /**
         * Checks if the two values are within the given `tolerance` of each other.
         * @param a [description]
         * @param b [description]
         * @param tolerance The tolerance. Anything equal to or less than this value is considered as being within range.
         */
        function Within(a: number, b: number, tolerance: number): boolean;

        /**
         * [description]
         * @param value [description]
         * @param min [description]
         * @param max [description]
         */
        function Wrap(value: number, min: number, max: number): number;

    }

    namespace Physics {
        namespace Arcade {
            /**
             * An Arcade Physics Image Game Object.
             * 
             * 
             * 
             * An Image is a light-weight Game Object useful for the display of static images in your game,
             * 
             * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
             * 
             * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
             * 
             * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
             */
            class Image extends Phaser.GameObjects.Image implements Phaser.Physics.Arcade.Components.Acceleration, Phaser.Physics.Arcade.Components.Angular, Phaser.Physics.Arcade.Components.Bounce, Phaser.Physics.Arcade.Components.Debug, Phaser.Physics.Arcade.Components.Drag, Phaser.Physics.Arcade.Components.Enable, Phaser.Physics.Arcade.Components.Friction, Phaser.Physics.Arcade.Components.Gravity, Phaser.Physics.Arcade.Components.Immovable, Phaser.Physics.Arcade.Components.Mass, Phaser.Physics.Arcade.Components.Size, Phaser.Physics.Arcade.Components.Velocity, Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(scene: Phaser.Scene, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x The horizontal acceleration
                 * @param y The vertical acceleration Default x.
                 */
                setAcceleration(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value The horizontal acceleration
                 */
                setAccelerationX(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value The vertical acceleration
                 */
                setAccelerationY(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularAcceleration(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularDrag(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setBounce(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounceX(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounceY(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setCollideWorldBounds(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setDrag(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDragX(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDragY(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param reset [description]
                 * @param x [description]
                 * @param y [description]
                 * @param enableGameObject [description]
                 * @param showGameObject [description]
                 */
                enableBody(reset: boolean, x: number, y: number, enableGameObject: boolean, showGameObject: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param disableGameObject [description] Default false.
                 * @param hideGameObject [description] Default false.
                 */
                disableBody(disableGameObject?: boolean, hideGameObject?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Syncs the Bodies position and size with its parent Game Object.
                 * You don't need to call this for Dynamic Bodies, as it happens automatically.
                 * But for Static bodies it's a useful way of modifying the position of a Static Body
                 * in the Physics World, based on its Game Object.
                 */
                refreshBody(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setFriction(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setGravity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setGravityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setGravityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description] Default true.
                 */
                setImmovable(value?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setOffset(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param offsetX [description]
                 * @param offsetY [description]
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * [description]
             */
            class ArcadePhysics {
                /**
                 * 
                 * @param scene [description]
                 */
                constructor(scene: Phaser.Scene);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                systems: Phaser.Scenes.Systems;

                /**
                 * [description]
                 */
                config: object;

                /**
                 * [description]
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                add: Phaser.Physics.Arcade.Factory;

                /**
                 * [description]
                 */
                getConfig(): object;

                /**
                 * Checks for overlaps between two Game Objects. The objects can be any Game Object that have an Arcade Physics Body.
                 * 
                 * Unlike {@link #collide} the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.
                 * 
                 * Both the first and second parameter can be arrays of objects, of differing types.
                 * If two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.
                 * 
                 * ##### Tilemaps
                 * 
                 * Any overlapping tiles, including blank/null tiles, will give a positive result. Tiles marked via {@link Phaser.Tilemap#setCollision} (and similar methods) have no special status, and callbacks added via {@link Phaser.Tilemap#setTileIndexCallback} or {@link Phaser.Tilemap#setTileLocationCallback} are not invoked. So calling this method without any callbacks isn't very useful.
                 * 
                 * If you're interested only in whether an object overlaps a certain tile or class of tiles, filter the tiles with `processCallback` and then use the result returned by this method. Blank/null tiles can be excluded by their {@link Phaser.Tile#index index} (-1).
                 * 
                 * If you want to take action on certain overlaps, examine the tiles in `collideCallback` and then handle as you like.
                 * @param object1 The first object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.
                 * @param object2 The second object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.
                 * @param overlapCallback An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them, unless you are checking Group vs. Sprite, in which case Sprite will always be the first parameter. Default null.
                 * @param processCallback A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`. Default null.
                 * @param callbackContext The context in which to run the callbacks.
                 */
                overlap(object1: Phaser.GameObjects.GameObject | any[] | Phaser.GameObjects.Group, object2: Phaser.GameObjects.GameObject | any[] | Phaser.GameObjects.Group, overlapCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * [description]
                 * @param object1 The first object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.
                 * @param object2 The second object or array of objects to check. Can be any Game Object that has an Arcade Physics Body.
                 * @param collideCallback An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them, unless you are checking Group vs. Sprite, in which case Sprite will always be the first parameter. Default null.
                 * @param processCallback A callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`. Default null.
                 * @param callbackContext The context in which to run the callbacks.
                 */
                collide(object1: Phaser.GameObjects.GameObject | any[], object2: Phaser.GameObjects.GameObject | any[], collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * [description]
                 */
                pause(): Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                resume(): Phaser.Physics.Arcade.World;

                /**
                 * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)
                 * 
                 * You must give a maximum speed value, beyond which the game object won't go any faster.
                 * 
                 * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.
                 * Note: The game object doesn't stop moving once it reaches the destination coordinates.
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param x The x coordinate to accelerate towards.
                 * @param y The y coordinate to accelerate towards.
                 * @param speed The speed it will accelerate in pixels per second. Default 60.
                 * @param xSpeedMax The maximum x velocity the game object can reach. Default 500.
                 * @param ySpeedMax The maximum y velocity the game object can reach. Default 500.
                 */
                accelerateTo(gameObject: Phaser.GameObjects.GameObject, x: number, y: number, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

                /**
                 * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)
                 * 
                 * You must give a maximum speed value, beyond which the game object won't go any faster.
                 * 
                 * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.
                 * Note: The game object doesn't stop moving once it reaches the destination coordinates.
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param destination The Game Object to move towards. Can be any object but must have visible x/y properties.
                 * @param speed The speed it will accelerate in pixels per second. Default 60.
                 * @param xSpeedMax The maximum x velocity the game object can reach. Default 500.
                 * @param ySpeedMax The maximum y velocity the game object can reach. Default 500.
                 */
                accelerateToObject(gameObject: Phaser.GameObjects.GameObject, destination: Phaser.GameObjects.GameObject, speed?: number, xSpeedMax?: number, ySpeedMax?: number): number;

                /**
                 * From a set of points or display objects, find the one closest to a source point or object.
                 * @param source Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
                 */
                closest(source: object): Phaser.Physics.Arcade.Body;

                /**
                 * From a set of points or display objects, find the one farthest from a source point or object.
                 * @param source Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
                 */
                furthest(source: object): Phaser.Physics.Arcade.Body;

                /**
                 * Move the given display object towards the x/y coordinates at a steady velocity.
                 * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
                 * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
                 * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
                 * Note: The display object doesn't stop moving once it reaches the destination coordinates.
                 * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param x The x coordinate to move towards.
                 * @param y The y coordinate to move towards.
                 * @param speed The speed it will move, in pixels per second (default is 60 pixels/sec) Default 60.
                 * @param maxTime Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms. Default 0.
                 */
                moveTo(gameObject: Phaser.GameObjects.GameObject, x: number, y: number, speed?: number, maxTime?: number): number;

                /**
                 * Move the given display object towards the destination object at a steady velocity.
                 * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.
                 * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
                 * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
                 * Note: The display object doesn't stop moving once it reaches the destination coordinates.
                 * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
                 * @param gameObject Any Game Object with an Arcade Physics body.
                 * @param destination Any object with public `x` and `y` properties, such as a Game Object or Geometry object.
                 * @param speed The speed it will move, in pixels per second (default is 60 pixels/sec) Default 60.
                 * @param maxTime Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms. Default 0.
                 */
                moveToObject(gameObject: Phaser.GameObjects.GameObject, destination: object, speed?: number, maxTime?: number): number;

                /**
                 * Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.
                 * One way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.
                 * @param angle The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
                 * @param speed The speed it will move, in pixels per second sq. Default 60.
                 * @param vec2 The Vector2 in which the x and y properties will be set to the calculated velocity.
                 */
                velocityFromAngle(angle: number, speed?: number, vec2?: Phaser.Math.Vector2): Phaser.Math.Vector2;

                /**
                 * Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.
                 * One way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.
                 * @param rotation The angle in radians.
                 * @param speed The speed it will move, in pixels per second sq. Default 60.
                 * @param vec2 The Vector2 in which the x and y properties will be set to the calculated velocity.
                 */
                velocityFromRotation(rotation: number, speed?: number, vec2?: Phaser.Math.Vector2): Phaser.Math.Vector2;

                /**
                 * The Scene that owns this plugin is shutting down.
                 * We need to kill and reset all internal properties as well as stop listening to Scene events.
                 */
                shutdown(): void;

                /**
                 * The Scene that owns this plugin is being destroyed.
                 * We need to shutdown and then kill off all external references.
                 */
                destroy(): void;

            }

            /**
             * An Arcade Physics Sprite Game Object.
             * 
             * 
             * 
             * A Sprite Game Object is used for the display of both static and animated images in your game.
             * 
             * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
             * 
             * and animated.
             * 
             * 
             * 
             * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
             * 
             * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
             * 
             * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
             */
            class Sprite extends Phaser.GameObjects.Sprite implements Phaser.Physics.Arcade.Components.Acceleration, Phaser.Physics.Arcade.Components.Angular, Phaser.Physics.Arcade.Components.Bounce, Phaser.Physics.Arcade.Components.Debug, Phaser.Physics.Arcade.Components.Drag, Phaser.Physics.Arcade.Components.Enable, Phaser.Physics.Arcade.Components.Friction, Phaser.Physics.Arcade.Components.Gravity, Phaser.Physics.Arcade.Components.Immovable, Phaser.Physics.Arcade.Components.Mass, Phaser.Physics.Arcade.Components.Size, Phaser.Physics.Arcade.Components.Velocity, Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param scene The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(scene: Phaser.Scene, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x The horizontal acceleration
                 * @param y The vertical acceleration Default x.
                 */
                setAcceleration(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value The horizontal acceleration
                 */
                setAccelerationX(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value The vertical acceleration
                 */
                setAccelerationY(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularAcceleration(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularDrag(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setBounce(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounceX(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounceY(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setCollideWorldBounds(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setDrag(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDragX(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDragY(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param reset [description]
                 * @param x [description]
                 * @param y [description]
                 * @param enableGameObject [description]
                 * @param showGameObject [description]
                 */
                enableBody(reset: boolean, x: number, y: number, enableGameObject: boolean, showGameObject: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param disableGameObject [description] Default false.
                 * @param hideGameObject [description] Default false.
                 */
                disableBody(disableGameObject?: boolean, hideGameObject?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Syncs the Bodies position and size with its parent Game Object.
                 * You don't need to call this for Dynamic Bodies, as it happens automatically.
                 * But for Static bodies it's a useful way of modifying the position of a Static Body
                 * in the Physics World, based on its Game Object.
                 */
                refreshBody(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setFriction(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setGravity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setGravityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setGravityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description] Default true.
                 */
                setImmovable(value?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setOffset(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param offsetX [description]
                 * @param offsetY [description]
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * [description]
             */
            class Body {
                /**
                 * 
                 * @param world [description]
                 * @param gameObject [description]
                 */
                constructor(world: Phaser.Physics.Arcade.World, gameObject: Phaser.GameObjects.GameObject);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                gameObject: Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                transform: object;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: integer;

                /**
                 * [description]
                 */
                enable: boolean;

                /**
                 * [description]
                 */
                isCircle: boolean;

                /**
                 * [description]
                 */
                radius: number;

                /**
                 * [description]
                 */
                offset: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                position: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                prev: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                allowRotation: boolean;

                /**
                 * [description]
                 */
                rotation: number;

                /**
                 * [description]
                 */
                preRotation: number;

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                sourceWidth: number;

                /**
                 * [description]
                 */
                sourceHeight: number;

                /**
                 * [description]
                 */
                halfWidth: number;

                /**
                 * [description]
                 */
                halfHeight: number;

                /**
                 * [description]
                 */
                center: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                velocity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                newVelocity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                deltaMax: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                acceleration: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                allowDrag: boolean;

                /**
                 * [description]
                 */
                drag: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                allowGravity: boolean;

                /**
                 * [description]
                 */
                gravity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                bounce: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                worldBounce: Phaser.Math.Vector2;

                /**
                 * Emit a `worldbounds` event when this body collides with the world bounds (and `collideWorldBounds` is also true).
                 */
                onWorldBounds: boolean;

                /**
                 * [description]
                 */
                onCollide: boolean;

                /**
                 * [description]
                 */
                onOverlap: boolean;

                /**
                 * [description]
                 */
                maxVelocity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                friction: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                angularVelocity: number;

                /**
                 * [description]
                 */
                angularAcceleration: number;

                /**
                 * [description]
                 */
                angularDrag: number;

                /**
                 * [description]
                 */
                maxAngular: number;

                /**
                 * [description]
                 */
                mass: number;

                /**
                 * [description]
                 */
                angle: number;

                /**
                 * [description]
                 */
                speed: number;

                /**
                 * [description]
                 */
                facing: integer;

                /**
                 * [description]
                 */
                immovable: boolean;

                /**
                 * [description]
                 */
                moves: boolean;

                /**
                 * [description]
                 */
                customSeparateX: boolean;

                /**
                 * [description]
                 */
                customSeparateY: boolean;

                /**
                 * [description]
                 */
                overlapX: number;

                /**
                 * [description]
                 */
                overlapY: number;

                /**
                 * [description]
                 */
                overlapR: number;

                /**
                 * [description]
                 */
                embedded: boolean;

                /**
                 * [description]
                 */
                collideWorldBounds: boolean;

                /**
                 * [description]
                 */
                checkCollision: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                touching: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                wasTouching: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                blocked: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                dirty: boolean;

                /**
                 * [description]
                 */
                syncBounds: boolean;

                /**
                 * [description]
                 */
                isMoving: boolean;

                /**
                 * [description]
                 */
                stopVelocityOnCollide: boolean;

                /**
                 * [description]
                 */
                physicsType: integer;

                /**
                 * [description]
                 */
                updateBounds(): void;

                /**
                 * [description]
                 */
                updateCenter(): void;

                /**
                 * [description]
                 * @param delta [description]
                 */
                update(delta: number): void;

                /**
                 * Feeds the body results back into the parent gameobject.
                 */
                postUpdate(): void;

                /**
                 * [description]
                 */
                checkWorldBounds(): boolean;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setOffset(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param center [description] Default true.
                 */
                setSize(width: number, height: number, center?: boolean): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param radius [description]
                 * @param offsetX [description]
                 * @param offsetY [description]
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): Phaser.Physics.Arcade.Body;

                /**
                 * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.
                 * If the body had any velocity or acceleration it is lost as a result of calling this.
                 * @param x The horizontal position to place the Game Object and Body.
                 * @param y The vertical position to place the Game Object and Body.
                 */
                reset(x: number, y: number): void;

                /**
                 * [description]
                 */
                stop(): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param obj [description]
                 */
                getBounds(obj: ArcadeBodyBounds): ArcadeBodyBounds;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                hitTest(x: number, y: number): boolean;

                /**
                 * [description]
                 */
                onFloor(): boolean;

                /**
                 * [description]
                 */
                onCeiling(): boolean;

                /**
                 * [description]
                 */
                onWall(): boolean;

                /**
                 * [description]
                 */
                deltaAbsX(): number;

                /**
                 * [description]
                 */
                deltaAbsY(): number;

                /**
                 * [description]
                 */
                deltaX(): number;

                /**
                 * [description]
                 */
                deltaY(): number;

                /**
                 * [description]
                 */
                deltaZ(): number;

                /**
                 * [description]
                 */
                destroy(): void;

                /**
                 * [description]
                 * @param graphic [description]
                 */
                drawDebug(graphic: Phaser.GameObjects.Graphics): void;

                /**
                 * [description]
                 */
                willDrawDebug(): boolean;

                /**
                 * [description]
                 * @param value [description]
                 */
                setCollideWorldBounds(value: boolean): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setVelocity(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setVelocityX(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setVelocityY(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setBounce(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounceX(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounceY(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setAcceleration(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAccelerationX(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAccelerationY(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setDrag(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDragX(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDragY(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setGravity(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravityX(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravityY(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionX(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionY(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularAcceleration(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularDrag(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 * @param value [description]
                 */
                setImmovable(value: boolean): Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 */
                x: number;

                /**
                 * [description]
                 */
                y: number;

                /**
                 * [description]
                 */
                left: number;

                /**
                 * [description]
                 */
                right: number;

                /**
                 * [description]
                 */
                top: number;

                /**
                 * [description]
                 */
                bottom: number;

            }

            /**
             * [description]
             */
            class Collider {
                /**
                 * 
                 * @param world [description]
                 * @param overlapOnly [description]
                 * @param object1 The first object to check for collision.
                 * @param object2 The second object to check for collision.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                constructor(world: Phaser.Physics.Arcade.World, overlapOnly: boolean, object1: Phaser.Physics.Arcade.Body, object2: Phaser.Physics.Arcade.Body, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: object);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                name: string;

                /**
                 * [description]
                 */
                active: boolean;

                /**
                 * [description]
                 */
                overlapOnly: boolean;

                /**
                 * [description]
                 */
                object1: Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 */
                object2: Phaser.Physics.Arcade.Body;

                /**
                 * [description]
                 */
                collideCallback: ArcadePhysicsCallback;

                /**
                 * [description]
                 */
                processCallback: ArcadePhysicsCallback;

                /**
                 * [description]
                 */
                callbackContext: object;

                /**
                 * [description]
                 * @param name [description]
                 */
                setName(name: string): Phaser.Physics.Arcade.Collider;

                /**
                 * [description]
                 */
                update(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

            namespace Components {
                /**
                 * [description]
                 */
                interface Acceleration {
                    /**
                     * [description]
                     * @param x The horizontal acceleration
                     * @param y The vertical acceleration Default x.
                     */
                    setAcceleration(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value The horizontal acceleration
                     */
                    setAccelerationX(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value The vertical acceleration
                     */
                    setAccelerationY(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Angular {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setAngularVelocity(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setAngularAcceleration(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setAngularDrag(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Bounce {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setBounce(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setBounceX(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setBounceY(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setCollideWorldBounds(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Debug {
                    /**
                     * [description]
                     * @param showBody [description]
                     * @param showVelocity [description]
                     * @param bodyColor [description]
                     */
                    setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    debugShowBody: boolean;
                    /**
                     * [description]
                     */
                    debugShowVelocity: boolean;
                    /**
                     * [description]
                     */
                    debugBodyColor: number;
                }

                /**
                 * [description]
                 */
                interface Drag {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setDrag(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setDragX(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setDragY(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Enable {
                    /**
                     * [description]
                     * @param reset [description]
                     * @param x [description]
                     * @param y [description]
                     * @param enableGameObject [description]
                     * @param showGameObject [description]
                     */
                    enableBody(reset: boolean, x: number, y: number, enableGameObject: boolean, showGameObject: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param disableGameObject [description] Default false.
                     * @param hideGameObject [description] Default false.
                     */
                    disableBody(disableGameObject?: boolean, hideGameObject?: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * Syncs the Bodies position and size with its parent Game Object.
                     * You don't need to call this for Dynamic Bodies, as it happens automatically.
                     * But for Static bodies it's a useful way of modifying the position of a Static Body
                     * in the Physics World, based on its Game Object.
                     */
                    refreshBody(): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Friction {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setFriction(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setFrictionX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setFrictionY(y: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Gravity {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setGravity(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setGravityX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setGravityY(y: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Immovable {
                    /**
                     * [description]
                     * @param value [description] Default true.
                     */
                    setImmovable(value?: boolean): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Mass {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setMass(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Size {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setOffset(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param center [description] Default true.
                     */
                    setSize(width: number, height: number, center?: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param radius [description]
                     * @param offsetX [description]
                     * @param offsetY [description]
                     */
                    setCircle(radius: number, offsetX?: number, offsetY?: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Velocity {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setVelocityX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setVelocityY(y: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;
                }

            }

            /**
             * [description]
             */
            var DYNAMIC_BODY: number;

            /**
             * [description]
             */
            var STATIC_BODY: number;

            /**
             * [description]
             */
            var GROUP: number;

            /**
             * [description]
             */
            var TILEMAPLAYER: number;

            /**
             * [description]
             */
            var FACING_NONE: number;

            /**
             * [description]
             */
            var FACING_UP: number;

            /**
             * [description]
             */
            var FACING_DOWN: number;

            /**
             * [description]
             */
            var FACING_LEFT: number;

            /**
             * [description]
             */
            var FACING_RIGHT: number;

            /**
             * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.
             * 
             * Objects that are created by this Factory are automatically added to the physics world.
             */
            class Factory {
                /**
                 * 
                 * @param world The Arcade Physics World instance.
                 */
                constructor(world: Phaser.Physics.Arcade.World);

                /**
                 * A reference to the Arcade Physics World.
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * A reference to the Scene this Arcade Physics instance belongs to.
                 */
                scene: Phaser.Scene;

                /**
                 * A reference to the Scene.Systems this Arcade Physics instance belongs to.
                 */
                sys: Phaser.Scenes.Systems;

                /**
                 * Create a new Arcade Physics Collider object.
                 * @param object1 The first object to check for collision.
                 * @param object2 The second object to check for collision.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                collider(object1: Phaser.Physics.Arcade.Body, object2: Phaser.Physics.Arcade.Body, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any): Phaser.Physics.Arcade.Collider;

                /**
                 * Create a new Arcade Physics Collider Overlap object.
                 * @param object1 The first object to check for overlap.
                 * @param object2 The second object to check for overlap.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                overlap(object1: Phaser.Physics.Arcade.Body, object2: Phaser.Physics.Arcade.Body, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any): Phaser.Physics.Arcade.Collider;

                /**
                 * Adds an Arcade Physics Body to the given Game Object.
                 * @param gameObject [description]
                 * @param isStatic Set to true to create a Static body, otherwise it will create a Dynamic body. Default false.
                 */
                existing(gameObject: Phaser.GameObjects.GameObject, isStatic?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Creates a new Arcade Image object with a Static body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                staticImage(x: number, y: number, texture: string, frame?: string | integer): Phaser.Physics.Arcade.Image;

                /**
                 * Creates a new Arcade Image object with a Dynamic body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                image(x: number, y: number, texture: string, frame?: string | integer): Phaser.Physics.Arcade.Image;

                /**
                 * Creates a new Arcade Sprite object with a Static body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                staticSprite(x: number, y: number, texture: string, frame?: string | integer): Phaser.Physics.Arcade.Sprite;

                /**
                 * Creates a new Arcade Sprite object with a Dynamic body.
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                sprite(x: number, y: number, key: string, frame?: string | integer): Phaser.Physics.Arcade.Sprite;

                /**
                 * Creates a Static Physics Group object.
                 * All Game Objects created by this Group will automatically be static Arcade Physics objects.
                 * @param children [description]
                 * @param config [description]
                 */
                staticGroup(children?: any[], config?: GroupConfig): Phaser.Physics.Arcade.StaticGroup;

                /**
                 * Creates a Physics Group object.
                 * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.
                 * @param children [description]
                 * @param config [description]
                 */
                group(children?: any[], config?: PhysicsGroupConfig): Phaser.Physics.Arcade.Group;

                /**
                 * Destroys this Factory.
                 */
                destroy(): void;

            }

            /**
             * [description]
             * @param body1 [description]
             * @param body2 [description]
             * @param overlapOnly [description]
             * @param bias [description]
             */
            function GetOverlapX(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean, bias: number): number;

            /**
             * [description]
             * @param body1 [description]
             * @param body2 [description]
             * @param overlapOnly [description]
             * @param bias [description]
             */
            function GetOverlapY(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean, bias: number): number;

            /**
             * An Arcade Physics Group object.
             * 
             * 
             * 
             * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.
             */
            class Group extends Phaser.GameObjects.Group {
                /**
                 * 
                 * @param world [description]
                 * @param scene [description]
                 * @param children [description]
                 * @param config [description]
                 */
                constructor(world: Phaser.Physics.Arcade.World, scene: Phaser.Scene, children: any[], config?: PhysicsGroupConfig);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                physicsType: integer;

                /**
                 * [description]
                 */
                defaults: PhysicsGroupDefaults;

                /**
                 * [description]
                 * @param child [description]
                 */
                createCallbackHandler(child: Phaser.GameObjects.GameObject): void;

                /**
                 * [description]
                 * @param child [description]
                 */
                removeCallbackHandler(child: Phaser.GameObjects.GameObject): void;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param step [description]
                 */
                setVelocity(x: number, y: number, step: number): Phaser.Physics.Arcade.Group;

                /**
                 * [description]
                 * @param value [description]
                 * @param step [description]
                 */
                setVelocityX(value: number, step: number): Phaser.Physics.Arcade.Group;

                /**
                 * [description]
                 * @param value [description]
                 * @param step [description]
                 */
                setVelocityY(value: number, step: number): Phaser.Physics.Arcade.Group;

            }

            /**
             * [description]
             * @param body1 [description]
             * @param body2 [description]
             * @param overlapOnly [description]
             * @param bias [description]
             */
            function SeparateX(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean, bias: number): boolean;

            /**
             * [description]
             * @param body1 [description]
             * @param body2 [description]
             * @param overlapOnly [description]
             * @param bias [description]
             */
            function SeparateY(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean, bias: number): boolean;

            /**
             * [description]
             */
            class StaticBody {
                /**
                 * 
                 * @param world [description]
                 * @param gameObject [description]
                 */
                constructor(world: Phaser.Physics.Arcade.World, gameObject: Phaser.GameObjects.GameObject);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                gameObject: Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: integer;

                /**
                 * [description]
                 */
                enable: boolean;

                /**
                 * [description]
                 */
                isCircle: boolean;

                /**
                 * [description]
                 */
                radius: number;

                /**
                 * [description]
                 */
                offset: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                position: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                halfWidth: number;

                /**
                 * [description]
                 */
                halfHeight: number;

                /**
                 * [description]
                 */
                center: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                velocity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                allowGravity: boolean;

                /**
                 * [description]
                 */
                gravity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                bounce: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                onWorldBounds: boolean;

                /**
                 * [description]
                 */
                onCollide: boolean;

                /**
                 * [description]
                 */
                onOverlap: boolean;

                /**
                 * [description]
                 */
                mass: number;

                /**
                 * [description]
                 */
                immovable: boolean;

                /**
                 * [description]
                 */
                customSeparateX: boolean;

                /**
                 * [description]
                 */
                customSeparateY: boolean;

                /**
                 * [description]
                 */
                overlapX: number;

                /**
                 * [description]
                 */
                overlapY: number;

                /**
                 * [description]
                 */
                overlapR: number;

                /**
                 * [description]
                 */
                embedded: boolean;

                /**
                 * [description]
                 */
                collideWorldBounds: boolean;

                /**
                 * [description]
                 */
                checkCollision: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                touching: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                wasTouching: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                blocked: ArcadeBodyCollision;

                /**
                 * [description]
                 */
                physicsType: integer;

                /**
                 * Changes the Game Object this Body is bound to.
                 * First it removes its reference from the old Game Object, then sets the new one.
                 * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.
                 * @param gameObject The new Game Object that will own this Body.
                 * @param update Reposition and resize this Body to match the new Game Object? Default true.
                 */
                setGameObject(gameObject: Phaser.GameObjects.GameObject, update?: boolean): Phaser.Physics.Arcade.StaticBody;

                /**
                 * Updates this Static Body so that its position and dimensions are updated
                 * based on the current Game Object it is bound to.
                 */
                updateFromGameObject(): Phaser.Physics.Arcade.StaticBody;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setOffset(x: number, y: number): Phaser.Physics.Arcade.StaticBody;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param offsetX [description]
                 * @param offsetY [description]
                 */
                setSize(width: number, height: number, offsetX?: number, offsetY?: number): Phaser.Physics.Arcade.StaticBody;

                /**
                 * [description]
                 * @param radius [description]
                 * @param offsetX [description]
                 * @param offsetY [description]
                 */
                setCircle(radius: number, offsetX?: number, offsetY?: number): Phaser.Physics.Arcade.StaticBody;

                /**
                 * [description]
                 */
                updateCenter(): void;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                reset(x: number, y: number): void;

                /**
                 * [description]
                 */
                stop(): Phaser.Physics.Arcade.StaticBody;

                /**
                 * [description]
                 * @param obj [description]
                 */
                getBounds(obj: ArcadeBodyBounds): ArcadeBodyBounds;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                hitTest(x: number, y: number): boolean;

                /**
                 * [description]
                 */
                deltaAbsX(): number;

                /**
                 * [description]
                 */
                deltaAbsY(): number;

                /**
                 * [description]
                 */
                deltaX(): number;

                /**
                 * [description]
                 */
                deltaY(): number;

                /**
                 * [description]
                 */
                deltaZ(): number;

                /**
                 * [description]
                 */
                destroy(): void;

                /**
                 * [description]
                 * @param graphic [description]
                 */
                drawDebug(graphic: Phaser.GameObjects.Graphics): void;

                /**
                 * [description]
                 */
                willDrawDebug(): boolean;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.Physics.Arcade.StaticBody;

                /**
                 * [description]
                 */
                x: number;

                /**
                 * [description]
                 */
                y: number;

                /**
                 * [description]
                 */
                left: number;

                /**
                 * [description]
                 */
                right: number;

                /**
                 * [description]
                 */
                top: number;

                /**
                 * [description]
                 */
                bottom: number;

            }

            /**
             * [description]
             */
            class StaticGroup extends Phaser.GameObjects.Group {
                /**
                 * 
                 * @param world [description]
                 * @param scene [description]
                 * @param children [description]
                 * @param config [description]
                 */
                constructor(world: Phaser.Physics.Arcade.World, scene: Phaser.Scene, children: any[], config: GroupConfig);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                physicsType: integer;

                /**
                 * [description]
                 * @param child [description]
                 */
                createCallbackHandler(child: Phaser.GameObjects.GameObject): void;

                /**
                 * [description]
                 * @param child [description]
                 */
                removeCallbackHandler(child: Phaser.GameObjects.GameObject): void;

                /**
                 * [description]
                 * @param entries [description]
                 */
                createMultipleCallbackHandler(entries: object): void;

                /**
                 * [description]
                 */
                refresh(): Phaser.Physics.Arcade.StaticGroup;

            }

            namespace Tilemap {
                /**
                 * [description]
                 * @param tile [description]
                 * @param sprite [description]
                 */
                function ProcessTileCallbacks(tile: Phaser.Tilemaps.Tilemap, sprite: Phaser.GameObjects.Sprite): boolean;

                /**
                 * Internal function to process the separation of a physics body from a tile.
                 * @param body The Body object to separate.
                 * @param x The x separation amount.
                 */
                function ProcessTileSeparationX(body: Phaser.Physics.Arcade.Body, x: number): void;

                /**
                 * Internal function to process the separation of a physics body from a tile.
                 * @param body The Body object to separate.
                 * @param y The y separation amount.
                 */
                function ProcessTileSeparationY(body: Phaser.Physics.Arcade.Body, y: number): void;

                /**
                 * The core separation function to separate a physics body and a tile.
                 * @param i [description]
                 * @param body The Body object to separate.
                 * @param tile The tile to collide against.
                 * @param tileWorldRect [description]
                 * @param tilemapLayer The tilemapLayer to collide against.
                 * @param tileBias [description]
                 */
                function SeparateTile(i: number, body: Phaser.Physics.Arcade.Body, tile: Phaser.Tilemaps.Tile, tileWorldRect: Phaser.Geom.Rectangle, tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer, tileBias: number): boolean;

                /**
                 * Check the body against the given tile on the X axis.
                 * @param body The Body object to separate.
                 * @param tile The tile to check.
                 * @param tileLeft [description]
                 * @param tileRight [description]
                 * @param tileBias [description]
                 */
                function TileCheckX(body: Phaser.Physics.Arcade.Body, tile: Phaser.Tilemaps.Tile, tileLeft: number, tileRight: number, tileBias: number): number;

                /**
                 * Check the body against the given tile on the Y axis.
                 * @param body The Body object to separate.
                 * @param tile The tile to check.
                 * @param tileTop [description]
                 * @param tileBottom [description]
                 * @param tileBias [description]
                 */
                function TileCheckY(body: Phaser.Physics.Arcade.Body, tile: Phaser.Tilemaps.Tile, tileTop: number, tileBottom: number, tileBias: number): number;

                /**
                 * [description]
                 * @param tileWorldRect [description]
                 * @param body [description]
                 */
                function TileIntersectsBody(tileWorldRect: Object, body: Phaser.Physics.Arcade.Body): boolean;

            }

            /**
             * [description]
             */
            class World extends Phaser.Events.EventEmitter {
                /**
                 * 
                 * @param scene [description]
                 * @param config [description]
                 */
                constructor(scene: Phaser.Scene, config: ArcadeWorldConfig);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * Dynamic Bodies
                 */
                bodies: Phaser.Structs.Set<Phaser.Physics.Arcade.Body>;

                /**
                 * Static Bodies
                 */
                staticBodies: Phaser.Structs.Set<Phaser.Physics.Arcade.StaticBody>;

                /**
                 * Static Bodies
                 */
                pendingDestroy: Phaser.Structs.Set<(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)>;

                /**
                 * [description]
                 */
                colliders: Phaser.Structs.ProcessQueue<Phaser.Physics.Arcade.Collider>;

                /**
                 * [description]
                 */
                gravity: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                bounds: Phaser.Geom.Rectangle;

                /**
                 * [description]
                 */
                checkCollision: CheckCollisionObject;

                /**
                 * [description]
                 */
                OVERLAP_BIAS: number;

                /**
                 * [description]
                 */
                TILE_BIAS: number;

                /**
                 * [description]
                 */
                forceX: boolean;

                /**
                 * [description]
                 */
                isPaused: boolean;

                /**
                 * [description]
                 */
                drawDebug: boolean;

                /**
                 * [description]
                 */
                debugGraphic: Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 */
                defaults: ArcadeWorldDefaults;

                /**
                 * [description]
                 */
                maxEntries: integer;

                /**
                 * [description]
                 */
                tree: Phaser.Structs.RTree;

                /**
                 * [description]
                 */
                staticTree: Phaser.Structs.RTree;

                /**
                 * [description]
                 */
                treeMinMax: ArcadeWorldTreeMinMax;

                /**
                 * [description]
                 * @param object [description]
                 * @param bodyType The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.
                 */
                enable(object: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[], bodyType?: integer): void;

                /**
                 * [description]
                 * @param object [description]
                 * @param bodyType The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.
                 */
                enableBody(object: Phaser.GameObjects.GameObject, bodyType?: integer): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param object [description]
                 */
                remove(object: Phaser.Physics.Arcade.Body): void;

                /**
                 * [description]
                 * @param object [description]
                 */
                disable(object: Phaser.GameObjects.GameObject | Phaser.GameObjects.GameObject[]): void;

                /**
                 * [description]
                 * @param object [description]
                 */
                disableGameObjectBody(object: Phaser.GameObjects.GameObject): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param body [description]
                 */
                disableBody(body: Phaser.Physics.Arcade.Body): void;

                /**
                 * [description]
                 */
                createDebugGraphic(): Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 * @param checkLeft [description]
                 * @param checkRight [description]
                 * @param checkUp [description]
                 * @param checkDown [description]
                 */
                setBounds(x: number, y: number, width: number, height: number, checkLeft?: boolean, checkRight?: boolean, checkUp?: boolean, checkDown?: boolean): Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 * @param left [description] Default true.
                 * @param right [description] Default true.
                 * @param up [description] Default true.
                 * @param down [description] Default true.
                 */
                setBoundsCollision(left?: boolean, right?: boolean, up?: boolean, down?: boolean): Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                pause(): Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 */
                resume(): Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 * @param object1 The first object to check for collision.
                 * @param object2 The second object to check for collision.
                 * @param collideCallback The callback to invoke when the two objects collide.
                 * @param processCallback The callback to invoke when the two objects collide. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                addCollider(object1: Phaser.Physics.Arcade.Body, object2: Phaser.Physics.Arcade.Body, collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): Phaser.Physics.Arcade.Collider;

                /**
                 * [description]
                 * @param object1 The first object to check for overlap.
                 * @param object2 The second object to check for overlap.
                 * @param collideCallback The callback to invoke when the two objects overlap.
                 * @param processCallback The callback to invoke when the two objects overlap. Must return a boolean.
                 * @param callbackContext The scope in which to call the callbacks.
                 */
                addOverlap(object1: Phaser.Physics.Arcade.Body, object2: Phaser.Physics.Arcade.Body, collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): Phaser.Physics.Arcade.Collider;

                /**
                 * [description]
                 * @param collider [description]
                 */
                removeCollider(collider: Phaser.Physics.Arcade.Collider): Phaser.Physics.Arcade.World;

                /**
                 * [description]
                 * @param time [description]
                 * @param delta [description]
                 */
                update(time: number, delta: number): void;

                /**
                 * [description]
                 */
                postUpdate(): void;

                /**
                 * [description]
                 * @param body [description]
                 */
                updateMotion(body: Phaser.Physics.Arcade.Body): void;

                /**
                 * [description]
                 * @param axis [description]
                 * @param body [description]
                 * @param velocity [description]
                 * @param acceleration [description]
                 * @param drag [description]
                 * @param max [description]
                 */
                computeVelocity(axis: integer, body: Phaser.Physics.Arcade.Body, velocity: number, acceleration: number, drag: number, max: number): number;

                /**
                 * [description]
                 * @param body1 [description]
                 * @param body2 [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                separate(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, processCallback?: ArcadePhysicsCallback, callbackContext?: any, overlapOnly?: boolean): boolean;

                /**
                 * [description]
                 * @param body1 [description]
                 * @param body2 [description]
                 * @param overlapOnly [description]
                 * @param bias [description]
                 */
                separateCircle(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body, overlapOnly: boolean, bias: number): boolean;

                /**
                 * [description]
                 * @param body1 [description]
                 * @param body2 [description]
                 */
                intersects(body1: Phaser.Physics.Arcade.Body, body2: Phaser.Physics.Arcade.Body): boolean;

                /**
                 * [description]
                 * @param circle [description]
                 * @param body [description]
                 */
                circleBodyIntersects(circle: Phaser.Physics.Arcade.Body, body: Phaser.Physics.Arcade.Body): boolean;

                /**
                 * [description]
                 * @param object1 [description]
                 * @param object2 [description]
                 * @param overlapCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 */
                overlap(object1: Phaser.GameObjects.GameObject, object2: Phaser.GameObjects.GameObject, overlapCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * [description]
                 * @param object1 [description]
                 * @param object2 [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 */
                collide(object1: Phaser.GameObjects.GameObject, object2: Phaser.GameObjects.GameObject, collideCallback?: ArcadePhysicsCallback, processCallback?: ArcadePhysicsCallback, callbackContext?: any): boolean;

                /**
                 * [description]
                 * @param object1 [description]
                 * @param object2 [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideObjects(object1: Phaser.GameObjects.GameObject, object2: Phaser.GameObjects.GameObject, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * [description]
                 * @param object1 [description]
                 * @param object2 [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideHandler(object1: Phaser.GameObjects.GameObject, object2: Phaser.GameObjects.GameObject, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * [description]
                 * @param sprite1 [description]
                 * @param sprite2 [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideSpriteVsSprite(sprite1: Phaser.GameObjects.GameObject, sprite2: Phaser.GameObjects.GameObject, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * [description]
                 * @param sprite [description]
                 * @param group [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideSpriteVsGroup(sprite: Phaser.GameObjects.GameObject, group: Phaser.GameObjects.Group, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * [description]
                 * @param group [description]
                 * @param tilemapLayer [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideGroupVsTilemapLayer(group: Phaser.GameObjects.Group, tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * [description]
                 * @param sprite [description]
                 * @param tilemapLayer [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideSpriteVsTilemapLayer(sprite: Phaser.GameObjects.GameObject, tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * TODO!
                 * @param group1 [description]
                 * @param group2 [description]
                 * @param collideCallback [description]
                 * @param processCallback [description]
                 * @param callbackContext [description]
                 * @param overlapOnly [description]
                 */
                collideGroupVsGroup(group1: Phaser.GameObjects.Group, group2: Phaser.GameObjects.Group, collideCallback: ArcadePhysicsCallback, processCallback: ArcadePhysicsCallback, callbackContext: any, overlapOnly: boolean): boolean;

                /**
                 * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.
                 * 
                 * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).
                 * @param object A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.
                 * @param padding An amount added to each boundary edge during the operation. Default 0.
                 */
                wrap(object: any, padding?: number): void;

                /**
                 * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.
                 * @param padding An amount added to the boundary. Default 0.
                 */
                wrapArray(arr: any[], padding?: number): void;

                /**
                 * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.
                 * @param object A Game Object, a Physics Body, or any object with `x` and `y` coordinates
                 * @param padding An amount added to the boundary. Default 0.
                 */
                wrapObject(object: any, padding?: number): void;

                /**
                 * [description]
                 */
                shutdown(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

        }

        /**
         * An Impact.js compatible physics world, body and solver, for those who are used
         * to the Impact way of defining and controlling physics bodies. Also works with
         * the new Loader support for Weltmeister map data.
         * 
         * World updated to run off the Phaser main loop.
         * Body extended to support additional setter functions.
         * 
         * To create the map data you'll need Weltmeister, which comes with Impact
         * and can be purchased from http://impactjs.com
         * 
         * My thanks to Dominic Szablewski for his permission to support Impact in Phaser.
         */
        namespace Impact {
            /**
             * An Impact.js compatible physics body.
             * 
             * This re-creates the properties you'd get on an Entity and the math needed to update them.
             */
            class Body {
                /**
                 * 
                 * @param world [description]
                 * @param x [description]
                 * @param y [description]
                 * @param sx [description] Default 16.
                 * @param sy [description] Default 16.
                 */
                constructor(world: Phaser.Physics.Impact.World, x: number, y: number, sx?: number, sy?: number);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Impact.World;

                /**
                 * [description]
                 */
                gameObject: Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * The ImpactBody, ImpactSprite or ImpactImage object that owns this Body, if any.
                 */
                parent: Phaser.Physics.Impact.ImpactBody | Phaser.Physics.Impact.ImpactImage | Phaser.Physics.Impact.ImpactSprite;

                /**
                 * [description]
                 */
                id: integer;

                /**
                 * [description]
                 */
                name: string;

                /**
                 * [description]
                 */
                size: Object;

                /**
                 * [description]
                 */
                offset: Object;

                /**
                 * [description]
                 */
                pos: Object;

                /**
                 * [description]
                 */
                last: Object;

                /**
                 * [description]
                 */
                vel: Object;

                /**
                 * [description]
                 */
                accel: Object;

                /**
                 * [description]
                 */
                friction: Object;

                /**
                 * [description]
                 */
                maxVel: Object;

                /**
                 * [description]
                 */
                standing: boolean;

                /**
                 * [description]
                 */
                gravityFactor: number;

                /**
                 * [description]
                 */
                bounciness: number;

                /**
                 * [description]
                 */
                minBounceVelocity: number;

                /**
                 * [description]
                 */
                accelGround: number;

                /**
                 * [description]
                 */
                accelAir: number;

                /**
                 * [description]
                 */
                jumpSpeed: number;

                /**
                 * [description]
                 */
                type: Phaser.Physics.Impact.TYPE;

                /**
                 * [description]
                 */
                checkAgainst: Phaser.Physics.Impact.TYPE;

                /**
                 * [description]
                 */
                collides: Phaser.Physics.Impact.COLLIDES;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: integer;

                /**
                 * [description]
                 */
                updateCallback: BodyUpdateCallback;

                /**
                 * min 44 deg, max 136 deg
                 */
                slopeStanding: Object;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                reset(x: number, y: number): void;

                /**
                 * [description]
                 * @param delta [description]
                 */
                update(delta: number): void;

                /**
                 * [description]
                 * @param graphic [description]
                 */
                drawDebug(graphic: Phaser.GameObjects.Graphics): void;

                /**
                 * [description]
                 */
                willDrawDebug(): boolean;

                /**
                 * [description]
                 */
                skipHash(): boolean;

                /**
                 * [description]
                 * @param other [description]
                 */
                touches(other: Phaser.Physics.Impact.Body): boolean;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                resetSize(x: number, y: number, width: number, height: number): Phaser.Physics.Impact.Body;

                /**
                 * [description]
                 */
                toJSON(): JSONImpactBody;

                /**
                 * [description]
                 * @param config [description]
                 */
                fromJSON(config: object): void;

                /**
                 * Can be overridden by user code
                 * @param other [description]
                 */
                check(other: Phaser.Physics.Impact.Body): void;

                /**
                 * Can be overridden by user code
                 * @param other [description]
                 * @param axis [description]
                 */
                collideWith(other: Phaser.Physics.Impact.Body, axis: string): void;

                /**
                 * Can be overridden by user code but must return a boolean.
                 * @param res [description]
                 */
                handleMovementTrace(res: number): boolean;

                /**
                 * [description]
                 */
                destroy(): void;

            }

            /**
             * Collision Types - Determine if and how entities collide with each other.
             * 
             * In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
             * while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
             * collisions, both entities are moved. LITE or PASSIVE entities don't collide
             * with other LITE or PASSIVE entities at all. The behavior for FIXED vs.
             * FIXED collisions is undefined.
             */
            enum COLLIDES {
                /**
                 * Never collides.
                 */
                NEVER,
                /**
                 * Lite collision.
                 */
                LITE,
                /**
                 * Passive collision.
                 */
                PASSIVE,
                /**
                 * Active collision.
                 */
                ACTIVE,
                /**
                 * Fixed collision.
                 */
                FIXED,
            }

            /**
             * [description]
             */
            class CollisionMap {
                /**
                 * 
                 * @param tilesize [description] Default 32.
                 * @param data [description]
                 */
                constructor(tilesize?: integer, data?: any[]);

                /**
                 * [description]
                 */
                tilesize: integer;

                /**
                 * [description]
                 */
                data: any[];

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                lastSlope: integer;

                /**
                 * [description]
                 */
                tiledef: object;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vx [description]
                 * @param vy [description]
                 * @param objectWidth [description]
                 * @param objectHeight [description]
                 */
                trace(x: number, y: number, vx: number, vy: number, objectWidth: number, objectHeight: number): boolean;

                /**
                 * [description]
                 * @param res [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vx [description]
                 * @param vy [description]
                 * @param width [description]
                 * @param height [description]
                 * @param rvx [description]
                 * @param rvy [description]
                 * @param step [description]
                 */
                step(res: object, x: number, y: number, vx: number, vy: number, width: number, height: number, rvx: number, rvy: number, step: number): void;

                /**
                 * [description]
                 * @param res [description]
                 * @param t [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vx [description]
                 * @param vy [description]
                 * @param width [description]
                 * @param height [description]
                 * @param tileX [description]
                 * @param tileY [description]
                 */
                checkDef(res: object, t: number, x: number, y: number, vx: number, vy: number, width: number, height: number, tileX: number, tileY: number): boolean;

            }

            namespace Components {
                /**
                 * [description]
                 */
                interface Acceleration {
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setAccelerationX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setAccelerationY(y: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description]
                     */
                    setAcceleration(x: number, y: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface BodyScale {
                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description] Default width.
                     */
                    setBodySize(width: number, height?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param scaleX [description]
                     * @param scaleY [description]
                     */
                    setBodyScale(scaleX: number, scaleY?: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface BodyType {
                    /**
                     * [description]
                     */
                    getBodyType(): number;
                    /**
                     * [description]
                     */
                    setTypeNone(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setTypeA(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setTypeB(): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Bounce {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setBounce(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setMinBounceVelocity(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    bounce: number;
                }

                /**
                 * [description]
                 */
                interface CheckAgainst {
                    /**
                     * [description]
                     */
                    setAvsB(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setBvsA(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCheckAgainstNone(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCheckAgainstA(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCheckAgainstB(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    checkAgainst: number;
                }

                /**
                 * [description]
                 */
                interface Collides {
                    /**
                     * [description]
                     * @param callback [description]
                     * @param scope [description]
                     */
                    setCollideCallback(callback: CollideCallback, scope: any): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setCollidesNever(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setLiteCollision(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setPassiveCollision(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setActiveCollision(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setFixedCollision(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    collides: number;
                }

                /**
                 * [description]
                 */
                interface Debug {
                    /**
                     * [description]
                     * @param showBody [description]
                     * @param showVelocity [description]
                     * @param bodyColor [description]
                     */
                    setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    debugShowBody: boolean;
                    /**
                     * [description]
                     */
                    debugShowVelocity: boolean;
                    /**
                     * [description]
                     */
                    debugBodyColor: number;
                }

                /**
                 * [description]
                 */
                interface Friction {
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setFrictionX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setFrictionY(y: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description]
                     */
                    setFriction(x: number, y: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Gravity {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setGravity(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    gravity: number;
                }

                /**
                 * [description]
                 */
                interface Offset {
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description]
                     * @param width [description]
                     * @param height [description]
                     */
                    setOffset(x: number, y: number, width?: number, height?: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface SetGameObject {
                    /**
                     * [description]
                     * @param gameObject [description]
                     * @param sync [description] Default true.
                     */
                    setGameObject(gameObject: Phaser.GameObjects.GameObject, sync?: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    syncGameObject(): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Velocity {
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setVelocityX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setVelocityY(y: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;
                }

            }

            /**
             * The Impact Physics Factory allows you to easily create Impact Physics enabled Game Objects.
             * 
             * Objects that are created by this Factory are automatically added to the physics world.
             */
            class Factory {
                /**
                 * 
                 * @param world [description]
                 */
                constructor(world: Phaser.Physics.Impact.World);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Impact.World;

                /**
                 * A reference to the Scene.Systems this Impact Physics instance belongs to.
                 */
                sys: Phaser.Scenes.Systems;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                body(x: number, y: number, width: number, height: number): Phaser.Physics.Impact.ImpactBody;

                /**
                 * Adds an Impact Physics Body to the given Game Object.
                 * @param gameObject [description]
                 */
                existing(gameObject: Phaser.GameObjects.GameObject): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                image(x: number, y: number, key: string, frame?: string | integer): Phaser.Physics.Impact.ImpactImage;

                /**
                 * [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                sprite(x: number, y: number, key: string, frame?: string | integer): Phaser.Physics.Impact.ImpactSprite;

                /**
                 * Destroys this Factory.
                 */
                destroy(): void;

            }

            /**
             * [description]
             * @param delta [description]
             * @param vel [description]
             * @param accel [description]
             * @param friction [description]
             * @param max [description]
             */
            function GetVelocity(delta: number, vel: number, accel: number, friction: number, max: number): number;

            /**
             * [description]
             */
            class ImpactBody implements Phaser.Physics.Impact.Components.Acceleration, Phaser.Physics.Impact.Components.BodyScale, Phaser.Physics.Impact.Components.BodyType, Phaser.Physics.Impact.Components.Bounce, Phaser.Physics.Impact.Components.CheckAgainst, Phaser.Physics.Impact.Components.Collides, Phaser.Physics.Impact.Components.Debug, Phaser.Physics.Impact.Components.Friction, Phaser.Physics.Impact.Components.Gravity, Phaser.Physics.Impact.Components.Offset, Phaser.Physics.Impact.Components.SetGameObject, Phaser.Physics.Impact.Components.Velocity {
                /**
                 * 
                 * @param world [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                constructor(world: Phaser.Physics.Impact.World, x: number, y: number, width: number, height: number);

                /**
                 * [description]
                 */
                body: Phaser.Physics.Impact.Body;

                /**
                 * [description]
                 */
                size: Object;

                /**
                 * [description]
                 */
                offset: Object;

                /**
                 * [description]
                 */
                vel: Object;

                /**
                 * [description]
                 */
                accel: Object;

                /**
                 * [description]
                 */
                friction: Object;

                /**
                 * [description]
                 */
                maxVel: Object;

                /**
                 * [description]
                 * @param x [description]
                 */
                setAccelerationX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setAccelerationY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setAcceleration(x: number, y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description] Default width.
                 */
                setBodySize(width: number, height?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param scaleX [description]
                 * @param scaleY [description]
                 */
                setBodyScale(scaleX: number, scaleY?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                getBodyType(): number;

                /**
                 * [description]
                 */
                setTypeNone(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setTypeA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setTypeB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounce(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMinBounceVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                bounce: number;

                /**
                 * [description]
                 */
                setAvsB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setBvsA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstNone(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                checkAgainst: number;

                /**
                 * [description]
                 * @param callback [description]
                 * @param scope [description]
                 */
                setCollideCallback(callback: CollideCallback, scope: any): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCollidesNever(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setLiteCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setPassiveCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setActiveCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setFixedCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                collides: number;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setOffset(x: number, y: number, width?: number, height?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param gameObject [description]
                 * @param sync [description] Default true.
                 */
                setGameObject(gameObject: Phaser.GameObjects.GameObject, sync?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                syncGameObject(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * An Impact Physics Image Game Object.
             * 
             * 
             * 
             * An Image is a light-weight Game Object useful for the display of static images in your game,
             * 
             * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
             * 
             * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
             * 
             * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
             */
            class ImpactImage extends Phaser.GameObjects.Image implements Phaser.Physics.Impact.Components.Acceleration, Phaser.Physics.Impact.Components.BodyScale, Phaser.Physics.Impact.Components.BodyType, Phaser.Physics.Impact.Components.Bounce, Phaser.Physics.Impact.Components.CheckAgainst, Phaser.Physics.Impact.Components.Collides, Phaser.Physics.Impact.Components.Debug, Phaser.Physics.Impact.Components.Friction, Phaser.Physics.Impact.Components.Gravity, Phaser.Physics.Impact.Components.Offset, Phaser.Physics.Impact.Components.SetGameObject, Phaser.Physics.Impact.Components.Velocity, Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(world: Phaser.Physics.Impact.World, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * [description]
                 */
                body: Phaser.Physics.Impact.Body;

                /**
                 * [description]
                 */
                size: Object;

                /**
                 * [description]
                 */
                offset: Object;

                /**
                 * [description]
                 */
                vel: Object;

                /**
                 * [description]
                 */
                accel: Object;

                /**
                 * [description]
                 */
                friction: Object;

                /**
                 * [description]
                 */
                maxVel: Object;

                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setAccelerationX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setAccelerationY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setAcceleration(x: number, y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description] Default width.
                 */
                setBodySize(width: number, height?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param scaleX [description]
                 * @param scaleY [description]
                 */
                setBodyScale(scaleX: number, scaleY?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                getBodyType(): number;

                /**
                 * [description]
                 */
                setTypeNone(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setTypeA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setTypeB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounce(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMinBounceVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                bounce: number;

                /**
                 * [description]
                 */
                setAvsB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setBvsA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstNone(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                checkAgainst: number;

                /**
                 * [description]
                 * @param callback [description]
                 * @param scope [description]
                 */
                setCollideCallback(callback: CollideCallback, scope: any): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCollidesNever(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setLiteCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setPassiveCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setActiveCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setFixedCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                collides: number;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setOffset(x: number, y: number, width?: number, height?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param gameObject [description]
                 * @param sync [description] Default true.
                 */
                setGameObject(gameObject: Phaser.GameObjects.GameObject, sync?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                syncGameObject(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * [description]
             */
            class ImpactPhysics {
                /**
                 * 
                 * @param scene [description]
                 */
                constructor(scene: Phaser.Scene);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                systems: Phaser.Scenes.Systems;

                /**
                 * [description]
                 */
                config: object;

                /**
                 * [description]
                 */
                world: Phaser.Physics.Impact.World;

                /**
                 * [description]
                 */
                add: Phaser.Physics.Impact.Factory;

                /**
                 * [description]
                 */
                getConfig(): object;

                /**
                 * [description]
                 */
                pause(): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 */
                resume(): Phaser.Physics.Impact.World;

            }

            /**
             * An Impact Physics Sprite Game Object.
             * 
             * 
             * 
             * A Sprite Game Object is used for the display of both static and animated images in your game.
             * 
             * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
             * 
             * and animated.
             * 
             * 
             * 
             * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
             * 
             * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
             * 
             * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
             */
            class ImpactSprite extends Phaser.GameObjects.Sprite implements Phaser.Physics.Impact.Components.Acceleration, Phaser.Physics.Impact.Components.BodyScale, Phaser.Physics.Impact.Components.BodyType, Phaser.Physics.Impact.Components.Bounce, Phaser.Physics.Impact.Components.CheckAgainst, Phaser.Physics.Impact.Components.Collides, Phaser.Physics.Impact.Components.Debug, Phaser.Physics.Impact.Components.Friction, Phaser.Physics.Impact.Components.Gravity, Phaser.Physics.Impact.Components.Offset, Phaser.Physics.Impact.Components.SetGameObject, Phaser.Physics.Impact.Components.Velocity, Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 */
                constructor(world: Phaser.Physics.Impact.World, x: number, y: number, texture: string, frame?: string | integer);

                /**
                 * [description]
                 */
                body: Phaser.Physics.Impact.Body;

                /**
                 * [description]
                 */
                size: Object;

                /**
                 * [description]
                 */
                offset: Object;

                /**
                 * [description]
                 */
                vel: Object;

                /**
                 * [description]
                 */
                accel: Object;

                /**
                 * [description]
                 */
                friction: Object;

                /**
                 * [description]
                 */
                maxVel: Object;

                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setAccelerationX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setAccelerationY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setAcceleration(x: number, y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description] Default width.
                 */
                setBodySize(width: number, height?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param scaleX [description]
                 * @param scaleY [description]
                 */
                setBodyScale(scaleX: number, scaleY?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                getBodyType(): number;

                /**
                 * [description]
                 */
                setTypeNone(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setTypeA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setTypeB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounce(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMinBounceVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                bounce: number;

                /**
                 * [description]
                 */
                setAvsB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setBvsA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstNone(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstA(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCheckAgainstB(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                checkAgainst: number;

                /**
                 * [description]
                 * @param callback [description]
                 * @param scope [description]
                 */
                setCollideCallback(callback: CollideCallback, scope: any): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setCollidesNever(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setLiteCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setPassiveCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setActiveCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                setFixedCollision(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                collides: number;

                /**
                 * [description]
                 * @param showBody [description]
                 * @param showVelocity [description]
                 * @param bodyColor [description]
                 */
                setDebug(showBody: boolean, showVelocity: boolean, bodyColor: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDebugBodyColor(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                debugShowBody: boolean;

                /**
                 * [description]
                 */
                debugShowVelocity: boolean;

                /**
                 * [description]
                 */
                debugBodyColor: number;

                /**
                 * [description]
                 * @param x [description]
                 */
                setFrictionX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setFrictionY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFriction(x: number, y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setGravity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                setOffset(x: number, y: number, width?: number, height?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param gameObject [description]
                 * @param sync [description] Default true.
                 */
                setGameObject(gameObject: Phaser.GameObjects.GameObject, sync?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                syncGameObject(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setMaxVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * [description]
             * @param world [description]
             * @param left [description]
             * @param right [description]
             * @param weak [description]
             */
            function SeperateX(world: Phaser.Physics.Impact.World, left: Phaser.Physics.Impact.Body, right: Phaser.Physics.Impact.Body, weak?: Phaser.Physics.Impact.Body): void;

            /**
             * [description]
             * @param world [description]
             * @param top [description]
             * @param bottom [description]
             * @param weak [description]
             */
            function SeperateY(world: Phaser.Physics.Impact.World, top: Phaser.Physics.Impact.Body, bottom: Phaser.Physics.Impact.Body, weak?: Phaser.Physics.Impact.Body): void;

            /**
             * Impact Physics Solver
             * @param world [description]
             * @param bodyA [description]
             * @param bodyB [description]
             */
            function Solver(world: Phaser.Physics.Impact.World, bodyA: Phaser.Physics.Impact.Body, bodyB: Phaser.Physics.Impact.Body): void;

            /**
             * Collision Types - Determine if and how entities collide with each other.
             * 
             * In ACTIVE vs. LITE or FIXED vs. ANY collisions, only the "weak" entity moves,
             * while the other one stays fixed. In ACTIVE vs. ACTIVE and ACTIVE vs. PASSIVE
             * collisions, both entities are moved. LITE or PASSIVE entities don't collide
             * with other LITE or PASSIVE entities at all. The behavior for FIXED vs.
             * FIXED collisions is undefined.
             */
            enum TYPE {
                /**
                 * Collides with nothing.
                 */
                NONE,
                /**
                 * Type A. Collides with Type B.
                 */
                A,
                /**
                 * Type B. Collides with Type A.
                 */
                B,
                /**
                 * Collides with both types A and B.
                 */
                BOTH,
            }

            /**
             * Set up the trace-result
             * var res = {
             *     collision: {x: false, y: false, slope: false},
             *     pos: {x: x, y: y},
             *     tile: {x: 0, y: 0}
             * };
             * @param body [description]
             * @param res [description]
             */
            function UpdateMotion(body: Phaser.Physics.Impact.Body, res: object): void;

            type WorldConfig = {
                /**
                 * [description]
                 */
                gravity?: number;
                /**
                 * [description]
                 */
                cellSize?: number;
                /**
                 * [description]
                 */
                timeScale?: number;
                /**
                 * [description]
                 */
                maxStep?: number;
                /**
                 * [description]
                 */
                debug?: boolean;
                /**
                 * [description]
                 */
                maxVelocity?: number;
                /**
                 * [description]
                 */
                debugShowBody?: boolean;
                /**
                 * [description]
                 */
                debugShowVelocity?: boolean;
                /**
                 * [description]
                 */
                debugBodyColor?: number;
                /**
                 * [description]
                 */
                debugVelocityColor?: number;
                /**
                 * [description]
                 */
                maxVelocityX?: number;
                /**
                 * [description]
                 */
                maxVelocityY?: number;
                /**
                 * [description]
                 */
                minBounceVelocity?: number;
                /**
                 * [description]
                 */
                gravityFactor?: number;
                /**
                 * [description]
                 */
                bounciness?: number;
                /**
                 * [description]
                 */
                setBounds?: object | boolean;
                /**
                 * [description]
                 */
                "setBounds.x"?: number;
                /**
                 * [description]
                 */
                "setBounds.y"?: number;
                /**
                 * [description]
                 */
                "setBounds.width"?: number;
                /**
                 * [description]
                 */
                "setBounds.height"?: number;
                /**
                 * [description]
                 */
                "setBounds.thickness"?: number;
                /**
                 * [description]
                 */
                "setBounds.left"?: boolean;
                /**
                 * [description]
                 */
                "setBounds.right"?: boolean;
                /**
                 * [description]
                 */
                "setBounds.top"?: boolean;
                /**
                 * [description]
                 */
                "setBounds.bottom"?: boolean;
            };

            /**
             * An object containing the 4 wall bodies that bound the physics world.
             */
            type WorldDefaults = {
                /**
                 * [description]
                 */
                debugShowBody: boolean;
                /**
                 * [description]
                 */
                debugShowVelocity: boolean;
                /**
                 * [description]
                 */
                bodyDebugColor: number;
                /**
                 * [description]
                 */
                velocityDebugColor: number;
                /**
                 * [description]
                 */
                maxVelocityX: number;
                /**
                 * [description]
                 */
                maxVelocityY: number;
                /**
                 * [description]
                 */
                minBounceVelocity: number;
                /**
                 * [description]
                 */
                gravityFactor: number;
                /**
                 * [description]
                 */
                bounciness: number;
            };

            type WorldWalls = {
                /**
                 * [description]
                 */
                left: Phaser.Physics.Impact.Body;
                /**
                 * [description]
                 */
                right: Phaser.Physics.Impact.Body;
                /**
                 * [description]
                 */
                top: Phaser.Physics.Impact.Body;
                /**
                 * [description]
                 */
                bottom: Phaser.Physics.Impact.Body;
            };

            /**
             * [description]
             */
            class World extends Phaser.Events.EventEmitter {
                /**
                 * 
                 * @param scene [description]
                 * @param config [description]
                 */
                constructor(scene: Phaser.Scene, config: Phaser.Physics.Impact.WorldConfig);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                bodies: Phaser.Structs.Set<Phaser.Physics.Impact.Body>;

                /**
                 * [description]
                 */
                gravity: number;

                /**
                 * Spatial hash cell dimensions
                 */
                cellSize: integer;

                /**
                 * [description]
                 */
                collisionMap: Phaser.Physics.Impact.CollisionMap;

                /**
                 * [description]
                 */
                timeScale: number;

                /**
                 * Impacts maximum time step is 20 fps.
                 */
                maxStep: number;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * [description]
                 */
                drawDebug: boolean;

                /**
                 * [description]
                 */
                debugGraphic: Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 */
                defaults: Phaser.Physics.Impact.WorldDefaults;

                /**
                 * An object containing the 4 wall bodies that bound the physics world.
                 */
                walls: Phaser.Physics.Impact.WorldWalls;

                /**
                 * [description]
                 */
                delta: number;

                /**
                 * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from
                 * a 2D array. If loading from a Weltmeister level, the map must have a layer called "collision".
                 * @param key Either a string key that corresponds to a Weltmeister level
                 * in the cache, or a 2D array of collision IDs.
                 * @param tileSize The size of a tile. This is optional if loading from a Weltmeister
                 * level in the cache.
                 */
                setCollisionMap(key: string | integer[][], tileSize: integer): Phaser.Physics.Impact.CollisionMap;

                /**
                 * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as
                 * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of
                 * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can
                 * manually create a slopeMap that stores the mapping between tile indices and slope IDs.
                 * @param tilemapLayer The tilemap layer to use.
                 * @param options Options for controlling the mapping from tiles to slope IDs.
                 * @param options.slopeTileProperty Slope IDs can be stored on tiles directly
                 * using Tiled's tileset editor. If a tile has a property with the given slopeTileProperty string
                 * name, the value of that property for the tile will be used for its slope mapping. E.g. a 45
                 * degree slope upward could be given a "slope" property with a value of 2. Default null.
                 * @param options.slopeMap A tile index to slope definition map. Default null.
                 * @param options.defaultCollidingSlope If specified, the default slope ID to
                 * assign to a colliding tile. If not specified, the tile's index is used. Default null.
                 * @param options.defaultNonCollidingSlope The default slope ID to assign to a
                 * non-colliding tile. Default 0.
                 */
                setCollisionMapFromTilemapLayer(tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer, options?: object): Phaser.Physics.Impact.CollisionMap;

                /**
                 * Sets the bounds of the Physics world to match the given world pixel dimensions.
                 * You can optionally set which 'walls' to create: left, right, top or bottom.
                 * If none of the walls are given it will default to use the walls settings it had previously.
                 * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
                 * the newly created bounds will also not have the left and right walls.
                 * Explicitly state them in the parameters to override this.
                 * @param x The x coordinate of the top-left corner of the bounds.
                 * @param y The y coordinate of the top-left corner of the bounds.
                 * @param width The width of the bounds.
                 * @param height The height of the bounds.
                 * @param thickness [description] Default 64.
                 * @param left If true will create the left bounds wall. Default true.
                 * @param right If true will create the right bounds wall. Default true.
                 * @param top If true will create the top bounds wall. Default true.
                 * @param bottom If true will create the bottom bounds wall. Default true.
                 */
                setBounds(x?: number, y?: number, width?: number, height?: number, thickness?: number, left?: boolean, right?: boolean, top?: boolean, bottom?: boolean): Phaser.Physics.Impact.World;

                /**
                 * position = 'left', 'right', 'top' or 'bottom'
                 * @param add [description]
                 * @param position [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                updateWall(add: boolean, position: string, x: number, y: number, width: number, height: number): void;

                /**
                 * [description]
                 */
                createDebugGraphic(): Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 */
                getNextID(): integer;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param sizeX [description]
                 * @param sizeY [description]
                 */
                create(x: number, y: number, sizeX: number, sizeY: number): Phaser.Physics.Impact.Body;

                /**
                 * [description]
                 * @param object The Body to remove from this World.
                 */
                remove(object: Phaser.Physics.Impact.Body): void;

                /**
                 * [description]
                 */
                pause(): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 */
                resume(): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param time [description]
                 * @param delta [description]
                 */
                update(time: number, delta: number): void;

                /**
                 * Check the body against the spatial hash.
                 * @param body [description]
                 * @param hash [description]
                 * @param size [description]
                 */
                checkHash(body: Phaser.Physics.Impact.Body, hash: object, size: number): void;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 */
                checkBodies(bodyA: Phaser.Physics.Impact.Body, bodyB: Phaser.Physics.Impact.Body): void;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setCollidesNever(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setLite(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setPassive(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setActive(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the collides value on.
                 */
                setFixed(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setTypeNone(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setTypeA(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setTypeB(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setAvsB(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setBvsA(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setCheckAgainstNone(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setCheckAgainstA(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 * @param bodies An Array of Impact Bodies to set the type value on.
                 */
                setCheckAgainstB(bodies: Phaser.Physics.Impact.Body[]): Phaser.Physics.Impact.World;

                /**
                 * [description]
                 */
                shutdown(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

        }

        namespace Matter {
            namespace Components {
                /**
                 * [description]
                 */
                interface Bounce {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setBounce(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Collision {
                    /**
                     * [description]
                     * @param value Unique category bitfield.
                     */
                    setCollisionCategory(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value Unique group index.
                     */
                    setCollisionGroup(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param categories A unique category bitfield, or an array of them.
                     */
                    setCollidesWith(categories: number | number[]): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Force {
                    /**
                     * [description]
                     * @param force [description]
                     */
                    applyForce(force: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param position [description]
                     * @param force [description]
                     */
                    applyForceFrom(position: Phaser.Math.Vector2, force: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param speed [description]
                     */
                    thrust(speed: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param speed [description]
                     */
                    thrustLeft(speed: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param speed [description]
                     */
                    thrustRight(speed: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param speed [description]
                     */
                    thrustBack(speed: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Friction {
                    /**
                     * [description]
                     * @param value [description]
                     * @param air [description]
                     * @param fstatic [description]
                     */
                    setFriction(value: number, air?: number, fstatic?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setFrictionAir(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setFrictionStatic(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Gravity {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setIgnoreGravity(value: boolean): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Mass {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setMass(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setDensity(value: number): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Sensor {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setSensor(value: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    isSensor(): boolean;
                }

                /**
                 * [description]
                 */
                interface SetBody {
                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param options [description]
                     */
                    setRectangle(width: number, height: number, options: object): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param radius [description]
                     * @param options [description]
                     */
                    setCircle(radius: number, options: object): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param radius [description]
                     * @param sides [description]
                     * @param options [description]
                     */
                    setPolygon(radius: number, sides: number, options: object): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param slope [description]
                     * @param options [description]
                     */
                    setTrapezoid(width: number, height: number, slope: number, options: object): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param body [description]
                     * @param addToWorld [description] Default true.
                     */
                    setExistingBody(body: MatterJS.Body, addToWorld?: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param config [description]
                     * @param options [description]
                     */
                    setBody(config: object, options: object): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Sleep {
                    /**
                     * [description]
                     * @param value [description] Default 60.
                     */
                    setSleepThreshold(value?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param start [description]
                     * @param end [description]
                     */
                    setSleepEvents(start: boolean, end: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setSleepStartEvent(value: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setSleepEndEvent(value: boolean): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Static {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setStatic(value: boolean): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    isStatic(): boolean;
                }

                /**
                 * [description]
                 */
                interface Transform {
                    /**
                     * [description]
                     */
                    x: number;
                    /**
                     * [description]
                     */
                    y: number;
                    /**
                     * [description]
                     */
                    scaleX: number;
                    /**
                     * [description]
                     */
                    scaleY: number;
                    /**
                     * [description]
                     */
                    angle: number;
                    /**
                     * [description]
                     */
                    rotation: number;
                    /**
                     * [description]
                     * @param x [description] Default 0.
                     * @param y [description] Default x.
                     */
                    setPosition(x?: number, y?: number): void;
                    /**
                     * [description]
                     * @param radians [description] Default 0.
                     */
                    setRotation(radians?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     */
                    setFixedRotation(): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param degrees [description] Default 0.
                     */
                    setAngle(degrees?: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description] Default 1.
                     * @param y [description] Default x.
                     * @param point [description]
                     */
                    setScale(x?: number, y?: number, point?: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;
                }

                /**
                 * [description]
                 */
                interface Velocity {
                    /**
                     * [description]
                     * @param value [description]
                     */
                    setAngularVelocity(value: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     */
                    setVelocityX(x: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param y [description]
                     */
                    setVelocityY(y: number): Phaser.GameObjects.GameObject;
                    /**
                     * [description]
                     * @param x [description]
                     * @param y [description] Default x.
                     */
                    setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;
                }

            }

            /**
             * [description]
             */
            class Factory {
                /**
                 * 
                 * @param world [description]
                 */
                constructor(world: Phaser.Physics.Matter.World);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Matter.World;

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * A reference to the Scene.Systems this Matter Physics instance belongs to.
                 */
                sys: Phaser.Scenes.Systems;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 * @param options [description]
                 */
                rectangle(x: number, y: number, width: number, height: number, options: object): MatterJS.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 * @param slope [description]
                 * @param options [description]
                 */
                trapezoid(x: number, y: number, width: number, height: number, slope: number, options: object): MatterJS.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param radius [description]
                 * @param options [description]
                 * @param maxSides [description]
                 */
                circle(x: number, y: number, radius: number, options: object, maxSides: number): MatterJS.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param sides [description]
                 * @param radius [description]
                 * @param options [description]
                 */
                polygon(x: number, y: number, sides: number, radius: number, options: object): MatterJS.Body;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param vertexSets [description]
                 * @param options [description]
                 * @param flagInternal [description]
                 * @param removeCollinear [description]
                 * @param minimumArea [description]
                 */
                fromVertices(x: number, y: number, vertexSets: any[], options: object, flagInternal: boolean, removeCollinear: boolean, minimumArea: number): MatterJS.Body;

                /**
                 * Create a new composite containing Matter Image objects created in a grid arrangement.
                 * This function uses the body bounds to prevent overlaps.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the grid.
                 * @param rows The number of rows in the grid.
                 * @param columnGap The distance between each column. Default 0.
                 * @param rowGap The distance between each row. Default 0.
                 * @param options [description]
                 */
                imageStack(key: string, frame: string | integer, x: number, y: number, columns: number, rows: number, columnGap?: number, rowGap?: number, options?: object): MatterJS.Composite;

                /**
                 * Create a new composite containing bodies created in the callback in a grid arrangement.
                 * This function uses the body bounds to prevent overlaps.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the grid.
                 * @param rows The number of rows in the grid.
                 * @param columnGap The distance between each column.
                 * @param rowGap The distance between each row.
                 * @param callback The callback that creates the stack.
                 */
                stack(x: number, y: number, columns: number, rows: number, columnGap: number, rowGap: number, callback: Function): MatterJS.Composite;

                /**
                 * Create a new composite containing bodies created in the callback in a pyramid arrangement.
                 * This function uses the body bounds to prevent overlaps.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the pyramid.
                 * @param rows The number of rows in the pyramid.
                 * @param columnGap The distance between each column.
                 * @param rowGap The distance between each row.
                 * @param callback [description]
                 */
                pyramid(x: number, y: number, columns: number, rows: number, columnGap: number, rowGap: number, callback: Function): MatterJS.Composite;

                /**
                 * Chains all bodies in the given composite together using constraints.
                 * @param composite [description]
                 * @param xOffsetA [description]
                 * @param yOffsetA [description]
                 * @param xOffsetB [description]
                 * @param yOffsetB [description]
                 * @param options [description]
                 */
                chain(composite: MatterJS.Composite, xOffsetA: number, yOffsetA: number, xOffsetB: number, yOffsetB: number, options: object): MatterJS.Composite;

                /**
                 * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.
                 * @param composite [description]
                 * @param columns [description]
                 * @param rows [description]
                 * @param crossBrace [description]
                 * @param options [description]
                 */
                mesh(composite: MatterJS.Composite, columns: number, rows: number, crossBrace: boolean, options: object): MatterJS.Composite;

                /**
                 * Creates a composite with a Newton's Cradle setup of bodies and constraints.
                 * @param x [description]
                 * @param y [description]
                 * @param number [description]
                 * @param size [description]
                 * @param length [description]
                 */
                newtonsCradle(x: number, y: number, number: number, size: number, length: number): MatterJS.Composite;

                /**
                 * Creates a composite with simple car setup of bodies and constraints.
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 * @param wheelSize [description]
                 */
                car(x: number, y: number, width: number, height: number, wheelSize: number): MatterJS.Composite;

                /**
                 * Creates a simple soft body like object.
                 * @param x The horizontal position of this composite in the world.
                 * @param y The vertical position of this composite in the world.
                 * @param columns The number of columns in the Composite.
                 * @param rows The number of rows in the Composite.
                 * @param columnGap The distance between each column.
                 * @param rowGap The distance between each row.
                 * @param crossBrace [description]
                 * @param particleRadius [description]
                 * @param particleOptions [description]
                 * @param constraintOptions [description]
                 */
                softBody(x: number, y: number, columns: number, rows: number, columnGap: number, rowGap: number, crossBrace: boolean, particleRadius: number, particleOptions: object, constraintOptions: object): MatterJS.Composite;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                joint(bodyA: MatterJS.Body, bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                spring(bodyA: MatterJS.Body, bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param bodyA [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                constraint(bodyA: MatterJS.Body, bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param bodyB [description]
                 * @param length [description]
                 * @param stiffness [description] Default 1.
                 * @param options [description] Default {}.
                 */
                worldConstraint(bodyB: MatterJS.Body, length: number, stiffness?: number, options?: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param options [description]
                 */
                mouseSpring(options: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param options [description]
                 */
                pointerConstraint(options: object): MatterJS.Constraint;

                /**
                 * [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
                 * @param options [description] Default {}.
                 */
                image(x: number, y: number, key: string, frame?: string | integer, options?: object): Phaser.Physics.Matter.Image;

                /**
                 * [description]
                 * @param tile [description]
                 * @param options [description]
                 */
                tileBody(tile: Phaser.Tilemaps.Tile, options: object): Phaser.Physics.Matter.TileBody;

                /**
                 * [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param key The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with. Set to `null` to skip this value.
                 * @param options [description] Default {}.
                 */
                sprite(x: number, y: number, key: string, frame?: string | integer, options?: object): Phaser.Physics.Matter.Sprite;

                /**
                 * [description]
                 * @param gameObject The Game Object to inject the Matter Body in to.
                 * @param options [description]
                 */
                gameObject(gameObject: Phaser.GameObjects.GameObject, options: object): Phaser.GameObjects.GameObject;

                /**
                 * Destroys this Factory.
                 */
                destroy(): void;

            }

            /**
             * [description]
             * @param world [description]
             * @param gameObject [description]
             * @param options [description]
             */
            function MatterGameObject(world: Phaser.Physics.Matter.World, gameObject: Phaser.GameObjects.GameObject, options: object): Phaser.GameObjects.GameObject;

            /**
             * A Matter Physics Image Game Object.
             * 
             * 
             * 
             * An Image is a light-weight Game Object useful for the display of static images in your game,
             * 
             * such as logos, backgrounds, scenery or other non-animated elements. Images can have input
             * 
             * events and physics bodies, or be tweened, tinted or scrolled. The main difference between an
             * 
             * Image and a Sprite is that you cannot animate an Image as they do not have the Animation component.
             */
            class Image extends Phaser.GameObjects.Image implements Phaser.Physics.Matter.Components.Bounce, Phaser.Physics.Matter.Components.Collision, Phaser.Physics.Matter.Components.Force, Phaser.Physics.Matter.Components.Friction, Phaser.Physics.Matter.Components.Gravity, Phaser.Physics.Matter.Components.Mass, Phaser.Physics.Matter.Components.Sensor, Phaser.Physics.Matter.Components.SetBody, Phaser.Physics.Matter.Components.Sleep, Phaser.Physics.Matter.Components.Static, Phaser.Physics.Matter.Components.Transform, Phaser.Physics.Matter.Components.Velocity, Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 * @param options Matter.js configuration object. Default {}.
                 */
                constructor(world: Phaser.Physics.Matter.World, x: number, y: number, texture: string, frame?: string | integer, options?: object);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Matter.World;

                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounce(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value Unique category bitfield.
                 */
                setCollisionCategory(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value Unique group index.
                 */
                setCollisionGroup(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param categories A unique category bitfield, or an array of them.
                 */
                setCollidesWith(categories: number | number[]): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param force [description]
                 */
                applyForce(force: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param position [description]
                 * @param force [description]
                 */
                applyForceFrom(position: Phaser.Math.Vector2, force: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrust(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrustLeft(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrustRight(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrustBack(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 * @param air [description]
                 * @param fstatic [description]
                 */
                setFriction(value: number, air?: number, fstatic?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionAir(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionStatic(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setIgnoreGravity(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDensity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSensor(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                isSensor(): boolean;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param options [description]
                 */
                setRectangle(width: number, height: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param options [description]
                 */
                setCircle(radius: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param sides [description]
                 * @param options [description]
                 */
                setPolygon(radius: number, sides: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param slope [description]
                 * @param options [description]
                 */
                setTrapezoid(width: number, height: number, slope: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param body [description]
                 * @param addToWorld [description] Default true.
                 */
                setExistingBody(body: MatterJS.Body, addToWorld?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param config [description]
                 * @param options [description]
                 */
                setBody(config: object, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description] Default 60.
                 */
                setSleepThreshold(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param start [description]
                 * @param end [description]
                 */
                setSleepEvents(start: boolean, end: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepStartEvent(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepEndEvent(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setStatic(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                isStatic(): boolean;

                /**
                 * [description]
                 */
                setFixedRotation(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * [description]
             */
            class MatterPhysics {
                /**
                 * 
                 * @param scene [description]
                 */
                constructor(scene: Phaser.Scene);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                systems: Phaser.Scenes.Systems;

                /**
                 * [description]
                 */
                config: object;

                /**
                 * [description]
                 */
                world: Phaser.Physics.Matter.World;

                /**
                 * [description]
                 */
                add: Phaser.Physics.Matter.Factory;

                /**
                 * [description]
                 */
                getConfig(): object;

                /**
                 * [description]
                 */
                enableAttractorPlugin(): Phaser.Physics.Matter.MatterPhysics;

                /**
                 * [description]
                 */
                enableWrapPlugin(): Phaser.Physics.Matter.MatterPhysics;

                /**
                 * [description]
                 */
                pause(): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 */
                resume(): Phaser.Physics.Matter.World;

                /**
                 * Sets the Matter Engine to run at fixed timestep of 60Hz and enables `autoUpdate`.
                 * If you have set a custom `getDelta` function then this will override it.
                 */
                set60Hz(): Phaser.Physics.Matter.MatterPhysics;

                /**
                 * Sets the Matter Engine to run at fixed timestep of 30Hz and enables `autoUpdate`.
                 * If you have set a custom `getDelta` function then this will override it.
                 */
                set30Hz(): Phaser.Physics.Matter.MatterPhysics;

                /**
                 * Manually advances the physics simulation by one iteration.
                 * 
                 * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.
                 * If undefined they use the Matter defaults of 60Hz and no correction.
                 * 
                 * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.
                 * 
                 * It also ignores any custom `getDelta` functions, as you should be passing the delta
                 * value in to this call.
                 * 
                 * You can adjust the number of iterations that Engine.update performs internally.
                 * Use the Scene Matter Physics config object to set the following properties:
                 * 
                 * positionIterations (defaults to 6)
                 * velocityIterations (defaults to 4)
                 * constraintIterations (defaults to 2)
                 * 
                 * Adjusting these values can help performance in certain situations, depending on the physics requirements
                 * of your game.
                 * @param delta [description] Default 16.666.
                 * @param correction [description] Default 1.
                 */
                step(delta?: number, correction?: number): void;

            }

            /**
             * A Matter Physics Sprite Game Object.
             * 
             * 
             * 
             * A Sprite Game Object is used for the display of both static and animated images in your game.
             * 
             * Sprites can have input events and physics bodies. They can also be tweened, tinted, scrolled
             * 
             * and animated.
             * 
             * 
             * 
             * The main difference between a Sprite and an Image Game Object is that you cannot animate Images.
             * 
             * As such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation
             * 
             * Component. If you do not require animation then you can safely use Images to replace Sprites in all cases.
             */
            class Sprite extends Phaser.GameObjects.Sprite implements Phaser.Physics.Matter.Components.Bounce, Phaser.Physics.Matter.Components.Collision, Phaser.Physics.Matter.Components.Force, Phaser.Physics.Matter.Components.Friction, Phaser.Physics.Matter.Components.Gravity, Phaser.Physics.Matter.Components.Mass, Phaser.Physics.Matter.Components.Sensor, Phaser.Physics.Matter.Components.SetBody, Phaser.Physics.Matter.Components.Sleep, Phaser.Physics.Matter.Components.Static, Phaser.Physics.Matter.Components.Transform, Phaser.Physics.Matter.Components.Velocity, Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Size, Phaser.GameObjects.Components.Texture, Phaser.GameObjects.Components.Tint, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
                /**
                 * 
                 * @param world [description]
                 * @param x The horizontal position of this Game Object in the world.
                 * @param y The vertical position of this Game Object in the world.
                 * @param texture The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.
                 * @param frame An optional frame from the Texture this Game Object is rendering with.
                 * @param options Matter.js configuration object. Default {}.
                 */
                constructor(world: Phaser.Physics.Matter.World, x: number, y: number, texture: string, frame?: string | integer, options?: object);

                /**
                 * [description]
                 */
                world: Phaser.Physics.Matter.World;

                /**
                 * Clears all alpha values associated with this Game Object.
                 * Immediately sets the alpha levels back to 1 (fully opaque)
                 */
                clearAlpha(): Phaser.GameObjects.GameObject;

                /**
                 * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
                 * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
                 * 
                 * If your game is running under WebGL you can optionally specify four different alpha values, each of which
                 * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
                 * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
                 * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
                 * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
                 * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
                 */
                setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

                /**
                 * The alpha value of the Game Object.
                 * 
                 * This is a global value, impacting the entire Game Object, not just a region of it.
                 */
                alpha: number;

                /**
                 * The alpha value starting from the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopLeft: number;

                /**
                 * The alpha value starting from the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaTopRight: number;

                /**
                 * The alpha value starting from the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomLeft: number;

                /**
                 * The alpha value starting from the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                alphaBottomRight: number;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 */
                blendMode: Phaser.BlendModes | string;

                /**
                 * Sets the Blend Mode being used by this Game Object.
                 * 
                 * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
                 * 
                 * Under WebGL only the following Blend Modes are available:
                 * 
                 * * ADD
                 * * MULTIPLY
                 * * SCREEN
                 * 
                 * Canvas has more available depending on browser support.
                 * 
                 * You can also create your own custom Blend Modes in WebGL.
                 * 
                 * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
                 * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
                 * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
                 * are used.
                 * @param value The BlendMode value. Either a string or a CONST.
                 */
                setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 */
                depth: number;

                /**
                 * The depth of this Game Object within the Scene.
                 * 
                 * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
                 * of Game Objects, without actually moving their position in the display list.
                 * 
                 * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
                 * value will always render in front of one with a lower value.
                 * 
                 * Setting the depth will queue a depth sort event within the Scene.
                 * @param value The depth of this Game Object.
                 */
                setDepth(value: integer): Phaser.GameObjects.GameObject;

                /**
                 * The horizontally flipped state of the Game Object.
                 * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipX: boolean;

                /**
                 * The vertically flipped state of the Game Object.
                 * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
                 * Flipping always takes place from the middle of the texture and does not impact the scale value.
                 */
                flipY: boolean;

                /**
                 * Toggles the horizontal flipped state of this Game Object.
                 */
                toggleFlipX(): Phaser.GameObjects.GameObject;

                /**
                 * Toggles the vertical flipped state of this Game Object.
                 */
                toggleFlipY(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipX(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the vertical flipped state of this Game Object.
                 * @param value The flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlipY(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Sets the horizontal and vertical flipped state of this Game Object.
                 * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
                 */
                setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
                 */
                resetFlip(): Phaser.GameObjects.GameObject;

                /**
                 * Gets the center coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 */
                getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * Gets the top-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the top-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
                 * The returned point is calculated in local space and does not factor in any parent containers
                 * @param output An object to store the values in. If not provided a new Vector2 will be created.
                 * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
                 */
                getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

                /**
                 * Gets the bounds of this Game Object, regardless of origin.
                 * The values are stored and returned in a Rectangle, or Rectangle-like, object.
                 * @param output An object to store the values in. If not provided a new Rectangle will be created.
                 */
                getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

                /**
                 * The horizontal origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the left of the Game Object.
                 */
                originX: number;

                /**
                 * The vertical origin of this Game Object.
                 * The origin maps the relationship between the size and position of the Game Object.
                 * The default value is 0.5, meaning all Game Objects are positioned based on their center.
                 * Setting the value to 0 means the position now relates to the top of the Game Object.
                 */
                originY: number;

                /**
                 * The horizontal display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginX: number;

                /**
                 * The vertical display origin of this Game Object.
                 * The origin is a normalized value between 0 and 1.
                 * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
                 */
                displayOriginY: number;

                /**
                 * Sets the origin of this Game Object.
                 * 
                 * The values are given in the range 0 to 1.
                 * @param x The horizontal origin value. Default 0.5.
                 * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the origin of this Game Object based on the Pivot values in its Frame.
                 */
                setOriginFromFrame(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display origin of this Game Object.
                 * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
                 * @param x The horizontal display origin value. Default 0.
                 * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
                 */
                setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Updates the Display Origin cached values internally stored on this Game Object.
                 * You don't usually call this directly, but it is exposed for edge-cases where you may.
                 */
                updateDisplayOrigin(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * Sets the initial WebGL Pipeline of this Game Object.
                 * This should only be called during the instantiation of the Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                initPipeline(pipelineName: string): boolean;

                /**
                 * Sets the active WebGL Pipeline of this Game Object.
                 * @param pipelineName The name of the pipeline to set on this Game Object.
                 */
                setPipeline(pipelineName: string): boolean;

                /**
                 * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
                 */
                resetPipeline(): boolean;

                /**
                 * Gets the name of the WebGL Pipeline this Game Object is currently using.
                 */
                getPipelineName(): string;

                /**
                 * The Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 */
                scaleMode: Phaser.ScaleModes;

                /**
                 * Sets the Scale Mode being used by this Game Object.
                 * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
                 * @param value The Scale Mode to be used by this Game Object.
                 */
                setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

                /**
                 * The horizontal scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorX: number;

                /**
                 * The vertical scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 */
                scrollFactorY: number;

                /**
                 * Sets the scroll factor of this Game Object.
                 * 
                 * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
                 * 
                 * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
                 * It does not change the Game Objects actual position values.
                 * 
                 * A value of 1 means it will move exactly in sync with a camera.
                 * A value of 0 means it will not move at all, even if the camera moves.
                 * Other values control the degree to which the camera movement is mapped to this Game Object.
                 * @param x The horizontal scroll factor of this Game Object.
                 * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * The native (un-scaled) width of this Game Object.
                 */
                width: number;

                /**
                 * The native (un-scaled) height of this Game Object.
                 */
                height: number;

                /**
                 * The displayed width of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayWidth: number;

                /**
                 * The displayed height of this Game Object.
                 * This value takes into account the scale factor.
                 */
                displayHeight: number;

                /**
                 * Sets the size of this Game Object to be that of the given Frame.
                 * @param frame The frame to base the size of this Game Object on.
                 */
                setSizeToFrame(frame: Phaser.Textures.Frame): Phaser.GameObjects.GameObject;

                /**
                 * Sets the size of this Game Object.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setSize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the display size of this Game Object.
                 * Calling this will adjust the scale.
                 * @param width The width of this Game Object.
                 * @param height The height of this Game Object.
                 */
                setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

                /**
                 * The Texture this Game Object is using to render with.
                 */
                texture: Phaser.Textures.Texture;

                /**
                 * The Texture Frame this Game Object is using to render with.
                 */
                frame: Phaser.Textures.Frame;

                /**
                 * Sets the texture and frame this Game Object will use to render with.
                 * 
                 * Textures are referenced by their string-based keys, as stored in the Texture Manager.
                 * @param key The key of the texture to be used, as stored in the Texture Manager.
                 * @param frame The name or index of the frame within the Texture.
                 */
                setTexture(key: string, frame?: string | integer): Phaser.GameObjects.GameObject;

                /**
                 * Sets the frame this Game Object will use to render with.
                 * 
                 * The Frame has to belong to the current Texture being used.
                 * 
                 * It can be either a string or an index.
                 * 
                 * Calling `setFrame` will modify the `width` and `height` properties of your Game Object.
                 * It will also change the `origin` if the Frame has a custom pivot point, as exported from packages like Texture Packer.
                 * @param frame The name or index of the frame within the Texture.
                 * @param updateSize Should this call adjust the size of the Game Object? Default true.
                 * @param updateOrigin Should this call adjust the origin of the Game Object? Default true.
                 */
                setFrame(frame: string | integer, updateSize?: boolean, updateOrigin?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * Clears all tint values associated with this Game Object.
                 * Immediately sets the alpha levels back to 0xffffff (no tint)
                 */
                clearTint(): Phaser.GameObjects.GameObject;

                /**
                 * Sets the tint values for this Game Object.
                 * @param topLeft The tint being applied to the top-left of the Game Object. If not other values are given this value is applied evenly, tinting the whole Game Object. Default 0xffffff.
                 * @param topRight The tint being applied to the top-right of the Game Object.
                 * @param bottomLeft The tint being applied to the bottom-left of the Game Object.
                 * @param bottomRight The tint being applied to the bottom-right of the Game Object.
                 */
                setTint(topLeft?: integer, topRight?: integer, bottomLeft?: integer, bottomRight?: integer): Phaser.GameObjects.GameObject;

                /**
                 * The tint value being applied to the top-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopLeft: integer;

                /**
                 * The tint value being applied to the top-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintTopRight: integer;

                /**
                 * The tint value being applied to the bottom-left of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomLeft: integer;

                /**
                 * The tint value being applied to the bottom-right of the Game Object.
                 * This value is interpolated from the corner to the center of the Game Object.
                 */
                tintBottomRight: integer;

                /**
                 * The tint value being applied to the whole of the Game Object.
                 */
                tint: integer;

                /**
                 * The x position of this Game Object.
                 */
                x: number;

                /**
                 * The y position of this Game Object.
                 */
                y: number;

                /**
                 * The z position of this Game Object.
                 * Note: Do not use this value to set the z-index, instead see the `depth` property.
                 */
                z: number;

                /**
                 * The w position of this Game Object.
                 */
                w: number;

                /**
                 * The horizontal scale of this Game Object.
                 */
                scaleX: number;

                /**
                 * The vertical scale of this Game Object.
                 */
                scaleY: number;

                /**
                 * The angle of this Game Object as expressed in degrees.
                 * 
                 * Where 0 is to the right, 90 is down, 180 is left.
                 * 
                 * If you prefer to work in radians, see the `rotation` property instead.
                 */
                angle: integer;

                /**
                 * The angle of this Game Object in radians.
                 * 
                 * If you prefer to work in degrees, see the `angle` property instead.
                 */
                rotation: number;

                /**
                 * Sets the position of this Game Object.
                 * @param x The x position of this Game Object. Default 0.
                 * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
                 * @param z The z position of this Game Object. Default 0.
                 * @param w The w position of this Game Object. Default 0.
                 */
                setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the rotation of this Game Object.
                 * @param radians The rotation of this Game Object, in radians. Default 0.
                 */
                setRotation(radians?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the angle of this Game Object.
                 * @param degrees The rotation of this Game Object, in degrees. Default 0.
                 */
                setAngle(degrees?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the scale of this Game Object.
                 * @param x The horizontal scale of this Game Object.
                 * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
                 */
                setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the x position of this Game Object.
                 * @param value The x position of this Game Object. Default 0.
                 */
                setX(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the y position of this Game Object.
                 * @param value The y position of this Game Object. Default 0.
                 */
                setY(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the z position of this Game Object.
                 * @param value The z position of this Game Object. Default 0.
                 */
                setZ(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Sets the w position of this Game Object.
                 * @param value The w position of this Game Object. Default 0.
                 */
                setW(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * Gets the local transform matrix for this Game Object.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
                 * @param tempMatrix The matrix to populate with the values from this Game Object.
                 */
                getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

                /**
                 * The visible state of the Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 */
                visible: boolean;

                /**
                 * Sets the visibility of this Game Object.
                 * 
                 * An invisible Game Object will skip rendering, but will still process update logic.
                 * @param value The visible state of the Game Object.
                 */
                setVisible(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounce(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value Unique category bitfield.
                 */
                setCollisionCategory(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value Unique group index.
                 */
                setCollisionGroup(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param categories A unique category bitfield, or an array of them.
                 */
                setCollidesWith(categories: number | number[]): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param force [description]
                 */
                applyForce(force: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param position [description]
                 * @param force [description]
                 */
                applyForceFrom(position: Phaser.Math.Vector2, force: Phaser.Math.Vector2): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrust(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrustLeft(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrustRight(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param speed [description]
                 */
                thrustBack(speed: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 * @param air [description]
                 * @param fstatic [description]
                 */
                setFriction(value: number, air?: number, fstatic?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionAir(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionStatic(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setIgnoreGravity(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDensity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSensor(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                isSensor(): boolean;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param options [description]
                 */
                setRectangle(width: number, height: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param options [description]
                 */
                setCircle(radius: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param radius [description]
                 * @param sides [description]
                 * @param options [description]
                 */
                setPolygon(radius: number, sides: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param slope [description]
                 * @param options [description]
                 */
                setTrapezoid(width: number, height: number, slope: number, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param body [description]
                 * @param addToWorld [description] Default true.
                 */
                setExistingBody(body: MatterJS.Body, addToWorld?: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param config [description]
                 * @param options [description]
                 */
                setBody(config: object, options: object): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description] Default 60.
                 */
                setSleepThreshold(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param start [description]
                 * @param end [description]
                 */
                setSleepEvents(start: boolean, end: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepStartEvent(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepEndEvent(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setStatic(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                isStatic(): boolean;

                /**
                 * [description]
                 */
                setFixedRotation(): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setAngularVelocity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 */
                setVelocityX(x: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param y [description]
                 */
                setVelocityY(y: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description] Default x.
                 */
                setVelocity(x: number, y?: number): Phaser.GameObjects.GameObject;

            }

            /**
             * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only
             * 
             * have one Matter body associated with it. You can either pass in an existing Matter body for
             * 
             * the tile or allow the constructor to create the corresponding body for you. If the Tile has a
             * 
             * collision group (defined in Tiled), those shapes will be used to create the body. If not, the
             * 
             * tile's rectangle bounding box will be used.
             * 
             * 
             * 
             * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.
             * 
             * 
             * 
             * Note: not all Tiled collision shapes are supported. See
             * 
             * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.
             */
            class TileBody implements Phaser.Physics.Matter.Components.Bounce, Phaser.Physics.Matter.Components.Collision, Phaser.Physics.Matter.Components.Friction, Phaser.Physics.Matter.Components.Gravity, Phaser.Physics.Matter.Components.Mass, Phaser.Physics.Matter.Components.Sensor, Phaser.Physics.Matter.Components.Sleep, Phaser.Physics.Matter.Components.Static {
                /**
                 * 
                 * @param world [description]
                 * @param tile The target tile that should have a Matter body.
                 * @param options Options to be used when creating the Matter body. See
                 * Phaser.Physics.Matter.Matter.Body for a list of what Matter accepts.
                 * @param options.body An existing Matter body to
                 * be used instead of creating a new one. Default null.
                 * @param options.isStatic Whether or not the newly created body should be
                 * made static. This defaults to true since typically tiles should not be moved. Default true.
                 * @param options.addToWorld Whether or not to add the newly created body (or
                 * existing body if options.body is used) to the Matter world. Default true.
                 */
                constructor(world: Phaser.Physics.Matter.World, tile: Phaser.Tilemaps.Tile, options?: object);

                /**
                 * The tile object the body is associated with.
                 */
                tile: Phaser.Tilemaps.Tile;

                /**
                 * The Matter world the body exists within.
                 */
                world: Phaser.Physics.Matter.World;

                /**
                 * Sets the current body to a rectangle that matches the bounds of the tile.
                 * @param options Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.
                 * @param options.isStatic Whether or not the newly created body should be
                 * made static. This defaults to true since typically tiles should not be moved. Default true.
                 * @param options.addToWorld Whether or not to add the newly created body (or
                 * existing body if options.body is used) to the Matter world. Default true.
                 */
                setFromTileRectangle(options?: object): Phaser.Physics.Matter.TileBody;

                /**
                 * Sets the current body from the collision group associated with the Tile. This is typically
                 * set up in Tiled's collision editor.
                 * 
                 * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly
                 * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are
                 * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave
                 * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to
                 * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave
                 * polygon into multiple convex polygons yourself.
                 * @param options Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.
                 * @param options.isStatic Whether or not the newly created body should be
                 * made static. This defaults to true since typically tiles should not be moved. Default true.
                 * @param options.addToWorld Whether or not to add the newly created body (or
                 * existing body if options.body is used) to the Matter world. Default true.
                 */
                setFromTileCollision(options?: object): Phaser.Physics.Matter.TileBody;

                /**
                 * Sets the current body to the given body. This will remove the previous body, if one already
                 * exists.
                 * @param body The new Matter body to use.
                 * @param addToWorld Whether or not to add the body to the Matter world. Default true.
                 */
                setBody(body: MatterJS.Body, addToWorld?: boolean): Phaser.Physics.Matter.TileBody;

                /**
                 * Removes the current body from the TileBody and from the Matter world
                 */
                removeBody(): Phaser.Physics.Matter.TileBody;

                /**
                 * Removes the current body from the tile and the world.
                 */
                destroy(): Phaser.Physics.Matter.TileBody;

                /**
                 * [description]
                 * @param value [description]
                 */
                setBounce(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value Unique category bitfield.
                 */
                setCollisionCategory(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value Unique group index.
                 */
                setCollisionGroup(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param categories A unique category bitfield, or an array of them.
                 */
                setCollidesWith(categories: number | number[]): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 * @param air [description]
                 * @param fstatic [description]
                 */
                setFriction(value: number, air?: number, fstatic?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionAir(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setFrictionStatic(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setIgnoreGravity(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setMass(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setDensity(value: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSensor(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                isSensor(): boolean;

                /**
                 * [description]
                 * @param value [description] Default 60.
                 */
                setSleepThreshold(value?: number): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param start [description]
                 * @param end [description]
                 */
                setSleepEvents(start: boolean, end: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepStartEvent(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setSleepEndEvent(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 * @param value [description]
                 */
                setStatic(value: boolean): Phaser.GameObjects.GameObject;

                /**
                 * [description]
                 */
                isStatic(): boolean;

            }

            /**
             * [description]
             */
            class PointerConstraint {
                /**
                 * 
                 * @param scene [description]
                 * @param world [description]
                 * @param options [description]
                 */
                constructor(scene: Phaser.Scene, world: Phaser.Physics.Matter.World, options: object);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                world: Phaser.Physics.Matter.World;

                /**
                 * [description]
                 */
                camera: Phaser.Cameras.Scene2D.Camera;

                /**
                 * [description]
                 */
                pointer: Phaser.Input.Pointer;

                /**
                 * [description]
                 */
                active: boolean;

                /**
                 * The transformed position.
                 */
                position: Phaser.Math.Vector2;

                /**
                 * [description]
                 */
                constraint: object;

                /**
                 * [description]
                 * @param pointer [description]
                 */
                onDown(pointer: Phaser.Input.Pointer): void;

                /**
                 * [description]
                 */
                onUp(): void;

                /**
                 * [description]
                 * @param body [description]
                 * @param position [description]
                 */
                getBodyPart(body: MatterJS.Body, position: Phaser.Math.Vector2): boolean;

                /**
                 * [description]
                 */
                update(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

            /**
             * [description]
             */
            class World extends Phaser.Events.EventEmitter {
                /**
                 * 
                 * @param scene [description]
                 * @param config [description]
                 */
                constructor(scene: Phaser.Scene, config: object);

                /**
                 * [description]
                 */
                scene: Phaser.Scene;

                /**
                 * [description]
                 */
                engine: MatterJS.Engine;

                /**
                 * A `World` composite object that will contain all simulated bodies and constraints.
                 */
                localWorld: MatterJS.World;

                /**
                 * An object containing the 4 wall bodies that bound the physics world.
                 */
                walls: object;

                /**
                 * [description]
                 */
                enabled: boolean;

                /**
                 * The correction argument is an optional Number that specifies the time correction factor to apply to the update.
                 * This can help improve the accuracy of the simulation in cases where delta is changing between updates.
                 * The value of correction is defined as delta / lastDelta, i.e. the percentage change of delta over the last step.
                 * Therefore the value is always 1 (no correction) when delta constant (or when no correction is desired, which is the default).
                 * See the paper on Time Corrected Verlet for more information.
                 */
                correction: number;

                /**
                 * This function is called every time the core game loop steps, which is bound to the
                 * Request Animation Frame frequency unless otherwise modified.
                 * 
                 * The function is passed two values: `time` and `delta`, both of which come from the game step values.
                 * 
                 * It must return a number. This number is used as the delta value passed to Matter.Engine.update.
                 * 
                 * You can override this function with your own to define your own timestep.
                 * 
                 * If you need to update the Engine multiple times in a single game step then call
                 * `World.update` as many times as required. Each call will trigger the `getDelta` function.
                 * If you wish to have full control over when the Engine updates then see the property `autoUpdate`.
                 * 
                 * You can also adjust the number of iterations that Engine.update performs.
                 * Use the Scene Matter Physics config object to set the following properties:
                 * 
                 * positionIterations (defaults to 6)
                 * velocityIterations (defaults to 4)
                 * constraintIterations (defaults to 2)
                 * 
                 * Adjusting these values can help performance in certain situations, depending on the physics requirements
                 * of your game.
                 */
                getDelta: Function;

                /**
                 * Automatically call Engine.update every time the game steps.
                 * If you disable this then you are responsible for calling `World.step` directly from your game.
                 * If you call `set60Hz` or `set30Hz` then `autoUpdate` is reset to `true`.
                 */
                autoUpdate: boolean;

                /**
                 * [description]
                 */
                drawDebug: boolean;

                /**
                 * [description]
                 */
                debugGraphic: Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 */
                defaults: object;

                /**
                 * [description]
                 */
                setEventsProxy(): void;

                /**
                 * Sets the bounds of the Physics world to match the given world pixel dimensions.
                 * You can optionally set which 'walls' to create: left, right, top or bottom.
                 * If none of the walls are given it will default to use the walls settings it had previously.
                 * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
                 * the newly created bounds will also not have the left and right walls.
                 * Explicitly state them in the parameters to override this.
                 * @param x The x coordinate of the top-left corner of the bounds. Default 0.
                 * @param y The y coordinate of the top-left corner of the bounds. Default 0.
                 * @param width The width of the bounds.
                 * @param height The height of the bounds.
                 * @param thickness The thickness of each wall, in pixels. Default 128.
                 * @param left If true will create the left bounds wall. Default true.
                 * @param right If true will create the right bounds wall. Default true.
                 * @param top If true will create the top bounds wall. Default true.
                 * @param bottom If true will create the bottom bounds wall. Default true.
                 */
                setBounds(x?: number, y?: number, width?: number, height?: number, thickness?: number, left?: boolean, right?: boolean, top?: boolean, bottom?: boolean): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param add [description]
                 * @param position [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 */
                updateWall(add: boolean, position: string, x: number, y: number, width: number, height: number): void;

                /**
                 * [description]
                 */
                createDebugGraphic(): Phaser.GameObjects.Graphics;

                /**
                 * [description]
                 */
                disableGravity(): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param x [description] Default 0.
                 * @param y [description] Default 1.
                 * @param scale [description]
                 */
                setGravity(x?: number, y?: number, scale?: number): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param width [description]
                 * @param height [description]
                 * @param options [description]
                 */
                create(x: number, y: number, width: number, height: number, options: object): MatterJS.Body;

                /**
                 * [description]
                 * @param object Can be single or an array, and can be a body, composite or constraint
                 */
                add(object: object | object[]): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param object The object to be removed from the world.
                 * @param deep [description]
                 */
                remove(object: object, deep: boolean): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param constraint [description]
                 * @param deep [description]
                 */
                removeConstraint(constraint: MatterJS.Constraint, deep: boolean): Phaser.Physics.Matter.World;

                /**
                 * Adds MatterTileBody instances for all the colliding tiles within the given tilemap layer. Set
                 * the appropriate tiles in your layer to collide before calling this method!
                 * @param tilemapLayer An array of tiles.
                 * @param options Options to be passed to the MatterTileBody constructor. {@ee Phaser.Physics.Matter.TileBody}
                 */
                convertTilemapLayer(tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer, options?: object): Phaser.Physics.Matter.World;

                /**
                 * Adds MatterTileBody instances for the given tiles. This adds bodies regardless of whether the
                 * tiles are set to collide or not.
                 * @param tiles An array of tiles.
                 * @param options Options to be passed to the MatterTileBody constructor. {@see Phaser.Physics.Matter.TileBody}
                 */
                convertTiles(tiles: Phaser.Tilemaps.Tile[], options?: object): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param isNonColliding [description]
                 */
                nextGroup(isNonColliding: boolean): number;

                /**
                 * [description]
                 */
                nextCategory(): number;

                /**
                 * [description]
                 */
                pause(): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 */
                resume(): Phaser.Physics.Matter.World;

                /**
                 * [description]
                 * @param time [description]
                 * @param delta [description]
                 */
                update(time: number, delta: number): void;

                /**
                 * Manually advances the physics simulation by one iteration.
                 * 
                 * You can optionally pass in the `delta` and `correction` values to be used by Engine.update.
                 * If undefined they use the Matter defaults of 60Hz and no correction.
                 * 
                 * Calling `step` directly bypasses any checks of `enabled` or `autoUpdate`.
                 * 
                 * It also ignores any custom `getDelta` functions, as you should be passing the delta
                 * value in to this call.
                 * 
                 * You can adjust the number of iterations that Engine.update performs internally.
                 * Use the Scene Matter Physics config object to set the following properties:
                 * 
                 * positionIterations (defaults to 6)
                 * velocityIterations (defaults to 4)
                 * constraintIterations (defaults to 2)
                 * 
                 * Adjusting these values can help performance in certain situations, depending on the physics requirements
                 * of your game.
                 * @param delta [description] Default 16.666.
                 * @param correction [description] Default 1.
                 */
                step(delta?: number, correction?: number): void;

                /**
                 * Runs the Matter Engine.update at a fixed timestep of 60Hz.
                 */
                update60Hz(): number;

                /**
                 * Runs the Matter Engine.update at a fixed timestep of 30Hz.
                 */
                update30Hz(): number;

                /**
                 * [description]
                 */
                postUpdate(): void;

                /**
                 * [description]
                 * @param path [description]
                 * @param points [description]
                 */
                fromPath(path: string, points: any[]): any[];

                /**
                 * [description]
                 */
                shutdown(): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

        }

    }

    namespace Plugins {
        /**
         * These are the Global Managers that are created by the Phaser.Game instance.
         * They are referenced from Scene.Systems so that plugins can use them.
         */
        var Global: any[];

        /**
         * These are the core plugins that are installed into every Scene.Systems instance, no matter what.
         * They are optionally exposed in the Scene as well (see the InjectionMap for details)
         * 
         * They are created in the order in which they appear in this array and EventEmitter is always first.
         */
        var CoreScene: any[];

        /**
         * These plugins are created in Scene.Systems in addition to the CoreScenePlugins.
         * 
         * You can elect not to have these plugins by either creating a DefaultPlugins object as part
         * of the Game Config, by creating a Plugins object as part of a Scene Config, or by modifying this array
         * and building your own bundle.
         * 
         * They are optionally exposed in the Scene as well (see the InjectionMap for details)
         * 
         * They are always created in the order in which they appear in the array.
         */
        var DefaultScene: any[];

    }

    /**
     * Phaser Blend Modes.
     */
    enum BlendModes {
        /**
         * Skips the Blend Mode check in the renderer.
         */
        SKIP_CHECK,
        /**
         * Normal blend mode.
         */
        NORMAL,
        /**
         * Add blend mode.
         */
        ADD,
        /**
         * Multiply blend mode.
         */
        MULTIPLY,
        /**
         * Screen blend mode.
         */
        SCREEN,
        /**
         * Overlay blend mode.
         */
        OVERLAY,
        /**
         * Darken blend mode.
         */
        DARKEN,
        /**
         * Lighten blend mode.
         */
        LIGHTEN,
        /**
         * Color Dodge blend mode.
         */
        COLOR_DODGE,
        /**
         * Color Burn blend mode.
         */
        COLOR_BURN,
        /**
         * Hard Light blend mode.
         */
        HARD_LIGHT,
        /**
         * Soft Light blend mode.
         */
        SOFT_LIGHT,
        /**
         * Difference blend mode.
         */
        DIFFERENCE,
        /**
         * Exclusion blend mode.
         */
        EXCLUSION,
        /**
         * Hue blend mode.
         */
        HUE,
        /**
         * Saturation blend mode.
         */
        SATURATION,
        /**
         * Color blend mode.
         */
        COLOR,
        /**
         * Luminosity blend mode.
         */
        LUMINOSITY,
    }

    namespace Renderer {
        namespace Canvas {
            /**
             * [description]
             */
            class CanvasRenderer {
                /**
                 * 
                 * @param game The Phaser Game instance that owns this renderer.
                 */
                constructor(game: Phaser.Game);

                /**
                 * The Phaser Game instance that owns this renderer.
                 */
                game: Phaser.Game;

                /**
                 * [description]
                 */
                type: integer;

                /**
                 * [description]
                 */
                drawCount: number;

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                config: RendererConfig;

                /**
                 * [description]
                 */
                scaleMode: integer;

                /**
                 * [description]
                 */
                gameCanvas: HTMLCanvasElement;

                /**
                 * [description]
                 */
                gameContext: CanvasRenderingContext2D;

                /**
                 * [description]
                 */
                currentContext: CanvasRenderingContext2D;

                /**
                 * Map to the required function.
                 */
                drawImage: Function;

                /**
                 * [description]
                 */
                blitImage: Function;

                /**
                 * [description]
                 */
                blendModes: any[];

                /**
                 * [description]
                 */
                currentAlpha: number;

                /**
                 * [description]
                 */
                currentBlendMode: number;

                /**
                 * [description]
                 */
                currentScaleMode: number;

                /**
                 * [description]
                 */
                snapshotCallback: SnapshotCallback;

                /**
                 * [description]
                 */
                snapshotType: string;

                /**
                 * [description]
                 */
                snapshotEncoder: number;

                /**
                 * [description]
                 */
                init(): void;

                /**
                 * Resize the main game canvas.
                 * @param width [description]
                 * @param height [description]
                 */
                resize(width: integer, height: integer): void;

                /**
                 * [description]
                 * @param callback [description]
                 */
                onContextLost(callback: Function): void;

                /**
                 * [description]
                 * @param callback [description]
                 */
                onContextRestored(callback: Function): void;

                /**
                 * [description]
                 */
                resetTransform(): void;

                /**
                 * [description]
                 * @param blendMode [description]
                 */
                setBlendMode(blendMode: number): number;

                /**
                 * [description]
                 * @param alpha [description]
                 */
                setAlpha(alpha: number): number;

                /**
                 * Called at the start of the render loop.
                 */
                preRender(): void;

                /**
                 * Renders the Scene to the given Camera.
                 * @param scene [description]
                 * @param children [description]
                 * @param interpolationPercentage [description]
                 * @param camera [description]
                 */
                render(scene: Phaser.Scene, children: Phaser.GameObjects.DisplayList, interpolationPercentage: number, camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 */
                postRender(): void;

                /**
                 * [description]
                 * @param callback [description]
                 * @param type [description]
                 * @param encoderOptions [description]
                 */
                snapshot(callback: SnapshotCallback, type: string, encoderOptions: number): void;

                /**
                 * [description]
                 */
                destroy(): void;

            }

            /**
             * No scaling, anchor, rotation or effects, literally draws the frame directly to the canvas.
             * @param dx The x coordinate to render the Frame to.
             * @param dy The y coordinate to render the Frame to.
             * @param frame The Frame to render.
             */
            function BlitImage(dx: number, dy: number, frame: Phaser.Textures.Frame): void;

            /**
             * [description]
             * @param src [description]
             * @param camera [description]
             * @param parentMatrix [description]
             */
            function DrawImage(src: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera, parentMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

            /**
             * [description]
             */
            function GetBlendModes(): any[];

        }

        namespace Snapshot {
            /**
             * [description]
             * @param canvas [description]
             * @param type [description] Default 'image/png'.
             * @param encoderOptions [description] Default 0.92.
             */
            function Canvas(canvas: HTMLCanvasElement, type?: string, encoderOptions?: number): HTMLImageElement;

            /**
             * [description]
             * @param sourceCanvas [description]
             * @param type [description] Default 'image/png'.
             * @param encoderOptions [description] Default 0.92.
             */
            function WebGL(sourceCanvas: HTMLCanvasElement, type?: string, encoderOptions?: number): HTMLImageElement;

        }

        namespace WebGL {
            namespace Pipelines {
                /**
                 * [description]
                 */
                class BitmapMaskPipeline extends Phaser.Renderer.WebGL.WebGLPipeline {
                    /**
                     * 
                     * @param config [description]
                     */
                    constructor(config: object);

                    /**
                     * [description]
                     */
                    vertexViewF32: Float32Array;

                    /**
                     * [description]
                     */
                    maxQuads: number;

                    /**
                     * [description]
                     */
                    resolutionDirty: boolean;

                    /**
                     * [description]
                     */
                    onBind(): Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline;

                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param resolution [description]
                     */
                    resize(width: number, height: number, resolution: number): Phaser.Renderer.WebGL.Pipelines.BitmapMaskPipeline;

                    /**
                     * [description]
                     * @param mask [description]
                     * @param maskedObject [description]
                     * @param camera [description]
                     */
                    beginMask(mask: Phaser.GameObjects.GameObject, maskedObject: Phaser.GameObjects.GameObject, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param mask [description]
                     */
                    endMask(mask: Phaser.GameObjects.GameObject): void;

                }

                /**
                 * [description]
                 */
                class FlatTintPipeline extends Phaser.Renderer.WebGL.WebGLPipeline {
                    /**
                     * 
                     * @param config [description]
                     */
                    constructor(config: object);

                    /**
                     * [description]
                     */
                    vertexViewF32: Float32Array;

                    /**
                     * [description]
                     */
                    vertexViewU32: Uint32Array;

                    /**
                     * [description]
                     */
                    tempTriangle: any[];

                    /**
                     * [description]
                     */
                    polygonCache: any[];

                    /**
                     * [description]
                     */
                    onBind(): Phaser.Renderer.WebGL.Pipelines.FlatTintPipeline;

                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param resolution [description]
                     */
                    resize(width: number, height: number, resolution: number): Phaser.Renderer.WebGL.Pipelines.FlatTintPipeline;

                    /**
                     * [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcScaleX [description]
                     * @param srcScaleY [description]
                     * @param srcRotation [description]
                     * @param x [description]
                     * @param y [description]
                     * @param width [description]
                     * @param height [description]
                     * @param fillColor [description]
                     * @param fillAlpha [description]
                     * @param a1 [description]
                     * @param b1 [description]
                     * @param c1 [description]
                     * @param d1 [description]
                     * @param e1 [description]
                     * @param f1 [description]
                     * @param currentMatrix [description]
                     */
                    batchFillRect(srcX: number, srcY: number, srcScaleX: number, srcScaleY: number, srcRotation: number, x: number, y: number, width: number, height: number, fillColor: integer, fillAlpha: number, a1: number, b1: number, c1: number, d1: number, e1: number, f1: number, currentMatrix: Float32Array): void;

                    /**
                     * [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcScaleX [description]
                     * @param srcScaleY [description]
                     * @param srcRotation [description]
                     * @param x0 [description]
                     * @param y0 [description]
                     * @param x1 [description]
                     * @param y1 [description]
                     * @param x2 [description]
                     * @param y2 [description]
                     * @param fillColor [description]
                     * @param fillAlpha [description]
                     * @param a1 [description]
                     * @param b1 [description]
                     * @param c1 [description]
                     * @param d1 [description]
                     * @param e1 [description]
                     * @param f1 [description]
                     * @param currentMatrix [description]
                     */
                    batchFillTriangle(srcX: number, srcY: number, srcScaleX: number, srcScaleY: number, srcRotation: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, fillColor: integer, fillAlpha: number, a1: number, b1: number, c1: number, d1: number, e1: number, f1: number, currentMatrix: Float32Array): void;

                    /**
                     * [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcScaleX [description]
                     * @param srcScaleY [description]
                     * @param srcRotation [description]
                     * @param x0 [description]
                     * @param y0 [description]
                     * @param x1 [description]
                     * @param y1 [description]
                     * @param x2 [description]
                     * @param y2 [description]
                     * @param lineWidth [description]
                     * @param lineColor [description]
                     * @param lineAlpha [description]
                     * @param a [description]
                     * @param b [description]
                     * @param c [description]
                     * @param d [description]
                     * @param e [description]
                     * @param f [description]
                     * @param currentMatrix [description]
                     */
                    batchStrokeTriangle(srcX: number, srcY: number, srcScaleX: number, srcScaleY: number, srcRotation: number, x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, lineWidth: number, lineColor: integer, lineAlpha: number, a: number, b: number, c: number, d: number, e: number, f: number, currentMatrix: Float32Array): void;

                    /**
                     * [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcScaleX [description]
                     * @param srcScaleY [description]
                     * @param srcRotation [description]
                     * @param path [description]
                     * @param fillColor [description]
                     * @param fillAlpha [description]
                     * @param a1 [description]
                     * @param b1 [description]
                     * @param c1 [description]
                     * @param d1 [description]
                     * @param e1 [description]
                     * @param f1 [description]
                     * @param currentMatrix [description]
                     */
                    batchFillPath(srcX: number, srcY: number, srcScaleX: number, srcScaleY: number, srcRotation: number, path: number, fillColor: integer, fillAlpha: number, a1: number, b1: number, c1: number, d1: number, e1: number, f1: number, currentMatrix: Float32Array): void;

                    /**
                     * [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcScaleX [description]
                     * @param srcScaleY [description]
                     * @param srcRotation [description]
                     * @param path [description]
                     * @param lineWidth [description]
                     * @param lineColor [description]
                     * @param lineAlpha [description]
                     * @param a [description]
                     * @param b [description]
                     * @param c [description]
                     * @param d [description]
                     * @param e [description]
                     * @param f [description]
                     * @param isLastPath [description]
                     * @param currentMatrix [description]
                     */
                    batchStrokePath(srcX: number, srcY: number, srcScaleX: number, srcScaleY: number, srcRotation: number, path: any[], lineWidth: number, lineColor: integer, lineAlpha: number, a: number, b: number, c: number, d: number, e: number, f: number, isLastPath: boolean, currentMatrix: Float32Array): void;

                    /**
                     * [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcScaleX [description]
                     * @param srcScaleY [description]
                     * @param srcRotation [description]
                     * @param ax [description]
                     * @param ay [description]
                     * @param bx [description]
                     * @param by [description]
                     * @param aLineWidth [description]
                     * @param bLineWidth [description]
                     * @param aLineColor [description]
                     * @param bLineColor [description]
                     * @param lineAlpha [description]
                     * @param a1 [description]
                     * @param b1 [description]
                     * @param c1 [description]
                     * @param d1 [description]
                     * @param e1 [description]
                     * @param f1 [description]
                     * @param currentMatrix [description]
                     */
                    batchLine(srcX: number, srcY: number, srcScaleX: number, srcScaleY: number, srcRotation: number, ax: number, ay: number, bx: number, by: number, aLineWidth: number, bLineWidth: number, aLineColor: integer, bLineColor: integer, lineAlpha: number, a1: number, b1: number, c1: number, d1: number, e1: number, f1: number, currentMatrix: Float32Array): void;

                    /**
                     * [description]
                     * @param graphics [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchGraphics(graphics: Phaser.GameObjects.Graphics, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param tilemap [description]
                     * @param camera [description]
                     */
                    drawStaticTilemapLayer(tilemap: Phaser.Tilemaps.StaticTilemapLayer, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param emitterManager [description]
                     * @param camera [description]
                     */
                    drawEmitterManager(emitterManager: Phaser.GameObjects.Particles.ParticleEmitterManager, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param blitter [description]
                     * @param camera [description]
                     */
                    drawBlitter(blitter: Phaser.GameObjects.Blitter, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param sprite [description]
                     * @param camera [description]
                     */
                    batchSprite(sprite: Phaser.GameObjects.Sprite, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param mesh [description]
                     * @param camera [description]
                     */
                    batchMesh(mesh: Phaser.GameObjects.Mesh, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param bitmapText [description]
                     * @param camera [description]
                     */
                    batchBitmapText(bitmapText: Phaser.GameObjects.BitmapText, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param bitmapText [description]
                     * @param camera [description]
                     */
                    batchDynamicBitmapText(bitmapText: Phaser.GameObjects.DynamicBitmapText, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param text [description]
                     * @param camera [description]
                     */
                    batchText(text: Phaser.GameObjects.Text, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param tilemapLayer [description]
                     * @param camera [description]
                     */
                    batchDynamicTilemapLayer(tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer, camera: Phaser.Cameras.Scene2D.Camera): void;

                    /**
                     * [description]
                     * @param tileSprite [description]
                     * @param camera [description]
                     */
                    batchTileSprite(tileSprite: Phaser.GameObjects.TileSprite, camera: Phaser.Cameras.Scene2D.Camera): void;

                }

                /**
                 * [description]
                 */
                class ForwardDiffuseLightPipeline extends Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline {
                    /**
                     * 
                     * @param config [description]
                     */
                    constructor(config: object);

                    /**
                     * [description]
                     * @param scene [description]
                     * @param camera [description]
                     */
                    onRender(scene: Phaser.Scene, camera: Phaser.Cameras.Scene2D.Camera): Phaser.Renderer.WebGL.Pipelines.ForwardDiffuseLightPipeline;

                    /**
                     * [description]
                     * @param emitterManager [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    drawEmitterManager(emitterManager: Phaser.GameObjects.Particles.ParticleEmitterManager, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param blitter [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    drawBlitter(blitter: Phaser.GameObjects.Blitter, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param sprite [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchSprite(sprite: Phaser.GameObjects.Sprite, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param mesh [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchMesh(mesh: Phaser.GameObjects.Mesh, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param bitmapText [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchBitmapText(bitmapText: Phaser.GameObjects.BitmapText, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param bitmapText [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchDynamicBitmapText(bitmapText: Phaser.GameObjects.DynamicBitmapText, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param text [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchText(text: Phaser.GameObjects.Text, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param tilemapLayer [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchDynamicTilemapLayer(tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param tileSprite [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchTileSprite(tileSprite: Phaser.GameObjects.TileSprite, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                }

                /**
                 * [description]
                 */
                class TextureTintPipeline extends Phaser.Renderer.WebGL.WebGLPipeline {
                    /**
                     * 
                     * @param config [description]
                     */
                    constructor(config: object);

                    /**
                     * [description]
                     */
                    vertexViewF32: Float32Array;

                    /**
                     * [description]
                     */
                    vertexViewU32: Uint32Array;

                    /**
                     * [description]
                     */
                    maxQuads: integer;

                    /**
                     * [description]
                     */
                    batches: any[];

                    /**
                     * [description]
                     * @param texture [description]
                     * @param textureUnit [description]
                     */
                    setTexture2D(texture: WebGLTexture, textureUnit: integer): Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline;

                    /**
                     * [description]
                     */
                    pushBatch(): void;

                    /**
                     * [description]
                     */
                    flush(): Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline;

                    /**
                     * [description]
                     */
                    onBind(): Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline;

                    /**
                     * [description]
                     * @param width [description]
                     * @param height [description]
                     * @param resolution [description]
                     */
                    resize(width: number, height: number, resolution: number): Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline;

                    /**
                     * [description]
                     * @param tilemap [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    drawStaticTilemapLayer(tilemap: Phaser.Tilemaps.StaticTilemapLayer, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param emitterManager [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    drawEmitterManager(emitterManager: Phaser.GameObjects.Particles.ParticleEmitterManager, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param blitter [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    drawBlitter(blitter: Phaser.GameObjects.Blitter, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param sprite [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchSprite(sprite: Phaser.GameObjects.Sprite, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param mesh [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchMesh(mesh: Phaser.GameObjects.Mesh, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param bitmapText [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchBitmapText(bitmapText: Phaser.GameObjects.BitmapText, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param bitmapText [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchDynamicBitmapText(bitmapText: Phaser.GameObjects.DynamicBitmapText, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param text [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchText(text: Phaser.GameObjects.Text, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param tilemapLayer [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchDynamicTilemapLayer(tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param tileSprite [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchTileSprite(tileSprite: Phaser.GameObjects.TileSprite, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * [description]
                     * @param gameObject [description]
                     * @param texture [description]
                     * @param textureWidth [description]
                     * @param textureHeight [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param srcWidth [description]
                     * @param srcHeight [description]
                     * @param scaleX [description]
                     * @param scaleY [description]
                     * @param rotation [description]
                     * @param flipX [description]
                     * @param flipY [description]
                     * @param scrollFactorX [description]
                     * @param scrollFactorY [description]
                     * @param displayOriginX [description]
                     * @param displayOriginY [description]
                     * @param frameX [description]
                     * @param frameY [description]
                     * @param frameWidth [description]
                     * @param frameHeight [description]
                     * @param tintTL [description]
                     * @param tintTR [description]
                     * @param tintBL [description]
                     * @param tintBR [description]
                     * @param uOffset [description]
                     * @param vOffset [description]
                     * @param camera [description]
                     * @param parentTransformMatrix [description]
                     */
                    batchTexture(gameObject: Phaser.GameObjects.GameObject, texture: WebGLTexture, textureWidth: integer, textureHeight: integer, srcX: number, srcY: number, srcWidth: number, srcHeight: number, scaleX: number, scaleY: number, rotation: number, flipX: boolean, flipY: boolean, scrollFactorX: number, scrollFactorY: number, displayOriginX: number, displayOriginY: number, frameX: number, frameY: number, frameWidth: number, frameHeight: number, tintTL: integer, tintTR: integer, tintBL: integer, tintBR: integer, uOffset: number, vOffset: number, camera: Phaser.Cameras.Scene2D.Camera, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): void;

                    /**
                     * Immediately draws a texture with no batching.
                     * @param texture [description]
                     * @param srcX [description]
                     * @param srcY [description]
                     * @param tint [description]
                     * @param alpha [description]
                     * @param frameX [description]
                     * @param frameY [description]
                     * @param frameWidth [description]
                     * @param frameHeight [description]
                     * @param transformMatrix [description]
                     * @param parentTransformMatrix [description]
                     */
                    drawTexture(texture: WebGLTexture, srcX: number, srcY: number, tint: number, alpha: number, frameX: number, frameY: number, frameWidth: number, frameHeight: number, transformMatrix: Phaser.GameObjects.Components.TransformMatrix, parentTransformMatrix: Phaser.GameObjects.Components.TransformMatrix): Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline;

                    /**
                     * [description]
                     * @param graphics [description]
                     * @param camera [description]
                     */
                    batchGraphics(graphics: Phaser.GameObjects.Graphics, camera: Phaser.Cameras.Scene2D.Camera): void;

                }

            }

            namespace Utils {
                /**
                 * [description]
                 * @param r [description]
                 * @param g [description]
                 * @param b [description]
                 * @param a [description]
                 */
                function getTintFromFloats(r: number, g: number, b: number, a: number): number;

                /**
                 * [description]
                 * @param rgb [description]
                 * @param a [description]
                 */
                function getTintAppendFloatAlpha(rgb: number, a: number): number;

                /**
                 * [description]
                 * @param rgb [description]
                 * @param a [description]
                 */
                function getTintAppendFloatAlphaAndSwap(rgb: number, a: number): number;

                /**
                 * [description]
                 * @param rgb [description]
                 */
                function getFloatsFromUintRGB(rgb: number): number;

                /**
                 * [description]
                 * @param attributes [description]
                 * @param glContext [description]
                 */
                function getComponentCount(attributes: number, glContext: WebGLRenderingContext): number;

            }

            /**
             * [description]
             */
            class WebGLPipeline {
                /**
                 * 
                 * @param config [description]
                 */
                constructor(config: object);

                /**
                 * [description]
                 */
                name: string;

                /**
                 * [description]
                 */
                game: Phaser.Game;

                /**
                 * [description]
                 */
                view: HTMLCanvasElement;

                /**
                 * [description]
                 */
                resolution: number;

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                gl: WebGLRenderingContext;

                /**
                 * [description]
                 */
                vertexCount: number;

                /**
                 * [description]
                 */
                vertexCapacity: integer;

                /**
                 * [description]
                 */
                renderer: Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 */
                vertexData: ArrayBuffer;

                /**
                 * [description]
                 */
                vertexBuffer: WebGLBuffer;

                /**
                 * [description]
                 */
                program: WebGLProgram;

                /**
                 * [description]
                 */
                attributes: object;

                /**
                 * [description]
                 */
                vertexSize: integer;

                /**
                 * [description]
                 */
                topology: integer;

                /**
                 * [description]
                 */
                bytes: Uint8Array;

                /**
                 * This will store the amount of components of 32 bit length
                 */
                vertexComponentCount: integer;

                /**
                 * Indicates if the current pipeline is flushing the contents to the GPU.
                 * When the variable is set the flush function will be locked.
                 */
                flushLocked: boolean;

                /**
                 * [description]
                 * @param name [description]
                 * @param size [description]
                 * @param type [description]
                 * @param normalized [description]
                 * @param offset [description]
                 */
                addAttribute(name: string, size: integer, type: integer, normalized: boolean, offset: integer): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                shouldFlush(): boolean;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param resolution [description]
                 */
                resize(width: number, height: number, resolution: number): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                bind(): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                onBind(): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                onPreRender(): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param scene [description]
                 * @param camera [description]
                 */
                onRender(scene: Phaser.Scene, camera: Phaser.Cameras.Scene2D.Camera): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                onPostRender(): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                flush(): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                destroy(): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 */
                setFloat1(name: string, x: number): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFloat2(name: string, x: number, y: number): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                setFloat3(name: string, x: number, y: number, z: number): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 * @param w [description]
                 */
                setFloat4(name: string, x: number, y: number, z: number, w: number): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 */
                setInt1(name: string, x: integer): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setInt2(name: string, x: integer, y: integer): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                setInt3(name: string, x: integer, y: integer, z: integer): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 * @param w [description]
                 */
                setInt4(name: string, x: integer, y: integer, z: integer, w: integer): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix2(name: string, transpose: boolean, matrix: Float32Array): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix3(name: string, transpose: boolean, matrix: Float32Array): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param name [description]
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix4(name: string, transpose: boolean, matrix: Float32Array): Phaser.Renderer.WebGL.WebGLPipeline;

            }

            /**
             * [description]
             */
            class WebGLRenderer {
                /**
                 * 
                 * @param game [description]
                 */
                constructor(game: Phaser.Game);

                /**
                 * [description]
                 */
                config: RendererConfig;

                /**
                 * [description]
                 */
                game: Phaser.Game;

                /**
                 * [description]
                 */
                type: integer;

                /**
                 * [description]
                 */
                width: number;

                /**
                 * [description]
                 */
                height: number;

                /**
                 * [description]
                 */
                canvas: HTMLCanvasElement;

                /**
                 * [description]
                 */
                lostContextCallbacks: WebGLContextCallback[];

                /**
                 * [description]
                 */
                restoredContextCallbacks: WebGLContextCallback[];

                /**
                 * [description]
                 */
                blendModes: any[];

                /**
                 * [description]
                 */
                nativeTextures: any[];

                /**
                 * [description]
                 */
                contextLost: boolean;

                /**
                 * [description]
                 */
                pipelines: object;

                /**
                 * [description]
                 */
                snapshotState: SnapshotState;

                /**
                 * [description]
                 */
                currentActiveTextureUnit: integer;

                /**
                 * [description]
                 */
                currentTextures: any[];

                /**
                 * [description]
                 */
                currentFramebuffer: WebGLFramebuffer;

                /**
                 * [description]
                 */
                currentPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 */
                currentProgram: WebGLProgram;

                /**
                 * [description]
                 */
                currentVertexBuffer: WebGLBuffer;

                /**
                 * [description]
                 */
                currentIndexBuffer: WebGLBuffer;

                /**
                 * [description]
                 */
                currentBlendMode: integer;

                /**
                 * [description]
                 */
                currentScissorEnabled: boolean;

                /**
                 * [description]
                 */
                currentScissor: Uint32Array;

                /**
                 * [description]
                 */
                currentScissorIdx: number;

                /**
                 * [description]
                 */
                scissorStack: Uint32Array;

                /**
                 * [description]
                 */
                gl: WebGLRenderingContext;

                /**
                 * [description]
                 */
                supportedExtensions: object;

                /**
                 * [description]
                 */
                extensions: object;

                /**
                 * [description]
                 */
                glFormats: any[];

                /**
                 * [description]
                 * @param config [description]
                 */
                init(config: object): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 */
                resize(width: number, height: number): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param callback [description]
                 * @param target [description]
                 */
                onContextRestored(callback: WebGLContextCallback, target: object): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param callback [description]
                 * @param target [description]
                 */
                onContextLost(callback: WebGLContextCallback, target: object): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param extensionName [description]
                 */
                hasExtension(extensionName: string): boolean;

                /**
                 * [description]
                 * @param extensionName [description]
                 */
                getExtension(extensionName: string): object;

                /**
                 * [description]
                 */
                flush(): void;

                /**
                 * [description]
                 * @param pipelineName [description]
                 */
                hasPipeline(pipelineName: string): boolean;

                /**
                 * [description]
                 * @param pipelineName [description]
                 */
                getPipeline(pipelineName: string): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param pipelineName [description]
                 */
                removePipeline(pipelineName: string): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param pipelineName [description]
                 * @param pipelineInstance [description]
                 */
                addPipeline(pipelineName: string, pipelineInstance: Phaser.Renderer.WebGL.WebGLPipeline): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param w [description]
                 * @param h [description]
                 */
                setScissor(x: integer, y: integer, w: integer, h: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param x [description]
                 * @param y [description]
                 * @param w [description]
                 * @param h [description]
                 */
                pushScissor(x: integer, y: integer, w: integer, h: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 */
                popScissor(): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param pipelineInstance [description]
                 */
                setPipeline(pipelineInstance: Phaser.Renderer.WebGL.WebGLPipeline): Phaser.Renderer.WebGL.WebGLPipeline;

                /**
                 * [description]
                 * @param blendModeId [description]
                 */
                setBlendMode(blendModeId: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param func [description]
                 * @param equation [description]
                 */
                addBlendMode(func: Function, equation: Function): integer;

                /**
                 * [description]
                 * @param index [description]
                 * @param func [description]
                 * @param equation [description]
                 */
                updateBlendMode(index: integer, func: Function, equation: Function): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param index [description]
                 */
                removeBlendMode(index: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param texture [description]
                 * @param textureUnit [description]
                 */
                setTexture2D(texture: WebGLTexture, textureUnit: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param framebuffer [description]
                 */
                setFramebuffer(framebuffer: WebGLFramebuffer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 */
                setProgram(program: WebGLProgram): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param vertexBuffer [description]
                 */
                setVertexBuffer(vertexBuffer: WebGLBuffer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param indexBuffer [description]
                 */
                setIndexBuffer(indexBuffer: WebGLBuffer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param source [description]
                 * @param width [description]
                 * @param height [description]
                 * @param scaleMode [description]
                 */
                createTextureFromSource(source: object, width: integer, height: integer, scaleMode: integer): WebGLTexture;

                /**
                 * [description]
                 * @param mipLevel [description]
                 * @param minFilter [description]
                 * @param magFilter [description]
                 * @param wrapT [description]
                 * @param wrapS [description]
                 * @param format [description]
                 * @param pixels [description]
                 * @param width [description]
                 * @param height [description]
                 * @param pma [description]
                 */
                createTexture2D(mipLevel: integer, minFilter: integer, magFilter: integer, wrapT: integer, wrapS: integer, format: integer, pixels: object, width: integer, height: integer, pma: boolean): WebGLTexture;

                /**
                 * [description]
                 * @param width [description]
                 * @param height [description]
                 * @param renderTexture [description]
                 * @param addDepthStencilBuffer [description]
                 */
                createFramebuffer(width: integer, height: integer, renderTexture: WebGLFramebuffer, addDepthStencilBuffer: boolean): WebGLFramebuffer;

                /**
                 * [description]
                 * @param vertexShader [description]
                 * @param fragmentShader [description]
                 */
                createProgram(vertexShader: string, fragmentShader: string): WebGLProgram;

                /**
                 * [description]
                 * @param initialDataOrSize [description]
                 * @param bufferUsage [description]
                 */
                createVertexBuffer(initialDataOrSize: ArrayBuffer, bufferUsage: integer): WebGLBuffer;

                /**
                 * [description]
                 * @param initialDataOrSize [description]
                 * @param bufferUsage [description]
                 */
                createIndexBuffer(initialDataOrSize: ArrayBuffer, bufferUsage: integer): WebGLBuffer;

                /**
                 * [description]
                 * @param texture [description]
                 */
                deleteTexture(texture: WebGLTexture): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param framebuffer [description]
                 */
                deleteFramebuffer(framebuffer: WebGLFramebuffer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 */
                deleteProgram(program: WebGLProgram): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param vertexBuffer [description]
                 */
                deleteBuffer(vertexBuffer: WebGLBuffer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param camera [description]
                 */
                preRenderCamera(camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 * @param camera [description]
                 */
                postRenderCamera(camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 */
                preRender(): void;

                /**
                 * [description]
                 * @param scene [description]
                 * @param children [description]
                 * @param interpolationPercentage [description]
                 * @param camera [description]
                 */
                render(scene: Phaser.Scene, children: Phaser.GameObjects.GameObject, interpolationPercentage: number, camera: Phaser.Cameras.Scene2D.Camera): void;

                /**
                 * [description]
                 */
                postRender(): void;

                /**
                 * [description]
                 * @param callback [description]
                 * @param type [description]
                 * @param encoderOptions [description]
                 */
                snapshot(callback: SnapshotCallback, type: string, encoderOptions: number): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param srcCanvas [description]
                 * @param dstTexture [description]
                 * @param shouldReallocate [description]
                 * @param scaleMode [description]
                 */
                canvasToTexture(srcCanvas: HTMLCanvasElement, dstTexture: WebGLTexture, shouldReallocate: boolean, scaleMode: integer): WebGLTexture;

                /**
                 * [description]
                 * @param texture [description]
                 * @param filter [description]
                 */
                setTextureFilter(texture: integer, filter: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 */
                setFloat1(program: WebGLProgram, name: string, x: number): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setFloat2(program: WebGLProgram, name: string, x: number, y: number): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                setFloat3(program: WebGLProgram, name: string, x: number, y: number, z: number): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 * @param w [description]
                 */
                setFloat4(program: WebGLProgram, name: string, x: number, y: number, z: number, w: number): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 */
                setInt1(program: WebGLProgram, name: string, x: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 */
                setInt2(program: WebGLProgram, name: string, x: integer, y: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 */
                setInt3(program: WebGLProgram, name: string, x: integer, y: integer, z: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param x [description]
                 * @param y [description]
                 * @param z [description]
                 * @param w [description]
                 */
                setInt4(program: WebGLProgram, name: string, x: integer, y: integer, z: integer, w: integer): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix2(program: WebGLProgram, name: string, transpose: boolean, matrix: Float32Array): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix3(program: WebGLProgram, name: string, transpose: boolean, matrix: Float32Array): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 * @param program [description]
                 * @param name [description]
                 * @param transpose [description]
                 * @param matrix [description]
                 */
                setMatrix4(program: WebGLProgram, name: string, transpose: boolean, matrix: Float32Array): Phaser.Renderer.WebGL.WebGLRenderer;

                /**
                 * [description]
                 */
                destroy(): void;

            }

        }

    }

    /**
     * Phaser Scale Modes.
     */
    enum ScaleModes {
        /**
         * Default Scale Mode (Linear).
         */
        DEFAULT,
        /**
         * Linear Scale Mode.
         */
        LINEAR,
        /**
         * Nearest Scale Mode.
         */
        NEAREST,
    }

    namespace Scenes {
        /**
         * Scene state.
         */
        var PENDING: integer;

        /**
         * Scene state.
         */
        var INIT: integer;

        /**
         * Scene state.
         */
        var START: integer;

        /**
         * Scene state.
         */
        var LOADING: integer;

        /**
         * Scene state.
         */
        var CREATING: integer;

        /**
         * Scene state.
         */
        var RUNNING: integer;

        /**
         * Scene state.
         */
        var PAUSED: integer;

        /**
         * Scene state.
         */
        var SLEEPING: integer;

        /**
         * Scene state.
         */
        var SHUTDOWN: integer;

        /**
         * Scene state.
         */
        var DESTROYED: integer;

        /**
         * Builds an array of which physics plugins should be activated for the given Scene.
         * @param sys [description]
         */
        function GetPhysicsPlugins(sys: Phaser.Scenes.Systems): any[];

        /**
         * Builds an array of which plugins (not including physics plugins) should be activated for the given Scene.
         * @param sys [description]
         */
        function GetScenePlugins(sys: Phaser.Scenes.Systems): any[];

        /**
         * The Scene Manager.
         * 
         * 
         * 
         * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the
         * 
         * Scenes in a Game instance.
         */
        class SceneManager {
            /**
             * 
             * @param game The Phaser.Game instance this Scene Manager belongs to.
             * @param sceneConfig Scene specific configuration settings.
             */
            constructor(game: Phaser.Game, sceneConfig: object);

            /**
             * The Game that this SceneManager belongs to.
             */
            game: Phaser.Game;

            /**
             * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.
             */
            keys: object;

            /**
             * The array in which all of the scenes are kept.
             */
            scenes: any[];

            /**
             * Is the Scene Manager actively processing the Scenes list?
             */
            isProcessing: boolean;

            /**
             * Has the Scene Manager properly started?
             */
            isBooted: boolean;

            /**
             * Process the Scene operations queue.
             */
            processQueue(): void;

            /**
             * Adds a new Scene into the SceneManager.
             * You must give each Scene a unique key by which you'll identify it.
             * 
             * The `sceneConfig` can be:
             * 
             * * A `Phaser.Scene` object, or an object that extends it.
             * * A plain JavaScript object
             * * A JavaScript ES6 Class that extends `Phaser.Scene`
             * * A JavaScript ES5 prototype based Class
             * * A JavaScript function
             * 
             * If a function is given then a new Scene will be created by calling it.
             * @param key A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.
             * @param sceneConfig The config for the Scene
             * @param autoStart If `true` the Scene will be started immediately after being added. Default false.
             * @param data Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.
             */
            add(key: string, sceneConfig: Phaser.Scene | Phaser.Scenes.Settings.Config | Function, autoStart?: boolean, data?: object): Phaser.Scene;

            /**
             * Removes a Scene from the SceneManager.
             * 
             * The Scene is removed from the local scenes array, it's key is cleared from the keys
             * cache and Scene.Systems.destroy is then called on it.
             * 
             * If the SceneManager is processing the Scenes when this method is called it wil
             * queue the operation for the next update sequence.
             * @param scene The Scene to be removed.
             */
            remove(scene: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Updates the Scenes.
             * @param time Time elapsed.
             * @param delta Delta time from the last update.
             */
            update(time: number, delta: number): void;

            /**
             * Informs the Scenes of the Game being resized.
             * @param width The new width of the game.
             * @param height The new height of the game.
             */
            resize(width: number, height: number): void;

            /**
             * Renders the Scenes.
             * @param renderer The renderer to use.
             */
            render(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer): void;

            /**
             * Retrieves a Scene.
             * @param key The Scene to retrieve.
             */
            getScene(key: string | Phaser.Scene): Phaser.Scene;

            /**
             * Determines whether a Scene is active.
             * @param key The Scene to check.
             */
            isActive(key: string): boolean;

            /**
             * Determines whether a Scene is visible.
             * @param key The Scene to check.
             */
            isVisible(key: string): boolean;

            /**
             * Determines whether a Scene is sleeping.
             * @param key The Scene to check.
             */
            isSleeping(key: string): boolean;

            /**
             * Pauses the given Scene.
             * @param key The Scene to pause.
             */
            pause(key: string): Phaser.Scenes.SceneManager;

            /**
             * Resumes the given Scene.
             * @param key The Scene to resume.
             */
            resume(key: string): Phaser.Scenes.SceneManager;

            /**
             * Puts the given Scene to sleep.
             * @param key The Scene to put to sleep.
             */
            sleep(key: string): Phaser.Scenes.SceneManager;

            /**
             * Awakens the given Scene.
             * @param key The Scene to wake up.
             */
            wake(key: string): Phaser.Scenes.SceneManager;

            /**
             * Starts the given Scene.
             * @param key The Scene to start.
             * @param data Optional data object to pass to Scene.Settings and Scene.init.
             */
            start(key: string, data?: object): Phaser.Scenes.SceneManager;

            /**
             * Stops the given Scene.
             * @param key The Scene to stop.
             */
            stop(key: string): Phaser.Scenes.SceneManager;

            /**
             * Sleeps one one Scene and starts the other.
             * @param from The Scene to sleep.
             * @param to The Scene to start.
             */
            switch(from: string, to: string): Phaser.Scenes.SceneManager;

            /**
             * Retrieves a Scene by numeric index.
             * @param index The index of the Scene to retrieve.
             */
            getAt(index: integer): Phaser.Scene | undefined;

            /**
             * Retrieves the numeric index of a Scene.
             * @param key The key of the Scene.
             */
            getIndex(key: string | Phaser.Scene): integer;

            /**
             * Brings a Scene to the top of the Scenes list.
             * 
             * This means it will render above all other Scenes.
             * @param key The Scene to move.
             */
            bringToTop(key: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Sends a Scene to the back of the Scenes list.
             * 
             * This means it will render below all other Scenes.
             * @param key The Scene to move.
             */
            sendToBack(key: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Moves a Scene down one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveDown(key: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Moves a Scene up one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveUp(key: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Moves a Scene so it is immediately above another Scene in the Scenes list.
             * 
             * This means it will render over the top of the other Scene.
             * @param keyA The Scene that Scene B will be moved above.
             * @param keyB The Scene to be moved.
             */
            moveAbove(keyA: string | Phaser.Scene, keyB: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Moves a Scene so it is immediately below another Scene in the Scenes list.
             * 
             * This means it will render behind the other Scene.
             * @param keyA The Scene that Scene B will be moved above.
             * @param keyB The Scene to be moved.
             */
            moveBelow(keyA: string | Phaser.Scene, keyB: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Swaps the positions of two Scenes in the Scenes list.
             * @param keyA The first Scene to swap.
             * @param keyB The second Scene to swap.
             */
            swapPosition(keyA: string | Phaser.Scene, keyB: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Dumps debug information about each Scene to the developer console.
             */
            dump(): void;

            /**
             * Destroy the SceneManager and all of its Scene's systems.
             */
            destroy(): void;

        }

        /**
         * A proxy class to the Global Scene Manager.
         */
        class ScenePlugin {
            /**
             * 
             * @param scene The Scene that this ScenePlugin belongs to.
             */
            constructor(scene: Phaser.Scene);

            /**
             * The Scene that this ScenePlugin belongs to.
             */
            scene: Phaser.Scene;

            /**
             * The Scene Systems instance of the Scene that this ScenePlugin belongs to.
             */
            systems: Phaser.Scenes.Systems;

            /**
             * The settings of the Scene this ScenePlugin belongs to.
             */
            settings: Phaser.Scenes.Settings.Object;

            /**
             * The key of the Scene this ScenePlugin belongs to.
             */
            key: string;

            /**
             * The Game's SceneManager.
             */
            manager: Phaser.Scenes.SceneManager;

            /**
             * If this Scene is currently transitioning to another, this holds
             * the current percentage of the transition progress, between 0 and 1.
             */
            transitionProgress: number;

            /**
             * Shutdown this Scene and run the given one.
             * @param key The Scene to start.
             * @param data The Scene data.
             */
            start(key: string, data?: object): Phaser.Scenes.ScenePlugin;

            /**
             * Restarts this Scene.
             * @param data The Scene data.
             */
            restart(data?: object): Phaser.Scenes.ScenePlugin;

            /**
             * This will start a transition from the current Scene to the target Scene given.
             * 
             * The transition will last for the duration specified in milliseconds.
             * 
             * You can have the target Scene moved above or below this one in the display list.
             * 
             * You can specify an update callback. This callback will be invoked _every frame_ for the duration
             * of the transition.
             * 
             * This Scene can either be sent to sleep at the end of the transition, or stopped. The default is to stop.
             * 
             * There are also 5 transition related events: This scene will emit the event `transitionto` when
             * the transition begins, which is typically the frame after calling this method.
             * 
             * The target Scene will emit the event `transitioninit` when that Scene's `init` method is called.
             * It will then emit the event `transitionstart` when its `create` method is called.
             * If the Scene was sleeping and has been woken up, it will emit the event `transitionwake` instead of these two,
             * as the Scenes `init` and `create` methods are not invoked when a sleep wakes up.
             * 
             * When the duration of the transition has elapsed it will emit the event `transitioncomplete`.
             * These events are all cleared of listeners when the Scene shuts down, but not if it is sent to sleep.
             * 
             * It's important to understand that the duration of the transition begins the moment you call this method.
             * If the Scene you are transitioning to includes delayed processes, such as waiting for files to load, the
             * time still counts down even while that is happening. If the game itself pauses, or something else causes
             * this Scenes update loop to stop, then the transition will also pause for that duration. There are
             * checks in place to prevent you accidentally stopping a transitioning Scene but if you've got code to
             * override this understand that until the target Scene completes it might never be unlocked for input events.
             * @param config The transition configuration object.
             */
            transition(config: Phaser.Scenes.ScenePlugin.SceneTransitionConfig): boolean;

            /**
             * Add the Scene into the Scene Manager and start it if 'autoStart' is true or the Scene config 'active' property is set.
             * @param key The Scene key.
             * @param sceneConfig The config for the Scene.
             * @param autoStart Whether to start the Scene after it's added.
             */
            add(key: string, sceneConfig: Phaser.Scene | Phaser.Scenes.Settings.Config | Function, autoStart: boolean): Phaser.Scenes.ScenePlugin;

            /**
             * Launch the given Scene and run it in parallel with this one.
             * @param key The Scene to launch.
             * @param data The Scene data.
             */
            launch(key: string, data?: object): Phaser.Scenes.ScenePlugin;

            /**
             * Pause the Scene - this stops the update step from happening but it still renders.
             * @param key The Scene to pause.
             */
            pause(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Resume the Scene - starts the update loop again.
             * @param key The Scene to resume.
             */
            resume(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Makes the Scene sleep (no update, no render) but doesn't shutdown.
             * @param key The Scene to put to sleep.
             */
            sleep(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Makes the Scene wake-up (starts update and render)
             * @param key The Scene to wake up.
             */
            wake(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Makes this Scene sleep then starts the Scene given.
             * @param key The Scene to start.
             */
            switch(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Shutdown the Scene, clearing display list, timers, etc.
             * @param key The Scene to stop.
             */
            stop(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Sets the active state of the given Scene.
             * @param value The Scene to set the active state for.
             */
            setActive(value: boolean): Phaser.Scenes.ScenePlugin;

            /**
             * Sets the visible state of the given Scene.
             * @param value The Scene to set the visible state for.
             */
            setVisible(value: boolean): Phaser.Scenes.ScenePlugin;

            /**
             * Checks if the given Scene is sleeping or not?
             * @param key The Scene to check.
             */
            isSleeping(key: string): boolean;

            /**
             * Checks if the given Scene is active or not?
             * @param key The Scene to check.
             */
            isActive(key: string): boolean;

            /**
             * Checks if the given Scene is visible or not?
             * @param key The Scene to check.
             */
            isVisible(key: string): boolean;

            /**
             * Swaps the position of two scenes in the Scenes list.
             * 
             * This controls the order in which they are rendered and updated.
             * @param keyA The first Scene to swap.
             * @param keyB The second Scene to swap. If none is given it defaults to this Scene.
             */
            swapPosition(keyA: string, keyB?: string): Phaser.Scenes.ScenePlugin;

            /**
             * Swaps the position of two scenes in the Scenes list, so that Scene B is directly above Scene A.
             * 
             * This controls the order in which they are rendered and updated.
             * @param keyA The Scene that Scene B will be moved to be above.
             * @param keyB The Scene to be moved. If none is given it defaults to this Scene.
             */
            moveAbove(keyA: string, keyB?: string): Phaser.Scenes.ScenePlugin;

            /**
             * Swaps the position of two scenes in the Scenes list, so that Scene B is directly below Scene A.
             * 
             * This controls the order in which they are rendered and updated.
             * @param keyA The Scene that Scene B will be moved to be below.
             * @param keyB The Scene to be moved. If none is given it defaults to this Scene.
             */
            moveBelow(keyA: string, keyB?: string): Phaser.Scenes.ScenePlugin;

            /**
             * Removes a Scene from the SceneManager.
             * 
             * The Scene is removed from the local scenes array, it's key is cleared from the keys
             * cache and Scene.Systems.destroy is then called on it.
             * 
             * If the SceneManager is processing the Scenes when this method is called it wil
             * queue the operation for the next update sequence.
             * @param key The Scene to be removed.
             */
            remove(key: string | Phaser.Scene): Phaser.Scenes.SceneManager;

            /**
             * Moves a Scene up one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveUp(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Moves a Scene down one position in the Scenes list.
             * @param key The Scene to move.
             */
            moveDown(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Brings a Scene to the top of the Scenes list.
             * 
             * This means it will render above all other Scenes.
             * @param key The Scene to move.
             */
            bringToTop(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Sends a Scene to the back of the Scenes list.
             * 
             * This means it will render below all other Scenes.
             * @param key The Scene to move.
             */
            sendToBack(key: string): Phaser.Scenes.ScenePlugin;

            /**
             * Retrieve a Scene.
             * @param key The Scene to retrieve.
             */
            get(key: string): Phaser.Scene;

        }

        namespace Settings {
            type Config = {
                /**
                 * [description]
                 */
                key?: string;
                /**
                 * [description]
                 */
                active?: boolean;
                /**
                 * [description]
                 */
                visible?: boolean;
                /**
                 * [description]
                 */
                files?: false | LoaderFileObject[];
                /**
                 * [description]
                 */
                cameras?: InputJSONCameraObject | InputJSONCameraObject[];
                /**
                 * Overwrites the default injection map for a scene.
                 */
                map?: {[key: string]:  string};
                /**
                 * Extends the injection map for a scene.
                 */
                mapAdd?: {[key: string]:  string};
                /**
                 * [description]
                 */
                physics?: object;
                /**
                 * [description]
                 */
                loader?: object;
                /**
                 * [description]
                 */
                plugins?: false | any;
            };

            type Object = {
                /**
                 * [description]
                 */
                status: number;
                /**
                 * [description]
                 */
                key: string;
                /**
                 * [description]
                 */
                active: boolean;
                /**
                 * [description]
                 */
                visible: boolean;
                /**
                 * [description]
                 */
                isBooted: boolean;
                /**
                 * [description]
                 */
                isTransition: boolean;
                /**
                 * [description]
                 */
                transitionFrom: Phaser.Scene;
                /**
                 * [description]
                 */
                transitionDuration: integer;
                /**
                 * [description]
                 */
                transitionAllowInput: boolean;
                /**
                 * [description]
                 */
                data: object;
                /**
                 * [description]
                 */
                files: false | LoaderFileObject[];
                /**
                 * [description]
                 */
                cameras: InputJSONCameraObject | InputJSONCameraObject[];
                /**
                 * [description]
                 */
                map: {[key: string]:  string};
                /**
                 * [description]
                 */
                physics: object;
                /**
                 * [description]
                 */
                loader: object;
                /**
                 * [description]
                 */
                plugins: false | any;
            };

            /**
             * Takes a Scene configuration object and returns a fully formed Systems object.
             * @param config [description]
             */
            function create(config: string | Phaser.Scenes.Settings.Config): Phaser.Scenes.Settings.Object;

        }

        /**
         * The Scene Systems class.
         * 
         * 
         * 
         * This class is available from within a Scene under the property `sys`.
         * 
         * It is responsible for managing all of the plugins a Scene has running, including the display list, and
         * 
         * handling the update step and renderer. It also contains references to global systems belonging to Game.
         */
        class Systems {
            /**
             * 
             * @param scene The Scene that owns this Systems instance.
             * @param config Scene specific configuration settings.
             */
            constructor(scene: Phaser.Scene, config: string | Phaser.Scenes.Settings.Config);

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            game: Phaser.Game;

            /**
             * [description]
             */
            config: string | Phaser.Scenes.Settings.Config;

            /**
             * [description]
             */
            settings: Phaser.Scenes.Settings.Object;

            /**
             * A handy reference to the Scene canvas / context.
             */
            canvas: HTMLCanvasElement;

            /**
             * [description]
             */
            context: CanvasRenderingContext2D;

            /**
             * [description]
             */
            anims: Phaser.Animations.AnimationManager;

            /**
             * [description]
             */
            cache: Phaser.Cache.CacheManager;

            /**
             * [description]
             */
            plugins: Phaser.Boot.PluginManager;

            /**
             * [description]
             */
            registry: Phaser.Data.DataManager;

            /**
             * [description]
             */
            sound: Phaser.Sound.BaseSoundManager;

            /**
             * [description]
             */
            textures: Phaser.Textures.TextureManager;

            /**
             * [description]
             */
            add: Phaser.GameObjects.GameObjectFactory;

            /**
             * [description]
             */
            cameras: Phaser.Cameras.Scene2D.CameraManager;

            /**
             * [description]
             */
            displayList: Phaser.GameObjects.DisplayList;

            /**
             * [description]
             */
            events: Phaser.Events.EventEmitter;

            /**
             * [description]
             */
            make: Phaser.GameObjects.GameObjectCreator;

            /**
             * [description]
             */
            scenePlugin: Phaser.Scenes.ScenePlugin;

            /**
             * [description]
             */
            updateList: Phaser.GameObjects.UpdateList;

            /**
             * This method is called only once by the Scene Manager when the Scene is instantiated.
             * It is responsible for setting up all of the Scene plugins and references.
             * It should never be called directly.
             * @param game A reference to the Phaser Game instance.
             */
            protected init(game: Phaser.Game): void;

            /**
             * A single game step. Called automatically by the Scene Manager as a result of a Request Animation
             * Frame or Set Timeout call to the main Game instance.
             * @param time [description]
             * @param delta [description]
             */
            step(time: number, delta: number): void;

            /**
             * Called automatically by the Scene Manager. Instructs the Scene to render itself via
             * its Camera Manager to the renderer given.
             * @param renderer [description]
             */
            render(renderer: Phaser.Renderer.Canvas.CanvasRenderer | Phaser.Renderer.WebGL.WebGLRenderer): void;

            /**
             * Force a sort of the display list on the next render.
             */
            queueDepthSort(): void;

            /**
             * Immediately sorts the display list if the flag is set.
             */
            depthSort(): void;

            /**
             * Pause this Scene.
             * A paused Scene still renders, it just doesn't run ANY of its update handlers or systems.
             */
            pause(): Phaser.Scenes.Systems;

            /**
             * Resume this Scene from a paused state.
             */
            resume(): Phaser.Scenes.Systems;

            /**
             * Send this Scene to sleep.
             * 
             * A sleeping Scene doesn't run it's update step or render anything, but it also isn't shut down
             * or have any of its systems or children removed, meaning it can be re-activated at any point and
             * will carry on from where it left off. It also keeps everything in memory and events and callbacks
             * from other Scenes may still invoke changes within it, so be careful what is left active.
             */
            sleep(): Phaser.Scenes.Systems;

            /**
             * Wake-up this Scene if it was previously asleep.
             */
            wake(): Phaser.Scenes.Systems;

            /**
             * Is this Scene sleeping?
             */
            isSleeping(): boolean;

            /**
             * Is this Scene active?
             */
            isActive(): boolean;

            /**
             * Is this Scene currently transitioning out to, or in from another Scene?
             */
            isTransitioning(): boolean;

            /**
             * Is this Scene currently transitioning out from itself to another Scene?
             */
            isTransitionOut(): boolean;

            /**
             * Is this Scene currently transitioning in from another Scene?
             */
            isTransitionIn(): boolean;

            /**
             * Is this Scene visible and rendering?
             */
            isVisible(): boolean;

            /**
             * Sets the visible state of this Scene.
             * An invisible Scene will not render, but will still process updates.
             * @param value [description]
             */
            setVisible(value: boolean): Phaser.Scenes.Systems;

            /**
             * Set the active state of this Scene.
             * An active Scene will run its core update loop.
             * @param value If `true` the Scene will be resumed, if previously paused. If `false` it will be paused.
             */
            setActive(value: boolean): Phaser.Scenes.Systems;

            /**
             * Start this Scene running and rendering.
             * Called automatically by the SceneManager.
             * @param data Optional data object that may have been passed to this Scene from another.
             */
            start(data: object): void;

            /**
             * Called automatically by the SceneManager if the Game resizes.
             * Dispatches an event you can respond to in your game code.
             * @param width The new width of the game.
             * @param height The new height of the game.
             */
            resize(width: number, height: number): void;

            /**
             * Shutdown this Scene and send a shutdown event to all of its systems.
             * A Scene that has been shutdown will not run its update loop or render, but it does
             * not destroy any of its plugins or references. It is put into hibernation for later use.
             * If you don't ever plan to use this Scene again, then it should be destroyed instead
             * to free-up resources.
             */
            shutdown(): void;

        }

    }

    /**
     * [description]
     */
    class Scene {
        /**
         * 
         * @param config Scene specific configuration settings.
         */
        constructor(config: string | Phaser.Scenes.Settings.Config);

        /**
         * The Scene Systems. You must never overwrite this property, or all hell will break lose.
         */
        sys: Phaser.Scenes.Systems;

        /**
         * A reference to the Phaser.Game instance.
         * This property will only be available if defined in the Scene Injection Map.
         */
        game: Phaser.Game;

        /**
         * A reference to the global Animation Manager.
         * This property will only be available if defined in the Scene Injection Map.
         */
        anims: Phaser.Animations.AnimationManager;

        /**
         * A reference to the global Cache.
         * This property will only be available if defined in the Scene Injection Map.
         */
        cache: Phaser.Cache.CacheManager;

        /**
         * A reference to the game level Data Manager.
         * This property will only be available if defined in the Scene Injection Map.
         */
        registry: Phaser.Data.DataManager;

        /**
         * A reference to the Sound Manager.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        sound: Phaser.Sound.BaseSoundManager;

        /**
         * A reference to the Texture Manager.
         * This property will only be available if defined in the Scene Injection Map.
         */
        textures: Phaser.Textures.TextureManager;

        /**
         * A scene level Event Emitter.
         * This property will only be available if defined in the Scene Injection Map.
         */
        events: Phaser.Events.EventEmitter;

        /**
         * A scene level Camera System.
         * This property will only be available if defined in the Scene Injection Map.
         */
        cameras: Phaser.Cameras.Scene2D.CameraManager;

        /**
         * A scene level 3D Camera System.
         * This property will only be available if defined in the Scene Injection Map.
         */
        cameras3d: Phaser.Cameras.Sprite3D.CameraManager;

        /**
         * A scene level Game Object Factory.
         * This property will only be available if defined in the Scene Injection Map.
         */
        add: Phaser.GameObjects.GameObjectFactory;

        /**
         * A scene level Game Object Creator.
         * This property will only be available if defined in the Scene Injection Map.
         */
        make: Phaser.GameObjects.GameObjectCreator;

        /**
         * A reference to the Scene Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map.
         */
        scene: Phaser.Scenes.ScenePlugin;

        /**
         * A scene level Game Object Display List.
         * This property will only be available if defined in the Scene Injection Map.
         */
        children: Phaser.GameObjects.DisplayList;

        /**
         * A scene level Lights Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        lights: Phaser.GameObjects.DisplayList;

        /**
         * A scene level Data Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        data: Phaser.Data.DataManager;

        /**
         * A scene level Input Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        input: Phaser.Input.InputPlugin;

        /**
         * A scene level Loader Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        load: Phaser.Loader.LoaderPlugin;

        /**
         * A scene level Time and Clock Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        time: Phaser.Time.Clock;

        /**
         * A scene level Tween Manager Plugin.
         * This property will only be available if defined in the Scene Injection Map and the plugin is installed.
         */
        tweens: Phaser.Tweens.TweenManager;

        /**
         * A scene level Arcade Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        physics: Phaser.Physics.Arcade.ArcadePhysics;

        /**
         * A scene level Impact Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        impact: Phaser.Physics.Impact.ImpactPhysics;

        /**
         * A scene level Matter Physics Plugin.
         * This property will only be available if defined in the Scene Injection Map, the plugin is installed and configured.
         */
        matter: Phaser.Physics.Matter.MatterPhysics;

        /**
         * Should be overridden by your own Scenes.
         * @param time [description]
         * @param delta [description]
         */
        update(time: number, delta: number): void;

    }

    namespace Sound {
        /**
         * Class containing all the shared state and behavior of a sound object, independent of the implementation.
         */
        class BaseSound extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            constructor(manager: Phaser.Sound.BaseSoundManager, key: string, config?: SoundConfig);

            /**
             * Asset key for the sound.
             */
            key: string;

            /**
             * Flag indicating if sound is currently playing.
             */
            isPlaying: boolean;

            /**
             * Flag indicating if sound is currently paused.
             */
            isPaused: boolean;

            /**
             * A property that holds the value of sound's actual playback rate,
             * after its rate and detune values has been combined with global
             * rate and detune values.
             */
            totalRate: number;

            /**
             * A value representing the duration, in seconds.
             * It could be total sound duration or a marker duration.
             */
            duration: number;

            /**
             * The total duration of the sound in seconds.
             */
            totalDuration: number;

            /**
             * Object containing markers definitions.
             */
            markers: {[key: string]:  SoundMarker};

            /**
             * Currently playing marker.
             * 'null' if whole sound is playing.
             */
            currentMarker: SoundMarker;

            /**
             * Adds a marker into the current sound. A marker is represented by name, start time, duration, and optionally config object.
             * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.
             * @param marker Marker object.
             */
            addMarker(marker: SoundMarker): boolean;

            /**
             * Updates previously added marker.
             * @param marker Marker object with updated values.
             */
            updateMarker(marker: SoundMarker): boolean;

            /**
             * Removes a marker from the sound.
             * @param markerName The name of the marker to remove.
             */
            removeMarker(markerName: string): SoundMarker;

            /**
             * Play this sound, or a marked section of it.
             * It always plays the sound from the start. If you want to start playback from a specific time
             * you can set 'seek' setting of the config object, provided to this call, to that value.
             * @param markerName If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound. Default ''.
             * @param config Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
             */
            play(markerName?: string, config?: SoundConfig): boolean;

            /**
             * Pauses the sound.
             */
            pause(): boolean;

            /**
             * Resumes the sound.
             */
            resume(): boolean;

            /**
             * Stop playing this sound.
             */
            stop(): boolean;

            /**
             * Method used internally for applying config values to some of the sound properties.
             */
            protected applyConfig(): void;

            /**
             * Method used internally for resetting values of some of the config properties.
             */
            protected resetConfig(): void;

            /**
             * Update method called automatically by sound manager on every game step.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Method used internally to calculate total playback rate of the sound.
             */
            protected calculateRate(): void;

            /**
             * Destroys this sound and all associated events and marks it for removal from the sound manager.
             */
            destroy(): void;

        }

        /**
         * The sound manager is responsible for playing back audio via Web Audio API or HTML Audio tag as fallback.
         * 
         * The audio file type and the encoding of those files are extremely important.
         * 
         * 
         * 
         * Not all browsers can play all audio formats.
         * 
         * 
         * 
         * There is a good guide to what's supported [here](https://developer.mozilla.org/en-US/Apps/Fundamentals/Audio_and_video_delivery/Cross-browser_audio_basics#Audio_Codec_Support).
         */
        class BaseSoundManager extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param game Reference to the current game instance.
             */
            constructor(game: Phaser.Game);

            /**
             * Local reference to game.
             */
            game: Phaser.Game;

            /**
             * Global mute setting.
             */
            mute: boolean;

            /**
             * Global volume setting.
             */
            volume: number;

            /**
             * Flag indicating if sounds should be paused when game looses focus,
             * for instance when user switches to another tab/program/app.
             */
            pauseOnBlur: boolean;

            /**
             * Mobile devices require sounds to be triggered from an explicit user action,
             * such as a tap, before any sound can be loaded/played on a web page.
             * Set to true if the audio system is currently locked awaiting user interaction.
             */
            locked: boolean;

            /**
             * Adds a new sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            add(key: string, config?: SoundConfig): Phaser.Sound.BaseSound;

            /**
             * Adds a new audio sprite sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            addAudioSprite(key: string, config?: SoundConfig): Phaser.Sound.BaseSound.AudioSpriteSound;

            /**
             * Enables playing sound on the fly without the need to keep a reference to it.
             * Sound will auto destroy once its playback ends.
             * @param key Asset key for the sound.
             * @param extra An optional additional object containing settings to be applied to the sound. It could be either config or marker object.
             */
            play(key: string, extra?: SoundConfig | SoundMarker): boolean;

            /**
             * Enables playing audio sprite sound on the fly without the need to keep a reference to it.
             * Sound will auto destroy once its playback ends.
             * @param key Asset key for the sound.
             * @param spriteName The name of the sound sprite to play.
             * @param config An optional config object containing default sound settings.
             */
            playAudioSprite(key: string, spriteName: string, config?: SoundConfig): boolean;

            /**
             * Removes a sound from the sound manager.
             * The removed sound is destroyed before removal.
             * @param sound The sound object to remove.
             */
            remove(sound: Phaser.Sound.BaseSound): boolean;

            /**
             * Removes all sounds from the sound manager that have an asset key matching the given value.
             * The removed sounds are destroyed before removal.
             * @param key The key to match when removing sound objects.
             */
            removeByKey(key: string): number;

            /**
             * Pauses all the sounds in the game.
             */
            pauseAll(): void;

            /**
             * Resumes all the sounds in the game.
             */
            resumeAll(): void;

            /**
             * Stops all the sounds in the game.
             */
            stopAll(): void;

            /**
             * Method used internally for unlocking audio playback on devices that
             * require user interaction before any sound can be played on a web page.
             * 
             * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).
             */
            protected unlock(): void;

            /**
             * Method used internally for pausing sound manager if
             * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.
             */
            protected onBlur(): void;

            /**
             * Method used internally for resuming sound manager if
             * Phaser.Sound.BaseSoundManager#pauseOnBlur is set to true.
             */
            protected onFocus(): void;

            /**
             * Update method called on every game step.
             * Removes destroyed sounds and updates every active sound in the game.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Destroys all the sounds in the game and all associated events.
             */
            destroy(): void;

            /**
             * Sets the global playback rate at which all the sounds will be played.
             * 
             * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             * @param value Global playback rate at which all the sounds will be played.
             */
            setRate(value: number): Phaser.Sound.BaseSoundManager;

            /**
             * Global playback rate at which all the sounds will be played.
             * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audio's playback speed.
             */
            rate: number;

            /**
             * Sets the global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             * @param value The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            setDetune(value: number): Phaser.Sound.BaseSoundManager;

            /**
             * Global detuning of all sounds in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            detune: number;

        }

        /**
         * HTML5 Audio implementation of the sound.
         */
        class HTML5AudioSound extends Phaser.Sound.BaseSound {
            /**
             * 
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings. Default {}.
             */
            constructor(manager: Phaser.Sound.HTML5AudioSoundManager, key: string, config?: SoundConfig);

            /**
             * Play this sound, or a marked section of it.
             * It always plays the sound from the start. If you want to start playback from a specific time
             * you can set 'seek' setting of the config object, provided to this call, to that value.
             * @param markerName If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound. Default ''.
             * @param config Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
             */
            play(markerName?: string, config?: SoundConfig): boolean;

            /**
             * Pauses the sound.
             */
            pause(): boolean;

            /**
             * Resumes the sound.
             */
            resume(): boolean;

            /**
             * Stop playing this sound.
             */
            stop(): boolean;

            /**
             * Update method called automatically by sound manager on every game step.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Calls Phaser.Sound.BaseSound#destroy method
             * and cleans up all HTML5 Audio related stuff.
             */
            destroy(): void;

            /**
             * Method used internally to calculate total playback rate of the sound.
             */
            protected calculateRate(): void;

            /**
             * Boolean indicating whether the sound is muted or not.
             * Gets or sets the muted state of this sound.
             */
            mute: boolean;

            /**
             * Sets the muted state of this Sound.
             * @param value `true` to mute this sound, `false` to unmute it.
             */
            setMute(value: boolean): Phaser.Sound.HTML5AudioSound;

            /**
             * Gets or sets the volume of this sound, a value between 0 (silence) and 1 (full volume).
             */
            volume: number;

            /**
             * Sets the volume of this Sound.
             * @param value The volume of the sound.
             */
            setVolume(value: number): Phaser.Sound.HTML5AudioSound;

            /**
             * Rate at which this Sound will be played.
             * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             */
            rate: number;

            /**
             * Sets the playback rate of this Sound.
             * 
             * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             * @param value The playback rate at of this Sound.
             */
            setRate(value: number): Phaser.Sound.HTML5AudioSound;

            /**
             * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            detune: number;

            /**
             * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             * @param value The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            setDetune(value: number): Phaser.Sound.HTML5AudioSound;

            /**
             * Property representing the position of playback for this sound, in seconds.
             * Setting it to a specific value moves current playback to that position.
             * The value given is clamped to the range 0 to current marker duration.
             * Setting seek of a stopped sound has no effect.
             */
            seek: number;

            /**
             * Seeks to a specific point in this sound.
             * @param value The point in the sound to seek to.
             */
            setSeek(value: number): Phaser.Sound.HTML5AudioSound;

            /**
             * Flag indicating whether or not the sound or current sound marker will loop.
             */
            loop: boolean;

            /**
             * Sets the loop state of this Sound.
             * @param value `true` to loop this sound, `false` to not loop it.
             */
            setLoop(value: boolean): Phaser.Sound.HTML5AudioSound;

        }

        /**
         * HTML5AudioSoundManager
         */
        class HTML5AudioSoundManager extends Phaser.Sound.BaseSoundManager {
            /**
             * 
             * @param game Reference to the current game instance.
             */
            constructor(game: Phaser.Game);

            /**
             * Flag indicating whether if there are no idle instances of HTML5 Audio tag,
             * for any particular sound, if one of the used tags should be hijacked and used
             * for succeeding playback or if succeeding Phaser.Sound.HTML5AudioSound#play
             * call should be ignored.
             */
            override: boolean;

            /**
             * Value representing time difference, in seconds, between calling
             * play method on an audio tag and when it actually starts playing.
             * It is used to achieve more accurate delayed sound playback.
             * 
             * You might need to tweak this value to get the desired results
             * since audio play delay varies depending on the browser/platform.
             */
            audioPlayDelay: number;

            /**
             * A value by which we should offset the loop end marker of the
             * looping sound to compensate for lag, caused by changing audio
             * tag playback position, in order to achieve gapless looping.
             * 
             * You might need to tweak this value to get the desired results
             * since loop lag varies depending on the browser/platform.
             */
            loopEndOffset: number;

            /**
             * Adds a new sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            add(key: string, config?: SoundConfig): Phaser.Sound.HTML5AudioSound;

            /**
             * Unlocks HTML5 Audio loading and playback on mobile
             * devices on the initial explicit user interaction.
             */
            unlock(): void;

            /**
             * Method used internally for pausing sound manager if
             * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
             */
            protected onBlur(): void;

            /**
             * Method used internally for resuming sound manager if
             * Phaser.Sound.HTML5AudioSoundManager#pauseOnBlur is set to true.
             */
            protected onFocus(): void;

            /**
             * Calls Phaser.Sound.BaseSoundManager#destroy method
             * and cleans up all HTML5 Audio related stuff.
             */
            destroy(): void;

            /**
             * Method used internally by Phaser.Sound.HTML5AudioSound class methods and property setters
             * to check if sound manager is locked and then either perform action immediately or queue it
             * to be performed once the sound manager gets unlocked.
             * @param sound Sound object on which to perform queued action.
             * @param prop Name of the method to be called or property to be assigned a value to.
             * @param value An optional parameter that either holds an array of arguments to be passed to the method call or value to be set to the property.
             */
            protected isLocked(sound: Phaser.Sound.HTML5AudioSound, prop: string, value?: any): boolean;

            /**
             * Sets the muted state of all this Sound Manager.
             * @param value `true` to mute all sounds, `false` to unmute them.
             */
            setMute(value: boolean): Phaser.Sound.HTML5AudioSoundManager;

            mute: boolean;

            /**
             * Sets the volume of this Sound Manager.
             * @param value The global volume of this Sound Manager.
             */
            setVolume(value: number): Phaser.Sound.HTML5AudioSoundManager;

            volume: number;

        }

        /**
         * No audio implementation of the sound. It is used if audio has been
         * 
         * disabled in the game config or the device doesn't support any audio.
         * 
         * 
         * 
         * It represents a graceful degradation of sound logic that provides
         * 
         * minimal functionality and prevents Phaser projects that use audio from
         * 
         * breaking on devices that don't support any audio playback technologies.
         */
        class NoAudioSound extends Phaser.Sound.BaseSound {
            /**
             * 
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings. Default {}.
             */
            constructor(manager: Phaser.Sound.NoAudioSoundManager, key: string, config?: SoundConfig);

        }

        /**
         * No audio implementation of the sound manager. It is used if audio has been
         * 
         * disabled in the game config or the device doesn't support any audio.
         * 
         * 
         * 
         * It represents a graceful degradation of sound manager logic that provides
         * 
         * minimal functionality and prevents Phaser projects that use audio from
         * 
         * breaking on devices that don't support any audio playback technologies.
         */
        class NoAudioSoundManager extends Phaser.Sound.BaseSoundManager {
            /**
             * 
             * @param game Reference to the current game instance.
             */
            constructor(game: Phaser.Game);

        }

        /**
         * Creates a Web Audio, HTML5 Audio or No Audio Sound Manager based on config and device settings.
         * @param game Reference to the current game instance.
         */
        function SoundManagerCreator(game: Phaser.Game): void;

        /**
         * Web Audio API implementation of the sound.
         */
        class WebAudioSound extends Phaser.Sound.BaseSound {
            /**
             * 
             * @param manager Reference to the current sound manager instance.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings. Default {}.
             */
            constructor(manager: Phaser.Sound.WebAudioSoundManager, key: string, config?: SoundConfig);

            /**
             * Play this sound, or a marked section of it.
             * 
             * It always plays the sound from the start. If you want to start playback from a specific time
             * you can set 'seek' setting of the config object, provided to this call, to that value.
             * @param markerName If you want to play a marker then provide the marker name here, otherwise omit it to play the full sound. Default ''.
             * @param config Optional sound config object to be applied to this marker or entire sound if no marker name is provided. It gets memorized for future plays of current section of the sound.
             */
            play(markerName?: string, config?: SoundConfig): boolean;

            /**
             * Pauses the sound.
             */
            pause(): boolean;

            /**
             * Resumes the sound.
             */
            resume(): boolean;

            /**
             * Stop playing this sound.
             */
            stop(): boolean;

            /**
             * Method used internally for applying config values to some of the sound properties.
             */
            protected applyConfig(): void;

            /**
             * Update method called automatically by sound manager on every game step.
             * @param time The current timestamp as generated by the Request Animation Frame or SetTimeout.
             * @param delta The delta time elapsed since the last frame.
             */
            protected update(time: number, delta: number): void;

            /**
             * Calls Phaser.Sound.BaseSound#destroy method
             * and cleans up all Web Audio API related stuff.
             */
            destroy(): void;

            /**
             * Method used internally to calculate total playback rate of the sound.
             */
            protected calculateRate(): void;

            /**
             * Rate at which this Sound will be played.
             * Value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             */
            rate: number;

            /**
             * Sets the playback rate of this Sound.
             * 
             * For example, a value of 1.0 plays the audio at full speed, 0.5 plays the audio at half speed
             * and 2.0 doubles the audios playback speed.
             * @param value The playback rate at of this Sound.
             */
            setRate(value: number): Phaser.Sound.WebAudioSound;

            /**
             * The detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            detune: number;

            /**
             * Sets the detune value of this Sound, given in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
             * The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             * @param value The range of the value is -1200 to 1200, but we recommend setting it to [50](https://en.wikipedia.org/wiki/50_Cent).
             */
            setDetune(value: number): Phaser.Sound.WebAudioSound;

            /**
             * Boolean indicating whether the sound is muted or not.
             * Gets or sets the muted state of this sound.
             */
            mute: boolean;

            /**
             * Sets the muted state of this Sound.
             * @param value `true` to mute this sound, `false` to unmute it.
             */
            setMute(value: boolean): Phaser.Sound.WebAudioSound;

            /**
             * Gets or sets the volume of this sound, a value between 0 (silence) and 1 (full volume).
             */
            volume: number;

            /**
             * Sets the volume of this Sound.
             * @param value The volume of the sound.
             */
            setVolume(value: number): Phaser.Sound.WebAudioSound;

            /**
             * Property representing the position of playback for this sound, in seconds.
             * Setting it to a specific value moves current playback to that position.
             * The value given is clamped to the range 0 to current marker duration.
             * Setting seek of a stopped sound has no effect.
             */
            seek: number;

            /**
             * Seeks to a specific point in this sound.
             * @param value The point in the sound to seek to.
             */
            setSeek(value: number): Phaser.Sound.WebAudioSound;

            /**
             * Flag indicating whether or not the sound or current sound marker will loop.
             */
            loop: boolean;

            /**
             * Sets the loop state of this Sound.
             * @param value `true` to loop this sound, `false` to not loop it.
             */
            setLoop(value: boolean): Phaser.Sound.WebAudioSound;

        }

        /**
         * Web Audio API implementation of the sound manager.
         */
        class WebAudioSoundManager extends Phaser.Sound.BaseSoundManager {
            /**
             * 
             * @param game Reference to the current game instance.
             */
            constructor(game: Phaser.Game);

            /**
             * Adds a new sound into the sound manager.
             * @param key Asset key for the sound.
             * @param config An optional config object containing default sound settings.
             */
            add(key: string, config?: SoundConfig): Phaser.Sound.WebAudioSound;

            /**
             * Unlocks Web Audio API on iOS devices on the initial touch event.
             * 
             * Read more about how this issue is handled here in [this article](https://medium.com/@pgoloskokovic/unlocking-web-audio-the-smarter-way-8858218c0e09).
             */
            unlock(): void;

            /**
             * Method used internally for pausing sound manager if
             * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.
             */
            protected onBlur(): void;

            /**
             * Method used internally for resuming sound manager if
             * Phaser.Sound.WebAudioSoundManager#pauseOnBlur is set to true.
             */
            protected onFocus(): void;

            /**
             * Calls Phaser.Sound.BaseSoundManager#destroy method
             * and cleans up all Web Audio API related stuff.
             */
            destroy(): void;

            /**
             * Sets the muted state of all this Sound Manager.
             * @param value `true` to mute all sounds, `false` to unmute them.
             */
            setMute(value: boolean): Phaser.Sound.WebAudioSoundManager;

            mute: boolean;

            /**
             * Sets the volume of this Sound Manager.
             * @param value The global volume of this Sound Manager.
             */
            setVolume(value: number): Phaser.Sound.WebAudioSoundManager;

            volume: number;

        }

    }

    namespace Structs {
        /**
         * [description]
         */
        class List<T> {
            /**
             * 
             * @param parent [description]
             */
            constructor(parent: any);

            /**
             * The parent of this list.
             */
            parent: any;

            /**
             * The objects that belong to this collection.
             */
            list: T[];

            /**
             * [description]
             */
            position: integer;

            /**
             * A callback that is invoked every time a child is added to this list.
             */
            addCallback: Function;

            /**
             * A callback that is invoked every time a child is removed from this list.
             */
            removeCallback: Function;

            /**
             * The property key to sort by.
             */
            _sortKey: string;

            /**
             * [description]
             * @param child [description]
             * @param skipCallback Skip calling the List.addCallback if this child is added successfully. Default false.
             */
            add(child: T, skipCallback?: boolean): T;

            /**
             * [description]
             * @param child [description]
             * @param index [description] Default 0.
             * @param skipCallback Skip calling the List.addCallback if this child is added successfully. Default false.
             */
            addAt(child: T, index?: integer, skipCallback?: boolean): T;

            /**
             * [description]
             * @param index [description]
             */
            getAt(index: integer): T;

            /**
             * [description]
             * @param child [description]
             */
            getIndex(child: T): integer;

            /**
             * Sort the contents of this List so the items are in order based
             * on the given property. For example, `sort('alpha')` would sort the List
             * contents based on the value of their `alpha` property.
             * @param property The property to lexically sort by.
             */
            sort(property: string): T[];

            /**
             * Searches for the first instance of a child with its `name`
             * property matching the given argument. Should more than one child have
             * the same name only the first is returned.
             * @param name The name to search for.
             */
            getByName(name: string): T | null;

            /**
             * Returns a random child from the group.
             * @param startIndex Offset from the front of the group (lowest child). Default 0.
             * @param length Restriction on the number of values you want to randomly select from. Default (to top).
             */
            getRandom(startIndex?: integer, length?: integer): T | null;

            /**
             * [description]
             * @param property [description]
             * @param value [description]
             * @param startIndex [description] Default 0.
             * @param endIndex [description]
             */
            getFirst(property: string, value: T, startIndex?: number, endIndex?: number): T | null;

            /**
             * Returns all children in this List.
             * 
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             * 
             * For example: `getAll('parent')` would return only children that have a property called `parent`.
             * 
             * You can also specify a value to compare the property to:
             * 
             * `getAll('visible', true)` would return only children that have their visible property set to `true`.
             * 
             * Optionally you can specify a start and end index. For example if this List had 100 children,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 children in the List.
             * @param property An optional property to test against the value argument.
             * @param value If property is set then Child.property must strictly equal this value to be included in the results.
             * @param startIndex The first child index to start the search from.
             * @param endIndex The last child index to search up until.
             */
            getAll(property?: string, value?: T, startIndex?: integer, endIndex?: integer): T[];

            /**
             * [description]
             * @param property [description]
             * @param value [description]
             */
            count(property: string, value: T): integer;

            /**
             * [description]
             * @param child1 [description]
             * @param child2 [description]
             */
            swap(child1: T, child2: T): void;

            /**
             * [description]
             * @param child [description]
             * @param index [description]
             */
            moveTo(child: T, index: integer): T;

            /**
             * [description]
             * @param child [description]
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            remove(child: T, skipCallback?: boolean): T;

            /**
             * [description]
             * @param index [description]
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            removeAt(index: integer, skipCallback?: boolean): T;

            /**
             * [description]
             * @param startIndex [description] Default 0.
             * @param endIndex [description]
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            removeBetween(startIndex?: integer, endIndex?: integer, skipCallback?: boolean): T[];

            /**
             * Removes all the items.
             * @param skipCallback Skip calling the List.removeCallback. Default false.
             */
            removeAll(skipCallback?: boolean): Phaser.Structs.List<T>;

            /**
             * Brings the given child to the top of this List.
             * @param child [description]
             */
            bringToTop(child: T): T;

            /**
             * Sends the given child to the bottom of this List.
             * @param child [description]
             */
            sendToBack(child: T): T;

            /**
             * Moves the given child up one place in this group unless it's already at the top.
             * @param child [description]
             */
            moveUp(child: T): T;

            /**
             * Moves the given child down one place in this group unless it's already at the bottom.
             * @param child [description]
             */
            moveDown(child: T): T;

            /**
             * Reverses the order of all children in this List.
             */
            reverse(): Phaser.Structs.List<T>;

            /**
             * [description]
             */
            shuffle(): Phaser.Structs.List<T>;

            /**
             * Replaces a child of this List with the given newChild. The newChild cannot be a member of this List.
             * @param oldChild The child in this List that will be replaced.
             * @param newChild The child to be inserted into this List.
             */
            replace(oldChild: T, newChild: T): T;

            /**
             * [description]
             * @param child [description]
             */
            exists(child: T): boolean;

            /**
             * Sets the property `key` to the given value on all members of this List.
             * @param property [description]
             * @param value [description]
             * @param startIndex The first child index to start the search from.
             * @param endIndex The last child index to search up until.
             */
            setAll(property: string, value: T, startIndex?: integer, endIndex?: integer): void;

            /**
             * Passes all children to the given callback.
             * @param callback The function to call.
             * @param thisArg Value to use as `this` when executing callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            each(callback: EachListCallback<T>, thisArg?: any, ...args: any[]): void;

            /**
             * [description]
             */
            shutdown(): void;

            /**
             * [description]
             */
            destroy(): void;

            /**
             * [description]
             */
            length: integer;

            /**
             * [description]
             */
            first: integer;

            /**
             * [description]
             */
            last: integer;

            /**
             * [description]
             */
            next: integer;

            /**
             * [description]
             */
            previous: integer;

        }

        /**
         * The keys of a Map can be arbitrary values.
         * 
         * var map = new Map([
         * 
         *    [ 1, 'one' ],
         * 
         *    [ 2, 'two' ],
         * 
         *    [ 3, 'three' ]
         * 
         * ]);
         */
        class Map<K, V> {
            /**
             * 
             * @param elements [description]
             */
            constructor(elements: V[]);

            /**
             * [description]
             */
            entries: {[key: string]:  V};

            /**
             * [description]
             */
            size: number;

            /**
             * [description]
             * @param key [description]
             * @param value [description]
             */
            set(key: K, value: V): Phaser.Structs.Map<K, V>;

            /**
             * [description]
             * @param key [description]
             */
            get(key: K): V;

            /**
             * [description]
             */
            getArray(): V[];

            /**
             * [description]
             * @param key [description]
             */
            has(key: K): boolean;

            /**
             * [description]
             * @param key [description]
             */
            delete(key: K): Phaser.Structs.Map<K, V>;

            /**
             * [description]
             */
            clear(): Phaser.Structs.Map<K, V>;

            /**
             * [description]
             */
            keys(): K[];

            /**
             * [description]
             */
            values(): V[];

            /**
             * [description]
             */
            dump(): void;

            /**
             * [description]
             * @param callback [description]
             */
            each(callback: EachMapCallback<V>): Phaser.Structs.Map<K, V>;

            /**
             * [description]
             * @param value [description]
             */
            contains(value: V): boolean;

            /**
             * Merges all new keys from the given Map into this one
             * If it encounters a key that already exists it will be skipped
             * unless override = true.
             * @param map [description]
             * @param override [description] Default false.
             */
            merge(map: Phaser.Structs.Map<K, V>, override?: boolean): Phaser.Structs.Map<K, V>;

        }

        /**
         * [description]
         */
        class ProcessQueue<T> {
            /**
             * [description]
             * @param item [description]
             */
            add(item: T): Phaser.Structs.ProcessQueue<T>;

            /**
             * [description]
             * @param item [description]
             */
            remove(item: T): Phaser.Structs.ProcessQueue<T>;

            /**
             * [description]
             */
            update(): T[];

            /**
             * [description]
             */
            getActive(): T[];

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * RBush is a high-performance JavaScript library for 2D spatial indexing of points and rectangles.
         * 
         * It's based on an optimized R-tree data structure with bulk insertion support.
         * 
         * 
         * 
         * Spatial index is a special data structure for points and rectangles that allows you to perform queries like
         * 
         * "all items within this bounding box" very efficiently (e.g. hundreds of times faster than looping over all items).
         * 
         * 
         * 
         * This version of RBush uses a fixed min/max accessor structure of `[ '.left', '.top', '.right', '.bottom' ]`.
         * 
         * This is to avoid the eval like function creation that the original library used, which caused CSP policy violations.
         */
        class RTree {
        }

        /**
         * A Set is a collection of unique elements.
         */
        class Set<T> {
            /**
             * 
             * @param elements [description]
             */
            constructor(elements?: T[]);

            /**
             * [description]
             */
            entries: T[];

            /**
             * [description]
             * @param value [description]
             */
            set(value: T): Phaser.Structs.Set<T>;

            /**
             * [description]
             * @param property [description]
             * @param value [description]
             */
            get(property: string, value: T): T;

            /**
             * [description]
             */
            getArray(): T[];

            /**
             * [description]
             * @param value [description]
             */
            delete(value: T): Phaser.Structs.Set<T>;

            /**
             * [description]
             */
            dump(): void;

            /**
             * For when you know this Set will be modified during the iteration.
             * @param callback [description]
             * @param callbackScope [description]
             */
            each(callback: EachSetCallback<T>, callbackScope: any): Phaser.Structs.Set<T>;

            /**
             * For when you absolutely know this Set won't be modified during the iteration.
             * @param callback [description]
             * @param callbackScope [description]
             */
            iterate(callback: EachSetCallback<T>, callbackScope: any): Phaser.Structs.Set<T>;

            /**
             * [description]
             * @param callbackKey [description]
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            iterateLocal(callbackKey: string, ...args: any[]): Phaser.Structs.Set<T>;

            /**
             * [description]
             */
            clear(): Phaser.Structs.Set<T>;

            /**
             * [description]
             * @param value [description]
             */
            contains(value: T): boolean;

            /**
             * [description]
             * @param set [description]
             */
            union(set: Phaser.Structs.Set<T>): Phaser.Structs.Set<T>;

            /**
             * [description]
             * @param set [description]
             */
            intersect(set: Phaser.Structs.Set<T>): Phaser.Structs.Set<T>;

            /**
             * [description]
             * @param set [description]
             */
            difference(set: Phaser.Structs.Set<T>): Phaser.Structs.Set<T>;

            /**
             * [description]
             */
            size: integer;

        }

    }

    namespace Textures {
        /**
         * Filter Types.
         */
        enum FilterMode {
            /**
             * Linear filter type.
             */
            LINEAR,
            /**
             * Nearest neighbor filter type.
             */
            NEAREST,
        }

        /**
         * A Frame is a section of a Texture.
         */
        class Frame {
            /**
             * 
             * @param texture The Texture this Frame is a part of.
             * @param name The name of this Frame. The name is unique within the Texture.
             * @param sourceIndex The index of the TextureSource that this Frame is a part of.
             * @param x The x coordinate of the top-left of this Frame.
             * @param y The y coordinate of the top-left of this Frame.
             * @param width The width of this Frame.
             * @param height The height of this Frame.
             */
            constructor(texture: Phaser.Textures.Texture, name: integer | string, sourceIndex: integer, x: number, y: number, width: number, height: number);

            /**
             * The Texture this Frame is a part of.
             */
            texture: Phaser.Textures.Texture;

            /**
             * The name of this Frame.
             * The name is unique within the Texture.
             */
            name: string;

            /**
             * The TextureSource this Frame is part of.
             */
            source: Phaser.Textures.TextureSource;

            /**
             * The index of the TextureSource in the Texture sources array.
             */
            sourceIndex: integer;

            /**
             * X position within the source image to cut from.
             */
            cutX: integer;

            /**
             * Y position within the source image to cut from.
             */
            cutY: integer;

            /**
             * The width of the area in the source image to cut.
             */
            cutWidth: integer;

            /**
             * The height of the area in the source image to cut.
             */
            cutHeight: integer;

            /**
             * The X rendering offset of this Frame, taking trim into account.
             */
            x: integer;

            /**
             * The Y rendering offset of this Frame, taking trim into account.
             */
            y: integer;

            /**
             * The rendering width of this Frame, taking trim into account.
             */
            width: integer;

            /**
             * The rendering height of this Frame, taking trim into account.
             */
            height: integer;

            /**
             * Half the width, floored.
             * Precalculated for the renderer.
             */
            halfWidth: integer;

            /**
             * Half the height, floored.
             * Precalculated for the renderer.
             */
            halfHeight: integer;

            /**
             * The x center of this frame, floored.
             */
            centerX: integer;

            /**
             * The y center of this frame, floored.
             */
            centerY: integer;

            /**
             * The horizontal pivot point of this Frame.
             */
            pivotX: number;

            /**
             * The vertical pivot point of this Frame.
             */
            pivotY: number;

            /**
             * Does this Frame have a custom pivot point?
             */
            customPivot: boolean;

            /**
             * **CURRENTLY UNSUPPORTED**
             * 
             * Is this frame is rotated or not in the Texture?
             * Rotation allows you to use rotated frames in texture atlas packing.
             * It has nothing to do with Sprite rotation.
             */
            rotated: boolean;

            /**
             * Over-rides the Renderer setting.
             * -1 = use Renderer Setting
             * 0 = No rounding
             * 1 = Round
             */
            autoRound: integer;

            /**
             * Any Frame specific custom data can be stored here.
             */
            customData: object;

            /**
             * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.
             * @param actualWidth The width of the frame before being trimmed.
             * @param actualHeight The height of the frame before being trimmed.
             * @param destX The destination X position of the trimmed frame for display.
             * @param destY The destination Y position of the trimmed frame for display.
             * @param destWidth The destination width of the trimmed frame for display.
             * @param destHeight The destination height of the trimmed frame for display.
             */
            setTrim(actualWidth: number, actualHeight: number, destX: number, destY: number, destWidth: number, destHeight: number): Phaser.Textures.Frame;

            /**
             * Updates the internal WebGL UV cache and the drawImage cache.
             */
            updateUVs(): Phaser.Textures.Frame;

            /**
             * Updates the internal WebGL UV cache.
             */
            updateUVsInverted(): Phaser.Textures.Frame;

            /**
             * Clones this Frame into a new Frame object.
             */
            clone(): Phaser.Textures.Frame;

            /**
             * Destroys this Frames references.
             */
            destroy(): void;

            /**
             * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
             * before being packed.
             */
            realWidth: number;

            /**
             * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,
             * before being packed.
             */
            realHeight: number;

            /**
             * The UV data for this Frame.
             */
            uvs: object;

            /**
             * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)
             */
            radius: number;

            /**
             * Is the Frame trimmed or not?
             */
            trimmed: boolean;

            /**
             * The Canvas drawImage data object.
             */
            canvasData: object;

        }

        /**
         * Linear filter type.
         */
        const LINEAR: any;

        /**
         * Nearest Neighbor filter type.
         */
        const NEAREST: any;

        namespace Parsers {
        }

        /**
         * A Texture consists of a source, usually an Image from the Cache, or a Canvas, and a collection
         * 
         * of Frames. The Frames represent the different areas of the Texture. For example a texture atlas
         * 
         * may have many Frames, one for each element within the atlas. Where-as a single image would have
         * 
         * just one frame, that encompasses the whole image.
         * 
         * 
         * 
         * Textures are managed by the global TextureManager. This is a singleton class that is
         * 
         * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
         * 
         * 
         * 
         * Sprites and other Game Objects get the texture data they need from the TextureManager.
         */
        class Texture {
            /**
             * 
             * @param manager A reference to the Texture Manager this Texture belongs to.
             * @param key The unique string-based key of this Texture.
             * @param source The source that is used to create the texture. Usually an Image, but can also be a Canvas.
             * @param width The width of the Texture. This is optional and automatically derived from the source images.
             * @param height The height of the Texture. This is optional and automatically derived from the source images.
             */
            constructor(manager: Phaser.Textures.TextureManager, key: string, source: HTMLImageElement | HTMLCanvasElement, width?: number, height?: number);

            /**
             * A reference to the Texture Manager this Texture belongs to.
             */
            manager: Phaser.Textures.TextureManager;

            /**
             * The unique string-based key of this Texture.
             */
            key: string;

            /**
             * An array of TextureSource instances.
             * These are unique to this Texture and contain the actual Image (or Canvas) data.
             */
            source: Phaser.Textures.TextureSource[];

            /**
             * An array of TextureSource data instances.
             * Used to store additional data images, such as normal maps or specular maps.
             */
            dataSource: any[];

            /**
             * A key-value object pair associating the unique Frame keys with the Frames objects.
             */
            frames: object;

            /**
             * Any additional data that was set in the source JSON (if any),
             * or any extra data you'd like to store relating to this texture
             */
            customData: object;

            /**
             * The name of the first frame of the Texture.
             */
            firstFrame: string;

            /**
             * The total number of Frames in this Texture.
             */
            frameTotal: integer;

            /**
             * Adds a new Frame to this Texture.
             * 
             * A Frame is a rectangular region of a TextureSource with a unique index or string-based key.
             * @param name The name of this Frame. The name is unique within the Texture.
             * @param sourceIndex The index of the TextureSource that this Frame is a part of.
             * @param x The x coordinate of the top-left of this Frame.
             * @param y The y coordinate of the top-left of this Frame.
             * @param width The width of this Frame.
             * @param height The height of this Frame.
             */
            add(name: integer | string, sourceIndex: integer, x: number, y: number, width: number, height: number): Phaser.Textures.Frame;

            /**
             * Checks to see if a Frame matching the given key exists within this Texture.
             * @param name The key of the Frame to check for.
             */
            has(name: string): boolean;

            /**
             * Gets a Frame from this Texture based on either the key or the index of the Frame.
             * 
             * In a Texture Atlas Frames are typically referenced by a key.
             * In a Sprite Sheet Frames are referenced by an index.
             * Passing no value for the name returns the base texture.
             * @param name The string-based name, or integer based index, of the Frame to get from this Texture.
             */
            get(name?: string | integer): Phaser.Textures.Frame;

            /**
             * Takes the given TextureSource and returns the index of it within this Texture.
             * If it's not in this Texture, it returns -1.
             * Unless this Texture has multiple TextureSources, such as with a multi-atlas, this
             * method will always return zero or -1.
             * @param source The TextureSource to check.
             */
            getTextureSourceIndex(source: Phaser.Textures.TextureSource): integer;

            /**
             * Returns an array of all the Frames in the given TextureSource.
             * @param sourceIndex The index of the TextureSource to get the Frames from.
             */
            getFramesFromTextureSource(sourceIndex: integer): Phaser.Textures.Frame[];

            /**
             * Returns an array with all of the names of the Frames in this Texture.
             * 
             * Useful if you want to randomly assign a Frame to a Game Object, as you can
             * pick a random element from the returned array.
             * @param includeBase Include the `__BASE` Frame in the output array? Default false.
             */
            getFrameNames(includeBase?: boolean): string[];

            /**
             * Given a Frame name, return the source image it uses to render with.
             * 
             * This will return the actual DOM Image or Canvas element.
             * @param name The string-based name, or integer based index, of the Frame to get from this Texture.
             */
            getSourceImage(name?: string | integer): HTMLImageElement | HTMLCanvasElement;

            /**
             * Adds a data source image to this Texture.
             * 
             * An example of a data source image would be a normal map, where all of the Frames for this Texture
             * equally apply to the normal map.
             * @param data The source image.
             */
            setDataSource(data: HTMLImageElement | HTMLCanvasElement): void;

            /**
             * Sets the Filter Mode for this Texture.
             * 
             * The mode can be either Linear, the default, or Nearest.
             * 
             * For pixel-art you should use Nearest.
             * 
             * The mode applies to the entire Texture, not just a specific Frame of it.
             * @param filterMode The Filter Mode.
             */
            setFilter(filterMode: Phaser.Textures.FilterMode): void;

            /**
             * Destroys this Texture and releases references to its sources and frames.
             */
            destroy(): void;

        }

        /**
         * Textures are managed by the global TextureManager. This is a singleton class that is
         * 
         * responsible for creating and delivering Textures and their corresponding Frames to Game Objects.
         * 
         * 
         * 
         * Sprites and other Game Objects get the texture data they need from the TextureManager.
         * 
         * 
         * 
         * Access it via `scene.textures`.
         */
        class TextureManager extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param game [description]
             */
            constructor(game: Phaser.Game);

            /**
             * [description]
             */
            game: Phaser.Game;

            /**
             * [description]
             */
            name: string;

            /**
             * [description]
             */
            list: object;

            /**
             * [description]
             */
            boot(): void;

            /**
             * [description]
             */
            updatePending(): void;

            /**
             * Adds a new Texture to the Texture Manager created from the given Base64 encoded data.
             * @param key The unique string-based key of the Texture.
             * @param data The Base64 encoded data.
             */
            addBase64(key: string, data: any): void;

            /**
             * Adds a new Texture to the Texture Manager created from the given Image element.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param dataSource An optional data Image element.
             */
            addImage(key: string, source: HTMLImageElement, dataSource?: HTMLImageElement): Phaser.Textures.Texture;

            /**
             * Creates a new Texture using the given config values.
             * Generated textures consist of a Canvas element to which the texture data is drawn.
             * See the Phaser.Create function for the more direct way to create textures.
             * @param key The unique string-based key of the Texture.
             * @param config [description]
             */
            generate(key: string, config: object): Phaser.Textures.Texture;

            /**
             * Creates a new Texture using a blank Canvas element of the size given.
             * 
             * Canvas elements are automatically pooled and calling this method will
             * extract a free canvas from the CanvasPool, or create one if none are available.
             * @param key The unique string-based key of the Texture.
             * @param width The width of the Canvas element.
             * @param height The height of the Canvas element.
             */
            createCanvas(key: string, width: integer, height: integer): Phaser.Textures.Texture;

            /**
             * Creates a new Texture object from an existing Canvas element and adds
             * it to this Texture Manager.
             * @param key The unique string-based key of the Texture.
             * @param source The Canvas element to form the base of the new Texture.
             */
            addCanvas(key: string, source: HTMLCanvasElement): Phaser.Textures.Texture;

            /**
             * Adds a new Texture Atlas to this Texture Manager.
             * It can accept either JSON Array or JSON Hash formats, as exported by Texture Packer and similar software.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             */
            addAtlas(key: string, source: HTMLImageElement, data: object): Phaser.Textures.Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager.
             * The frame data of the atlas must be stored in an Array within the JSON.
             * This is known as a JSON Array in software such as Texture Packer.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             */
            addAtlasJSONArray(key: string, source: HTMLImageElement, data: object): Phaser.Textures.Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager.
             * The frame data of the atlas must be stored in an Object within the JSON.
             * This is known as a JSON Hash in software such as Texture Packer.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             */
            addAtlasJSONHash(key: string, source: HTMLImageElement, data: object): Phaser.Textures.Texture;

            /**
             * Adds a Unity Texture Atlas to this Texture Manager.
             * The data must be in the form of a Unity YAML file.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas data.
             */
            addUnityAtlas(key: string, source: HTMLImageElement, data: object): Phaser.Textures.Texture;

            /**
             * Adds a Sprite Sheet to this Texture Manager.
             * 
             * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact
             * same size and cannot be trimmed or rotated.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param config The configuration object for this Sprite Sheet.
             */
            addSpriteSheet(key: string, source: HTMLImageElement, config: SpriteSheetConfig): Phaser.Textures.Texture;

            /**
             * Adds a Sprite Sheet to this Texture Manager, where the Sprite Sheet exists as a Frame within a Texture Atlas.
             * 
             * In Phaser terminology a Sprite Sheet is a texture containing different frames, but each frame is the exact
             * same size and cannot be trimmed or rotated.
             * @param key The unique string-based key of the Texture.
             * @param config The configuration object for this Sprite Sheet.
             */
            addSpriteSheetFromAtlas(key: string, config: SpriteSheetFromAtlasConfig): Phaser.Textures.Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager, where the atlas data is given
             * in the Starling XML format.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas XML data.
             */
            addAtlasStarlingXML(key: string, source: HTMLImageElement, data: object): Phaser.Textures.Texture;

            /**
             * Adds a Texture Atlas to this Texture Manager, where the atlas data is given
             * in the Pyxel JSON format.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param data The Texture Atlas XML data.
             */
            addAtlasPyxel(key: string, source: HTMLImageElement, data: object): Phaser.Textures.Texture;

            /**
             * Creates a new Texture using the given source and dimensions.
             * @param key The unique string-based key of the Texture.
             * @param source The source Image element.
             * @param width The width of the Texture.
             * @param height The height of the Texture.
             */
            create(key: string, source: HTMLImageElement, width: integer, height: integer): Phaser.Textures.Texture;

            /**
             * Checks the given key to see if a Texture using it exists within this Texture Manager.
             * @param key The unique string-based key of the Texture.
             */
            exists(key: string): boolean;

            /**
             * Returns a Texture from the Texture Manager that matches the given key.
             * If the key is undefined it will return the `__DEFAULT` Texture.
             * If the key is given, but not found, it will return the `__MISSING` Texture.
             * @param key The unique string-based key of the Texture.
             */
            get(key: string): Phaser.Textures.Texture;

            /**
             * Takes a Texture key and Frame name and returns a clone of that Frame if found.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame to be cloned.
             */
            cloneFrame(key: string, frame: string | integer): Phaser.Textures.Frame;

            /**
             * Takes a Texture key and Frame name and returns a reference to that Frame, if found.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame.
             */
            getFrame(key: string, frame: string | integer): Phaser.Textures.Frame;

            /**
             * Returns an array with all of the keys of all Textures in this Texture Manager.
             * The output array will exclude the `__DEFAULT` and `__MISSING` keys.
             */
            getTextureKeys(): string[];

            /**
             * Given a Texture and an `x` and `y` coordinate this method will return a new
             * Color object that has been populated with the color and alpha values of the pixel
             * at that location in the Texture.
             * @param x The x coordinate of the pixel within the Texture.
             * @param y The y coordinate of the pixel within the Texture.
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame.
             */
            getPixel(x: integer, y: integer, key: string, frame: string | integer): Phaser.Display.Color;

            /**
             * Sets the given Game Objects `texture` and `frame` properties so that it uses
             * the Texture and Frame specified in the `key` and `frame` arguments to this method.
             * @param gameObject [description]
             * @param key The unique string-based key of the Texture.
             * @param frame The string or index of the Frame.
             */
            setTexture(gameObject: Phaser.GameObjects.GameObject, key: string, frame: string | integer): Phaser.GameObjects.GameObject;

            /**
             * Passes all Textures to the given callback.
             * @param callback The callback function to be sent the Textures.
             * @param scope The value to use as `this` when executing the callback.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            each(callback: EachTextureCallback, scope: object, ...args: any[]): void;

            /**
             * Destroys the Texture Manager and all Textures stored within it.
             */
            destroy(): void;

        }

        /**
         * A Texture Source is the encapsulation of the actual source data for a Texture.
         * 
         * This is typically an Image Element, loaded from the file system or network, or a Canvas Element.
         * 
         * 
         * 
         * A Texture can contain multiple Texture Sources, which only happens when a multi-atlas is loaded.
         */
        class TextureSource {
            /**
             * 
             * @param texture The Texture this TextureSource belongs to.
             * @param source The source image data.
             * @param width Optional width of the source image. If not given it's derived from the source itself.
             * @param height Optional height of the source image. If not given it's derived from the source itself.
             */
            constructor(texture: Phaser.Textures.Texture, source: HTMLImageElement | HTMLCanvasElement, width?: integer, height?: integer);

            /**
             * The Texture this TextureSource belongs to.
             */
            texture: string;

            /**
             * The source image data. This is either an Image Element, or a Canvas Element.
             */
            image: HTMLImageElement | HTMLCanvasElement;

            /**
             * Currently un-used.
             */
            compressionAlgorithm: integer;

            /**
             * The resolution of the source image.
             */
            resolution: number;

            /**
             * The width of the source image. If not specified in the constructor it will check
             * the `naturalWidth` and then `width` properties of the source image.
             */
            width: integer;

            /**
             * The height of the source image. If not specified in the constructor it will check
             * the `naturalHeight` and then `height` properties of the source image.
             */
            height: integer;

            /**
             * The Scale Mode the image will use when rendering.
             * Either Linear or Nearest.
             */
            scaleMode: number;

            /**
             * Is the source image a Canvas Element?
             */
            isCanvas: boolean;

            /**
             * Are the source image dimensions a power of two?
             */
            isPowerOf2: boolean;

            /**
             * The WebGL Texture of the source image.
             */
            glTexture: WebGLTexture;

            /**
             * Creates a WebGL Texture, if required, and sets the Texture filter mode.
             * @param game A reference to the Phaser Game instance.
             */
            init(game: Phaser.Game): void;

            /**
             * Sets the Filter Mode for this Texture.
             * 
             * The mode can be either Linear, the default, or Nearest.
             * 
             * For pixel-art you should use Nearest.
             * @param filterMode The Filter Mode.
             */
            setFilter(filterMode: Phaser.Textures.FilterMode): void;

            /**
             * Destroys this Texture Source and nulls the source image reference.
             */
            destroy(): void;

        }

    }

    namespace Tilemaps {
        namespace Components {
        }

        /**
         * A DynamicTilemapLayer is a game object that renders LayerData from a Tilemap. A
         * 
         * DynamicTilemapLayer can only render tiles from a single tileset.
         * 
         * 
         * 
         * A DynamicTilemapLayer trades some speed for being able to apply powerful effects. Unlike a
         * 
         * StaticTilemapLayer, you can apply per-tile effects like tint or alpha, and you can change the
         * 
         * tiles in a DynamicTilemapLayer. Use this over a StaticTilemapLayer when you need those
         * 
         * features.
         */
        class DynamicTilemapLayer extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.ScrollFactor, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param scene [description]
             * @param tilemap The Tilemap this layer is a part of.
             * @param layerIndex The index of the LayerData associated with this layer.
             * @param tileset The tileset used to render the tiles in this layer.
             * @param x The world x position where the top left of this layer will be placed. Default 0.
             * @param y The world y position where the top left of this layer will be placed. Default 0.
             */
            constructor(scene: Phaser.Scene, tilemap: Phaser.Tilemaps.Tilemap, layerIndex: integer, tileset: Phaser.Tilemaps.Tileset, x?: number, y?: number);

            /**
             * Used internally by physics system to perform fast type checks.
             */
            isTilemap: boolean;

            /**
             * The Tilemap that this layer is a part of.
             */
            tilemap: Phaser.Tilemaps.Tilemap;

            /**
             * The index of the LayerData associated with this layer.
             */
            layerIndex: integer;

            /**
             * The LayerData associated with this layer. LayerData can only be associated with one
             * tilemap layer.
             */
            layer: Phaser.Tilemaps.LayerData;

            /**
             * The Tileset associated with this layer. A tilemap layer can only render from one Tileset.
             */
            tileset: Phaser.Tilemaps.Tileset;

            /**
             * Used internally with the canvas render. This holds the tiles that are visible within the
             * camera.
             */
            culledTiles: any[];

            /**
             * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
             * faces are used internally for optimizing collisions against tiles. This method is mostly used
             * internally to optimize recalculating faces when only one tile has been changed.
             * @param tileX The x coordinate.
             * @param tileY The y coordinate.
             */
            calculateFacesAt(tileX: integer, tileY: integer): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
             * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
             * is mostly used internally.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             */
            calculateFacesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Creates a Sprite for every object matching the given tile indexes in the layer. You can
             * optionally specify if each tile will be replaced with a new tile after the Sprite has been
             * created. This is useful if you want to lay down special tiles in a level that are converted to
             * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
             * @param indexes The tile index, or array of indexes, to create Sprites from.
             * @param replacements The tile index, or array of indexes, to change a converted
             * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
             * one-to-one mapping with the indexes array.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default scene the map is within.
             * @param camera The Camera to use when determining the world XY Default main camera.
             */
            createFromTiles(indexes: integer | any[], replacements: integer | any[], spriteConfig: object, scene?: Phaser.Scene, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.GameObjects.Sprite[];

            /**
             * Returns the tiles in the given layer that are within the cameras viewport.
             * This is used internally.
             * @param camera The Camera to run the cull check against.
             */
            cull(camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile[];

            /**
             * Copies the tiles in the source rectangular area to a new destination (all specified in tile
             * coordinates) within the layer. This copies all tile properties & recalculates collision
             * information in the destination region.
             * @param srcTileX [description]
             * @param srcTileY [description]
             * @param width [description]
             * @param height [description]
             * @param destTileX [description]
             * @param destTileY [description]
             * @param recalculateFaces [description] Default true.
             */
            copy(srcTileX: integer, srcTileY: integer, width: integer, height: integer, destTileX: integer, destTileY: integer, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Destroys this DynamicTilemapLayer and removes its link to the associated LayerData.
             */
            destroy(): void;

            /**
             * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the
             * specified index. Tiles will be set to collide if the given index is a colliding index.
             * Collision information in the region will be recalculated.
             * @param index [description]
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param recalculateFaces [description] Default true.
             */
            fill(index: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
             * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter. The callback should return true for tiles that pass the
             * filter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            filterTiles(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.Tile[];

            /**
             * Searches the entire map layer for the first tile matching the given index, then returns that Tile
             * object. If no match is found, it returns null. The search starts from the top-left tile and
             * continues horizontally until it hits the end of the row, then it drops down to the next column.
             * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
             * the top-left.
             * @param index The tile index value to search for.
             * @param skip The number of times to skip a matching tile before returning. Default 0.
             * @param reverse If true it will scan the layer in reverse, starting at the
             * bottom-right. Otherwise it scans from the top-left. Default false.
             */
            findByIndex(index: integer, skip?: integer, reverse?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
             * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
             * true. Similar to Array.prototype.find in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            findTile(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.Tile;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * callback. Similar to Array.prototype.forEach in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            forEachTile(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Gets a tile at the given tile coordinates from the given layer.
             * @param tileX X position to get the tile from (given in tile units, not pixels).
             * @param tileY Y position to get the tile from (given in tile units, not pixels).
             * @param nonNull If true getTile won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             */
            getTileAt(tileX: integer, tileY: integer, nonNull?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Gets a tile at the given world coordinates from the given layer.
             * @param worldX X position to get the tile from (given in pixels)
             * @param worldY Y position to get the tile from (given in pixels)
             * @param nonNull If true, function won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             * @param camera [description] Default main camera.
             */
            getTileAtWorldXY(worldX: number, worldY: number, nonNull?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile;

            /**
             * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            getTilesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.Tile[];

            /**
             * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
             * Line, Rectangle or Triangle. The shape should be in world coordinates.
             * @param shape A shape in world (pixel) coordinates
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param camera [description] Default main camera.
             */
            getTilesWithinShape(shape: Phaser.Geom.Circle | Phaser.Geom.Line | Phaser.Geom.Rectangle | Phaser.Geom.Triangle, filteringOptions?: object, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile[];

            /**
             * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
             * @param worldX [description]
             * @param worldY [description]
             * @param width [description]
             * @param height [description]
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param camera [description] Default main camera.
             */
            getTilesWithinWorldXY(worldX: number, worldY: number, width: number, height: number, filteringOptions?: object, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile[];

            /**
             * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param tileX [description]
             * @param tileY [description]
             */
            hasTileAt(tileX: integer, tileY: integer): boolean;

            /**
             * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param worldX [description]
             * @param worldY [description]
             * @param camera [description] Default main camera.
             */
            hasTileAtWorldXY(worldX: number, worldY: number, camera?: Phaser.Cameras.Scene2D.Camera): boolean;

            /**
             * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index
             * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified
             * location. If you pass in an index, only the index at the specified location will be changed.
             * Collision information will be recalculated at the specified location.
             * @param tile The index of this tile to set or a Tile object.
             * @param tileX [description]
             * @param tileY [description]
             * @param recalculateFaces [description] Default true.
             */
            putTileAt(tile: integer | Phaser.Tilemaps.Tile, tileX: integer, tileY: integer, recalculateFaces?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either
             * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the
             * specified location. If you pass in an index, only the index at the specified location will be
             * changed. Collision information will be recalculated at the specified location.
             * @param tile The index of this tile to set or a Tile object.
             * @param worldX [description]
             * @param worldY [description]
             * @param recalculateFaces [description] Default true.
             * @param camera [description]
             */
            putTileAtWorldXY(tile: integer | Phaser.Tilemaps.Tile, worldX: integer, worldY: integer, recalculateFaces?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile;

            /**
             * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified
             * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,
             * all attributes will be copied over to the specified location. If you pass in an index, only the
             * index at the specified location will be changed. Collision information will be recalculated
             * within the region tiles were changed.
             * @param tile A row (array) or grid (2D array) of Tiles
             * or tile indexes to place.
             * @param tileX [description]
             * @param tileY [description]
             * @param recalculateFaces [description] Default true.
             */
            putTilesAt(tile: integer[] | integer[][] | Phaser.Tilemaps.Tile[] | Phaser.Tilemaps.Tile[][], tileX: integer, tileY: integer, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will receive a new index. If an array of indexes is passed in, then
             * those will be used for randomly assigning new tile indexes. If an array is not provided, the
             * indexes found within the region (excluding -1) will be used for randomly assigning new tile
             * indexes. This method only modifies tile indexes and does not change collision information.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param indexes An array of indexes to randomly draw from during randomization.
             */
            randomize(tileX?: integer, tileY?: integer, width?: integer, height?: integer, indexes?: integer[]): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Removes the tile at the given tile coordinates in the specified layer and updates the layer's
             * collision information.
             * @param tile The index of this tile to set or a Tile object.
             * @param tileX [description]
             * @param tileY [description]
             * @param replaceWithNull If true, this will replace the tile at the specified
             * location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces [description] Default true.
             */
            removeTileAt(tile: integer | Phaser.Tilemaps.Tile, tileX: integer, tileY: integer, replaceWithNull?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Removes the tile at the given world coordinates in the specified layer and updates the layer's
             * collision information.
             * @param tile The index of this tile to set or a Tile object.
             * @param worldX [description]
             * @param worldY [description]
             * @param replaceWithNull If true, this will replace the tile at the specified
             * location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces [description] Default true.
             * @param camera [description] Default main camera.
             */
            removeTileAtWorldXY(tile: integer | Phaser.Tilemaps.Tile, worldX: number, worldY: number, replaceWithNull?: boolean, recalculateFaces?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile;

            /**
             * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
             * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
             * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
             * wherever you want on the screen.
             * @param graphics The target Graphics object to draw upon.
             * @param styleConfig An object specifying the colors to use for the debug drawing.
             * @param styleConfig.tileColor Color to use for drawing a filled rectangle at
             * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn. Default blue.
             * @param styleConfig.collidingTileColor Color to use for drawing a filled
             * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn. Default orange.
             * @param styleConfig.faceColor Color to use for drawing a line at interesting
             * tile faces. If set to null, interesting tile faces will not be drawn. Default grey.
             */
            renderDebug(graphics: Phaser.GameObjects.Graphics, styleConfig: object): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does
             * not change collision information.
             * @param findIndex [description]
             * @param newIndex [description]
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             */
            replaceByIndex(findIndex: integer, newIndex: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
             * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
             * collision will be enabled (true) or disabled (false).
             * @param indexes Either a single tile index, or an array of tile indexes.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollision(indexes: integer | any[], collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
             * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
             * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
             * enabled (true) or disabled (false).
             * @param start The first index of the tile to be set for collision.
             * @param stop The last index of the tile to be set for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionBetween(start: integer, stop: integer, collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
             * that matches the given properties object, its collision flag will be set. The `collides`
             * parameter controls if collision will be enabled (true) or disabled (false). Passing in
             * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
             * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
             * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
             * "types" property that matches any of those values, its collision flag will be updated.
             * @param properties An object with tile properties and corresponding values that should
             * be checked.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionByProperty(properties: object, collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
             * the given array. The `collides` parameter controls if collision will be enabled (true) or
             * disabled (false).
             * @param indexes An array of the tile indexes to not be counted for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionByExclusion(indexes: integer[], collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking each tiles collision group data
             * (typically defined in Tiled within the tileset collision editor). If any objects are found within
             * a tiles collision group, the tile's colliding information will be set. The `collides` parameter
             * controls if collision will be enabled (true) or disabled (false).
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionFromCollisionGroup(collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets a global collision callback for the given tile index within the layer. This will affect all
             * tiles on this layer that have the same index. If a callback is already set for the tile index it
             * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
             * at a specific location on the map then see setTileLocationCallback.
             * @param indexes Either a single tile index, or an array of tile indexes to have a
             * collision callback set for.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileIndexCallback(indexes: integer | any[], callback: Function, callbackContext: object): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
             * If a callback is already set for the tile index it will be replaced. Set the callback to null to
             * remove it.
             * @param tileX [description]
             * @param tileY [description]
             * @param width [description]
             * @param height [description]
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileLocationCallback(tileX: integer, tileY: integer, width: integer, height: integer, callback: Function, callbackContext?: object): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given
             * layer. It will only randomize the tiles in that area, so if they're all the same nothing will
             * appear to have changed! This method only modifies tile indexes and does not change collision
             * information.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             */
            shuffle(tileX?: integer, tileY?: integer, width?: integer, height?: integer): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision
             * information.
             * @param tileA First tile index.
             * @param tileB Second tile index.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             */
            swapByIndex(tileA: integer, tileB: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileX [description]
             * @param camera [description] Default main camera.
             */
            tileToWorldX(tileX: integer, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileY [description]
             * @param camera [description] Default main camera.
             */
            tileToWorldY(tileY: integer, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param tileX [description]
             * @param tileY [description]
             * @param point [description]
             * @param camera [description] Default main camera.
             */
            tileToWorldXY(tileX: integer, tileY: integer, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will recieve a new index. New indexes are drawn from the given
             * weightedIndexes array. An example weighted array:
             * 
             * [
             *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8
             *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8
             *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8
             *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8
             * ]
             * 
             * The probability of any index being choose is (the index's weight) / (sum of all weights). This
             * method only modifies tile indexes and does not change collision information.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param weightedIndexes An array of objects to randomly draw from during
             * randomization. They should be in the form: { index: 0, weight: 4 } or
             * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.
             */
            weightedRandomize(tileX?: integer, tileY?: integer, width?: integer, height?: integer, weightedIndexes?: object[]): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldX [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera [description] Default main camera.
             */
            worldToTileX(worldX: number, snapToFloor?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldY [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera [description] Default main camera.
             */
            worldToTileY(worldY: number, snapToFloor?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param worldX [description]
             * @param worldY [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param point [description]
             * @param camera [description] Default main camera.
             */
            worldToTileXY(worldX: number, worldY: number, snapToFloor?: boolean, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        namespace Formats {
            /**
             * CSV Map Type
             */
            var CSV: number;

            /**
             * Tiled JSON Map Type
             */
            var TILED_JSON: number;

            /**
             * 2D Array Map Type
             */
            var ARRAY_2D: number;

            /**
             * Weltmeister (Impact.js) Map Type
             */
            var WELTMEISTER: number;

        }

        /**
         * An Image Collection is a special Tile Set containing multiple images, with no slicing into each image.
         * 
         * 
         * 
         * Image Collections are normally created automatically when Tiled data is loaded.
         */
        class ImageCollection {
            /**
             * 
             * @param name The name of the image collection in the map data.
             * @param firstgid The first image index this image collection contains.
             * @param width Width of widest image (in pixels). Default 32.
             * @param height Height of tallest image (in pixels). Default 32.
             * @param margin The margin around all images in the collection (in pixels). Default 0.
             * @param spacing The spacing between each image in the collection (in pixels). Default 0.
             * @param properties Custom Image Collection properties. Default {}.
             */
            constructor(name: string, firstgid: integer, width?: integer, height?: integer, margin?: integer, spacing?: integer, properties?: object);

            /**
             * The name of the Image Collection.
             */
            name: string;

            /**
             * The Tiled firstgid value.
             * This is the starting index of the first image index this Image Collection contains.
             */
            firstgid: integer;

            /**
             * The width of the widest image (in pixels).
             */
            imageWidth: integer;

            /**
             * The height of the tallest image (in pixels).
             */
            imageHeight: integer;

            /**
             * The margin around the images in the collection (in pixels).
             * Use `setSpacing` to change.
             */
            imageMarge: integer;

            /**
             * The spacing between each image in the collection (in pixels).
             * Use `setSpacing` to change.
             */
            imageSpacing: integer;

            /**
             * Image Collection-specific properties that are typically defined in the Tiled editor.
             */
            properties: object;

            /**
             * The cached images that are a part of this collection.
             */
            images: any[];

            /**
             * The total number of images in the image collection.
             */
            total: integer;

            /**
             * Returns true if and only if this image collection contains the given image index.
             * @param imageIndex The image index to search for.
             */
            containsImageIndex(imageIndex: integer): boolean;

            /**
             * Add an image to this Image Collection.
             * @param gid The gid of the image in the Image Collection.
             * @param image The the key of the image in the Image Collection and in the cache.
             */
            addImage(gid: integer, image: string): Phaser.Tilemaps.ImageCollection;

        }

        /**
         * A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,
         * 
         * etc. into this format. Tilemap, StaticTilemapLayer and DynamicTilemapLayer have a reference
         * 
         * to this data and use it to look up and perform operations on tiles.
         */
        class LayerData {
            /**
             * 
             * @param config [description]
             */
            constructor(config?: object);

            /**
             * [description]
             */
            name: string;

            /**
             * [description]
             */
            x: number;

            /**
             * [description]
             */
            y: number;

            /**
             * [description]
             */
            width: number;

            /**
             * [description]
             */
            height: number;

            /**
             * [description]
             */
            tileWidth: number;

            /**
             * [description]
             */
            tileHeight: number;

            /**
             * [description]
             */
            baseTileWidth: number;

            /**
             * [description]
             */
            baseTileHeight: number;

            /**
             * [description]
             */
            widthInPixels: number;

            /**
             * [description]
             */
            heightInPixels: number;

            /**
             * [description]
             */
            alpha: number;

            /**
             * [description]
             */
            visible: boolean;

            /**
             * [description]
             */
            properties: object;

            /**
             * [description]
             */
            indexes: any[];

            /**
             * [description]
             */
            collideIndexes: any[];

            /**
             * [description]
             */
            callbacks: any[];

            /**
             * [description]
             */
            bodies: any[];

            /**
             * [description]
             */
            data: any[];

            /**
             * [description]
             */
            tilemapLayer: Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer;

        }

        /**
         * A class for representing data about a map. Maps are parsed from CSV, Tiled, etc. into this
         * 
         * format. A Tilemap object get a copy of this data and then unpacks the needed properties into
         * 
         * itself.
         */
        class MapData {
            /**
             * 
             * @param config [description]
             */
            constructor(config?: object);

            /**
             * [description]
             */
            name: string;

            /**
             * [description]
             */
            width: number;

            /**
             * [description]
             */
            height: number;

            /**
             * [description]
             */
            tileWidth: number;

            /**
             * [description]
             */
            tileHeight: number;

            /**
             * [description]
             */
            widthInPixels: number;

            /**
             * [description]
             */
            heightInPixels: number;

            /**
             * [description]
             */
            format: integer;

            /**
             * [description]
             */
            orientation: string;

            /**
             * [description]
             */
            version: string;

            /**
             * [description]
             */
            properties: object;

            /**
             * [description]
             */
            layers: any[];

            /**
             * [description]
             */
            images: any[];

            /**
             * [description]
             */
            objects: object;

            /**
             * [description]
             */
            collision: object;

            /**
             * [description]
             */
            tilesets: any[];

            /**
             * [description]
             */
            imageCollections: any[];

            /**
             * [description]
             */
            tiles: any[];

        }

        /**
         * A class for representing a Tiled object layer in a map. This mirrors the structure of a Tiled
         * 
         * object layer, except:
         * 
         *  - "x" & "y" properties are ignored since these cannot be changed in Tiled.
         * 
         *  - "offsetx" & "offsety" are applied to the individual object coordinates directly, so they
         * 
         *    are ignored as well.
         * 
         *  - "draworder" is ignored.
         */
        class ObjectLayer {
            /**
             * 
             * @param config [description]
             */
            constructor(config?: object);

            /**
             * [description]
             */
            name: string;

            /**
             * [description]
             */
            opacity: number;

            /**
             * [description]
             */
            properties: object;

            /**
             * [description]
             */
            propertyTypes: object;

            /**
             * [description]
             */
            type: string;

            /**
             * [description]
             */
            visible: boolean;

            /**
             * [description]
             */
            objects: Phaser.GameObjects.GameObject[];

        }

        namespace Parsers {
            namespace Impact {
                /**
                 * [description]
                 * @param json [description]
                 * @param insertNull [description]
                 */
                function ParseTileLayers(json: object, insertNull: boolean): any[];

                /**
                 * [description]
                 * @param json [description]
                 */
                function ParseTilesets(json: object): any[];

                /**
                 * Parses a Weltmeister JSON object into a new MapData object.
                 * @param name The name of the tilemap, used to set the name on the MapData.
                 * @param json The Weltmeister JSON object.
                 * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
                 * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
                 * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
                 * the tile data doesn't need to change then setting this value to `true` will help with memory
                 * consumption. However if your map is small or you need to update the tiles dynamically, then leave
                 * the default value set.
                 */
                function ParseWeltmeister(name: string, json: object, insertNull: boolean): object;

            }

            /**
             * Parses raw data of a given Tilemap format into a new MapData object. If no recognized data format
             * is found, returns `null`. When loading from CSV or a 2D array, you should specify the tileWidth &
             * tileHeight. When parsing from a map from Tiled, the tileWidth & tileHeight will be pulled from
             * the map data.
             * @param name The name of the tilemap, used to set the name on the MapData.
             * @param mapFormat See ../Formats.js.
             * @param data 2D array, CSV string or Tiled JSON object.
             * @param tileWidth The width of a tile in pixels. Required for 2D array and CSV, but
             * ignored for Tiled JSON.
             * @param tileHeight The height of a tile in pixels. Required for 2D array and CSV, but
             * ignored for Tiled JSON.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
             * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set.
             */
            function Parse(name: string, mapFormat: integer, data: integer[][] | string | object, tileWidth: integer, tileHeight: integer, insertNull: boolean): Phaser.Tilemaps.MapData;

            /**
             * Parses a 2D array of tile indexes into a new MapData object with a single layer.
             * @param name The name of the tilemap, used to set the name on the MapData.
             * @param data 2D array, CSV string or Tiled JSON object.
             * @param tileWidth The width of a tile in pixels.
             * @param tileHeight The height of a tile in pixels.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
             * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set.
             */
            function Parse2DArray(name: string, data: integer[][], tileWidth: integer, tileHeight: integer, insertNull: boolean): Phaser.Tilemaps.MapData;

            /**
             * Parses a CSV string of tile indexes into a new MapData object with a single layer.
             * @param name The name of the tilemap, used to set the name on the MapData.
             * @param data CSV string of tile indexes.
             * @param tileWidth The width of a tile in pixels.
             * @param tileHeight The height of a tile in pixels.
             * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
             * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
             * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
             * the tile data doesn't need to change then setting this value to `true` will help with memory
             * consumption. However if your map is small or you need to update the tiles dynamically, then leave
             * the default value set.
             */
            function ParseCSV(name: string, data: string, tileWidth: integer, tileHeight: integer, insertNull: boolean): Phaser.Tilemaps.MapData;

            namespace Tiled {
                /**
                 * Copy properties from tileset to tiles.
                 * @param mapData [description]
                 */
                function AssignTileProperties(mapData: Phaser.Tilemaps.MapData): void;

                /**
                 * [description]
                 * @param data [description]
                 */
                function Base64Decode(data: object): any[];

                /**
                 * Master list of tiles -> x, y, index in tileset.
                 * @param mapData [description]
                 */
                function BuildTilesetIndex(mapData: Phaser.Tilemaps.MapData): any[];

                /**
                 * See Tiled documentation on tile flipping:
                 * http://docs.mapeditor.org/en/latest/reference/tmx-map-format/
                 * @param gid [description]
                 */
                function ParseGID(gid: number): object;

                /**
                 * [description]
                 * @param json [description]
                 */
                function ParseImageLayers(json: object): any[];

                /**
                 * Parses a Tiled JSON object into a new MapData object.
                 * @param name The name of the tilemap, used to set the name on the MapData.
                 * @param json The Tiled JSON object.
                 * @param insertNull Controls how empty tiles, tiles with an index of -1, in the map
                 * data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
                 * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
                 * the tile data doesn't need to change then setting this value to `true` will help with memory
                 * consumption. However if your map is small or you need to update the tiles dynamically, then leave
                 * the default value set.
                 */
                function ParseJSONTiled(name: string, json: object, insertNull: boolean): Phaser.Tilemaps.MapData;

                /**
                 * [description]
                 * @param tiledObject [description]
                 * @param offsetX [description] Default 0.
                 * @param offsetY [description] Default 0.
                 */
                function ParseObject(tiledObject: object, offsetX?: number, offsetY?: number): object;

                /**
                 * [description]
                 * @param json [description]
                 */
                function ParseObjectLayers(json: object): any[];

                /**
                 * [description]
                 * @param json [description]
                 * @param insertNull [description]
                 */
                function ParseTileLayers(json: object, insertNull: boolean): any[];

                /**
                 * Tilesets & Image Collections
                 * @param json [description]
                 */
                function ParseTilesets(json: object): object;

                /**
                 * [description]
                 * @param object [description]
                 * @param keys [description]
                 */
                function Pick(object: object, keys: any[]): object;

            }

        }

        /**
         * Create a Tilemap from the given key or data. If neither is given, make a blank Tilemap. When
         * loading from CSV or a 2D array, you should specify the tileWidth & tileHeight. When parsing from
         * a map from Tiled, the tileWidth, tileHeight, width & height will be pulled from the map data. For
         * an empty map, you should specify tileWidth, tileHeight, width & height.
         * @param scene The Scene to which this Tilemap belongs.
         * @param key The key in the Phaser cache that corresponds to the loaded tilemap data.
         * @param tileWidth The width of a tile in pixels. Default 32.
         * @param tileHeight The height of a tile in pixels. Default 32.
         * @param width The width of the map in tiles. Default 10.
         * @param height The height of the map in tiles. Default 10.
         * @param data Instead of loading from the cache, you can also load directly from
         * a 2D array of tile indexes.
         * @param insertNull Controls how empty tiles, tiles with an index of -1, in the
         * map data are handled. If `true`, empty locations will get a value of `null`. If `false`, empty
         * location will get a Tile object with an index of -1. If you've a large sparsely populated map and
         * the tile data doesn't need to change then setting this value to `true` will help with memory
         * consumption. However if your map is small or you need to update the tiles dynamically, then leave
         * the default value set. Default false.
         */
        function ParseToTilemap(scene: Phaser.Scene, key?: string, tileWidth?: integer, tileHeight?: integer, width?: integer, height?: integer, data?: integer[][], insertNull?: boolean): Phaser.Tilemaps.Tilemap;

        /**
         * A StaticTilemapLayer is a game object that renders LayerData from a Tilemap. A
         * 
         * StaticTilemapLayer can only render tiles from a single tileset.
         * 
         * 
         * 
         * A StaticTilemapLayer is optimized for speed over flexibility. You cannot apply per-tile
         * 
         * effects like tint or alpha. You cannot change the tiles in a StaticTilemapLayer. Use this
         * 
         * over a DynamicTilemapLayer when you don't need either of those features.
         */
        class StaticTilemapLayer extends Phaser.GameObjects.GameObject implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.BlendMode, Phaser.GameObjects.Components.ComputedSize, Phaser.GameObjects.Components.Depth, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.GetBounds, Phaser.GameObjects.Components.Origin, Phaser.GameObjects.Components.Pipeline, Phaser.GameObjects.Components.ScaleMode, Phaser.GameObjects.Components.Transform, Phaser.GameObjects.Components.Visible, Phaser.GameObjects.Components.ScrollFactor {
            /**
             * 
             * @param scene [description]
             * @param tilemap The Tilemap this layer is a part of.
             * @param layerIndex The index of the LayerData associated with this layer.
             * @param tileset The tileset used to render the tiles in this layer.
             * @param x The world x position where the top left of this layer will be placed. Default 0.
             * @param y The world y position where the top left of this layer will be placed. Default 0.
             */
            constructor(scene: Phaser.Scene, tilemap: Phaser.Tilemaps.Tilemap, layerIndex: integer, tileset: Phaser.Tilemaps.Tileset, x?: number, y?: number);

            /**
             * Used internally by physics system to perform fast type checks.
             */
            isTilemap: boolean;

            /**
             * The Tilemap that this layer is a part of.
             */
            tilemap: Phaser.Tilemaps.Tilemap;

            /**
             * The index of the LayerData associated with this layer.
             */
            layerIndex: integer;

            /**
             * The LayerData associated with this layer. LayerData can only be associated with one
             * tilemap layer.
             */
            layer: Phaser.Tilemaps.LayerData;

            /**
             * The Tileset associated with this layer. A tilemap layer can only render from one Tileset.
             */
            tileset: Phaser.Tilemaps.Tileset;

            /**
             * Used internally with the canvas render. This holds the tiles that are visible within the
             * camera.
             */
            culledTiles: any[];

            /**
             * Upload the tile data to a VBO.
             * @param camera The camera to render to.
             */
            upload(camera: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
             * faces are used internally for optimizing collisions against tiles. This method is mostly used
             * internally to optimize recalculating faces when only one tile has been changed.
             * @param tileX The x coordinate.
             * @param tileY The y coordinate.
             */
            calculateFacesAt(tileX: integer, tileY: integer): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
             * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
             * is mostly used internally.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             */
            calculateFacesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Creates a Sprite for every object matching the given tile indexes in the layer. You can
             * optionally specify if each tile will be replaced with a new tile after the Sprite has been
             * created. This is useful if you want to lay down special tiles in a level that are converted to
             * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
             * @param indexes The tile index, or array of indexes, to create Sprites from.
             * @param replacements The tile index, or array of indexes, to change a converted
             * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
             * one-to-one mapping with the indexes array.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default scene the map is within.
             * @param camera The Camera to use when determining the world XY Default main camera.
             */
            createFromTiles(indexes: integer | any[], replacements: integer | any[], spriteConfig: object, scene?: Phaser.Scene, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.GameObjects.Sprite[];

            /**
             * Returns the tiles in the given layer that are within the cameras viewport.
             * This is used internally.
             * @param camera The Camera to run the cull check against.
             */
            cull(camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile[];

            /**
             * Destroys this StaticTilemapLayer and removes its link to the associated LayerData.
             */
            destroy(): void;

            /**
             * Searches the entire map layer for the first tile matching the given index, then returns that Tile
             * object. If no match is found, it returns null. The search starts from the top-left tile and
             * continues horizontally until it hits the end of the row, then it drops down to the next column.
             * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
             * the top-left.
             * @param index The tile index value to search for.
             * @param skip The number of times to skip a matching tile before returning. Default 0.
             * @param reverse If true it will scan the layer in reverse, starting at the
             * bottom-right. Otherwise it scans from the top-left. Default false.
             */
            findByIndex(index: integer, skip?: integer, reverse?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
             * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
             * true. Similar to Array.prototype.find in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            findTile(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.Tile;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
             * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter. The callback should return true for tiles that pass the
             * filter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            filterTiles(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.Tile[];

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * callback. Similar to Array.prototype.forEach in vanilla JS.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            forEachTile(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Gets a tile at the given tile coordinates from the given layer.
             * @param tileX X position to get the tile from (given in tile units, not pixels).
             * @param tileY Y position to get the tile from (given in tile units, not pixels).
             * @param nonNull If true getTile won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             */
            getTileAt(tileX: integer, tileY: integer, nonNull?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Gets a tile at the given world coordinates from the given layer.
             * @param worldX X position to get the tile from (given in pixels)
             * @param worldY Y position to get the tile from (given in pixels)
             * @param nonNull If true, function won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             * @param camera [description] Default main camera.
             */
            getTileAtWorldXY(worldX: number, worldY: number, nonNull?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile;

            /**
             * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             */
            getTilesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object): Phaser.Tilemaps.Tile[];

            /**
             * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
             * @param worldX [description]
             * @param worldY [description]
             * @param width [description]
             * @param height [description]
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param camera [description] Default main camera.
             */
            getTilesWithinWorldXY(worldX: number, worldY: number, width: number, height: number, filteringOptions?: object, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile[];

            /**
             * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
             * Line, Rectangle or Triangle. The shape should be in world coordinates.
             * @param shape A shape in world (pixel) coordinates
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param camera [description] Default main camera.
             */
            getTilesWithinShape(shape: Phaser.Geom.Circle | Phaser.Geom.Line | Phaser.Geom.Rectangle | Phaser.Geom.Triangle, filteringOptions?: object, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Tilemaps.Tile[];

            /**
             * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param tileX [description]
             * @param tileY [description]
             */
            hasTileAt(tileX: integer, tileY: integer): boolean;

            /**
             * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * @param worldX [description]
             * @param worldY [description]
             * @param camera [description] Default main camera.
             */
            hasTileAtWorldXY(worldX: number, worldY: number, camera?: Phaser.Cameras.Scene2D.Camera): boolean;

            /**
             * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
             * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
             * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
             * wherever you want on the screen.
             * @param graphics The target Graphics object to draw upon.
             * @param styleConfig An object specifying the colors to use for the debug drawing.
             * @param styleConfig.tileColor Color to use for drawing a filled rectangle at
             * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn. Default blue.
             * @param styleConfig.collidingTileColor Color to use for drawing a filled
             * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn. Default orange.
             * @param styleConfig.faceColor Color to use for drawing a line at interesting
             * tile faces. If set to null, interesting tile faces will not be drawn. Default grey.
             */
            renderDebug(graphics: Phaser.GameObjects.Graphics, styleConfig: object): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
             * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
             * collision will be enabled (true) or disabled (false).
             * @param indexes Either a single tile index, or an array of tile indexes.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollision(indexes: integer | any[], collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
             * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
             * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
             * enabled (true) or disabled (false).
             * @param start The first index of the tile to be set for collision.
             * @param stop The last index of the tile to be set for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionBetween(start: integer, stop: integer, collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
             * that matches the given properties object, its collision flag will be set. The `collides`
             * parameter controls if collision will be enabled (true) or disabled (false). Passing in
             * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
             * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
             * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
             * "types" property that matches any of those values, its collision flag will be updated.
             * @param properties An object with tile properties and corresponding values that should
             * be checked.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionByProperty(properties: object, collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
             * the given array. The `collides` parameter controls if collision will be enabled (true) or
             * disabled (false).
             * @param indexes An array of the tile indexes to not be counted for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionByExclusion(indexes: integer[], collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets a global collision callback for the given tile index within the layer. This will affect all
             * tiles on this layer that have the same index. If a callback is already set for the tile index it
             * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
             * at a specific location on the map then see setTileLocationCallback.
             * @param indexes Either a single tile index, or an array of tile indexes to have a
             * collision callback set for.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileIndexCallback(indexes: integer | any[], callback: Function, callbackContext: object): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets collision on the tiles within a layer by checking each tiles collision group data
             * (typically defined in Tiled within the tileset collision editor). If any objects are found within
             * a tiles collision group, the tile's colliding information will be set. The `collides` parameter
             * controls if collision will be enabled (true) or disabled (false).
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             */
            setCollisionFromCollisionGroup(collides?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Sets a collision callback for the given rectangular area (in tile coordinates) within the layer.
             * If a callback is already set for the tile index it will be replaced. Set the callback to null to
             * remove it.
             * @param tileX [description]
             * @param tileY [description]
             * @param width [description]
             * @param height [description]
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             */
            setTileLocationCallback(tileX: integer, tileY: integer, width: integer, height: integer, callback: Function, callbackContext?: object): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileX [description]
             * @param camera [description] Default main camera.
             */
            tileToWorldX(tileX: integer, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * @param tileY [description]
             * @param camera [description] Default main camera.
             */
            tileToWorldY(tileY: integer, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param tileX [description]
             * @param tileY [description]
             * @param point [description]
             * @param camera [description] Default main camera.
             */
            tileToWorldXY(tileX: integer, tileY: integer, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

            /**
             * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldX [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera [description] Default main camera.
             */
            worldToTileX(worldX: number, snapToFloor?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * @param worldY [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera [description] Default main camera.
             */
            worldToTileY(worldY: number, snapToFloor?: boolean, camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * @param worldX [description]
             * @param worldY [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param point [description]
             * @param camera [description] Default main camera.
             */
            worldToTileXY(worldX: number, worldY: number, snapToFloor?: boolean, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera): Phaser.Math.Vector2;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             */
            blendMode: Phaser.BlendModes | string;

            /**
             * Sets the Blend Mode being used by this Game Object.
             * 
             * This can be a const, such as `Phaser.BlendModes.SCREEN`, or an integer, such as 4 (for Overlay)
             * 
             * Under WebGL only the following Blend Modes are available:
             * 
             * * ADD
             * * MULTIPLY
             * * SCREEN
             * 
             * Canvas has more available depending on browser support.
             * 
             * You can also create your own custom Blend Modes in WebGL.
             * 
             * Blend modes have different effects under Canvas and WebGL, and from browser to browser, depending
             * on support. Blend Modes also cause a WebGL batch flush should it encounter a new blend mode. For these
             * reasons try to be careful about the construction of your Scene and the frequency of which blend modes
             * are used.
             * @param value The BlendMode value. Either a string or a CONST.
             */
            setBlendMode(value: string | Phaser.BlendModes): Phaser.GameObjects.GameObject;

            /**
             * The native (un-scaled) width of this Game Object.
             */
            width: number;

            /**
             * The native (un-scaled) height of this Game Object.
             */
            height: number;

            /**
             * The displayed width of this Game Object.
             * This value takes into account the scale factor.
             */
            displayWidth: number;

            /**
             * The displayed height of this Game Object.
             * This value takes into account the scale factor.
             */
            displayHeight: number;

            /**
             * Sets the size of this Game Object.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setSize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the display size of this Game Object.
             * Calling this will adjust the scale.
             * @param width The width of this Game Object.
             * @param height The height of this Game Object.
             */
            setDisplaySize(width: number, height: number): Phaser.GameObjects.GameObject;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             */
            depth: number;

            /**
             * The depth of this Game Object within the Scene.
             * 
             * The depth is also known as the 'z-index' in some environments, and allows you to change the rendering order
             * of Game Objects, without actually moving their position in the display list.
             * 
             * The depth starts from zero (the default value) and increases from that point. A Game Object with a higher depth
             * value will always render in front of one with a lower value.
             * 
             * Setting the depth will queue a depth sort event within the Scene.
             * @param value The depth of this Game Object.
             */
            setDepth(value: integer): Phaser.GameObjects.GameObject;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * Gets the center coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             */
            getCenter<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * Gets the top-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the top-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getTopRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-left corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomLeft<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bottom-right corner coordinate of this Game Object, regardless of origin.
             * The returned point is calculated in local space and does not factor in any parent containers
             * @param output An object to store the values in. If not provided a new Vector2 will be created.
             * @param includeParent If this Game Object has a parent Container, include it (and all other ancestors) in the resulting vector? Default false.
             */
            getBottomRight<O extends Phaser.Math.Vector2>(output?: O, includeParent?: boolean): O;

            /**
             * Gets the bounds of this Game Object, regardless of origin.
             * The values are stored and returned in a Rectangle, or Rectangle-like, object.
             * @param output An object to store the values in. If not provided a new Rectangle will be created.
             */
            getBounds<O extends Phaser.Math.Vector2>(output?: O): O;

            /**
             * The horizontal origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the left of the Game Object.
             */
            originX: number;

            /**
             * The vertical origin of this Game Object.
             * The origin maps the relationship between the size and position of the Game Object.
             * The default value is 0.5, meaning all Game Objects are positioned based on their center.
             * Setting the value to 0 means the position now relates to the top of the Game Object.
             */
            originY: number;

            /**
             * The horizontal display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginX: number;

            /**
             * The vertical display origin of this Game Object.
             * The origin is a normalized value between 0 and 1.
             * The displayOrigin is a pixel value, based on the size of the Game Object combined with the origin.
             */
            displayOriginY: number;

            /**
             * Sets the origin of this Game Object.
             * 
             * The values are given in the range 0 to 1.
             * @param x The horizontal origin value. Default 0.5.
             * @param y The vertical origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the origin of this Game Object based on the Pivot values in its Frame.
             */
            setOriginFromFrame(): Phaser.GameObjects.GameObject;

            /**
             * Sets the display origin of this Game Object.
             * The difference between this and setting the origin is that you can use pixel values for setting the display origin.
             * @param x The horizontal display origin value. Default 0.
             * @param y The vertical display origin value. If not defined it will be set to the value of `x`. Default x.
             */
            setDisplayOrigin(x?: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Updates the Display Origin cached values internally stored on this Game Object.
             * You don't usually call this directly, but it is exposed for edge-cases where you may.
             */
            updateDisplayOrigin(): Phaser.GameObjects.GameObject;

            /**
             * [description]
             */
            defaultPipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * [description]
             */
            pipeline: Phaser.Renderer.WebGL.WebGLPipeline;

            /**
             * Sets the initial WebGL Pipeline of this Game Object.
             * This should only be called during the instantiation of the Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            initPipeline(pipelineName: string): boolean;

            /**
             * Sets the active WebGL Pipeline of this Game Object.
             * @param pipelineName The name of the pipeline to set on this Game Object.
             */
            setPipeline(pipelineName: string): boolean;

            /**
             * Resets the WebGL Pipeline of this Game Object back to the default it was created with.
             */
            resetPipeline(): boolean;

            /**
             * Gets the name of the WebGL Pipeline this Game Object is currently using.
             */
            getPipelineName(): string;

            /**
             * The Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             */
            scaleMode: Phaser.ScaleModes;

            /**
             * Sets the Scale Mode being used by this Game Object.
             * Can be either `ScaleModes.LINEAR` or `ScaleModes.NEAREST`.
             * @param value The Scale Mode to be used by this Game Object.
             */
            setScaleMode(value: Phaser.ScaleModes): Phaser.GameObjects.GameObject;

            /**
             * The x position of this Game Object.
             */
            x: number;

            /**
             * The y position of this Game Object.
             */
            y: number;

            /**
             * The z position of this Game Object.
             * Note: Do not use this value to set the z-index, instead see the `depth` property.
             */
            z: number;

            /**
             * The w position of this Game Object.
             */
            w: number;

            /**
             * The horizontal scale of this Game Object.
             */
            scaleX: number;

            /**
             * The vertical scale of this Game Object.
             */
            scaleY: number;

            /**
             * The angle of this Game Object as expressed in degrees.
             * 
             * Where 0 is to the right, 90 is down, 180 is left.
             * 
             * If you prefer to work in radians, see the `rotation` property instead.
             */
            angle: integer;

            /**
             * The angle of this Game Object in radians.
             * 
             * If you prefer to work in degrees, see the `angle` property instead.
             */
            rotation: number;

            /**
             * Sets the position of this Game Object.
             * @param x The x position of this Game Object. Default 0.
             * @param y The y position of this Game Object. If not set it will use the `x` value. Default x.
             * @param z The z position of this Game Object. Default 0.
             * @param w The w position of this Game Object. Default 0.
             */
            setPosition(x?: number, y?: number, z?: number, w?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the rotation of this Game Object.
             * @param radians The rotation of this Game Object, in radians. Default 0.
             */
            setRotation(radians?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the angle of this Game Object.
             * @param degrees The rotation of this Game Object, in degrees. Default 0.
             */
            setAngle(degrees?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the scale of this Game Object.
             * @param x The horizontal scale of this Game Object.
             * @param y The vertical scale of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScale(x: number, y?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the x position of this Game Object.
             * @param value The x position of this Game Object. Default 0.
             */
            setX(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the y position of this Game Object.
             * @param value The y position of this Game Object. Default 0.
             */
            setY(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the z position of this Game Object.
             * @param value The z position of this Game Object. Default 0.
             */
            setZ(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Sets the w position of this Game Object.
             * @param value The w position of this Game Object. Default 0.
             */
            setW(value?: number): Phaser.GameObjects.GameObject;

            /**
             * Gets the local transform matrix for this Game Object.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getLocalTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * Gets the world transform matrix for this Game Object, factoring in any parent Containers.
             * @param tempMatrix The matrix to populate with the values from this Game Object.
             */
            getWorldTransformMatrix(tempMatrix?: Phaser.GameObjects.Components.TransformMatrix): Phaser.GameObjects.Components.TransformMatrix;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * The horizontal scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorX: number;

            /**
             * The vertical scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             */
            scrollFactorY: number;

            /**
             * Sets the scroll factor of this Game Object.
             * 
             * The scroll factor controls the influence of the movement of a Camera upon this Game Object.
             * 
             * When a camera scrolls it will change the location at which this Game Object is rendered on-screen.
             * It does not change the Game Objects actual position values.
             * 
             * A value of 1 means it will move exactly in sync with a camera.
             * A value of 0 means it will not move at all, even if the camera moves.
             * Other values control the degree to which the camera movement is mapped to this Game Object.
             * @param x The horizontal scroll factor of this Game Object.
             * @param y The vertical scroll factor of this Game Object. If not set it will use the `x` value. Default x.
             */
            setScrollFactor(x: number, y?: number): Phaser.GameObjects.GameObject;

        }

        /**
         * A Tile is a representation of a single tile within the Tilemap. This is a lightweight data
         * 
         * representation, so its position information is stored without factoring in scroll, layer
         * 
         * scale or layer position.
         */
        class Tile implements Phaser.GameObjects.Components.Alpha, Phaser.GameObjects.Components.Flip, Phaser.GameObjects.Components.Visible {
            /**
             * 
             * @param layer The LayerData object in the Tilemap that this tile belongs to.
             * @param index The unique index of this tile within the map.
             * @param x The x coordinate of this tile in tile coordinates.
             * @param y The y coordinate of this tile in tile coordinates.
             * @param width Width of the tile in pixels.
             * @param height Height of the tile in pixels.
             * @param baseWidth The base width a tile in the map (in pixels). Tiled maps support
             * multiple tileset sizes within one map, but they are still placed at intervals of the base
             * tile width.
             * @param baseHeight The base height of the tile in pixels (in pixels). Tiled maps
             * support multiple tileset sizes within one map, but they are still placed at intervals of the
             * base tile height.
             */
            constructor(layer: Phaser.Tilemaps.LayerData, index: integer, x: integer, y: integer, width: integer, height: integer, baseWidth: integer, baseHeight: integer);

            /**
             * The LayerData in the Tilemap data that this tile belongs to.
             */
            layer: Phaser.Tilemaps.LayerData;

            /**
             * The index of this tile within the map data corresponding to the tileset, or -1 if this
             * represents a blank tile.
             */
            index: integer;

            /**
             * The x map coordinate of this tile in tile units.
             */
            x: integer;

            /**
             * The y map coordinate of this tile in tile units.
             */
            y: integer;

            /**
             * The width of the tile in pixels.
             */
            width: integer;

            /**
             * The height of the tile in pixels.
             */
            height: integer;

            /**
             * The map's base width of a tile in pixels. Tiled maps support multiple tileset sizes
             * within one map, but they are still placed at intervals of the base tile size.
             */
            baseWidth: integer;

            /**
             * The map's base height of a tile in pixels. Tiled maps support multiple tileset sizes
             * within one map, but they are still placed at intervals of the base tile size.
             */
            baseHeight: integer;

            /**
             * The x coordinate of the top left of this tile in pixels. This is relative to the top left
             * of the layer this tile is being rendered within. This property does NOT factor in camera
             * scroll, layer scale or layer position.
             */
            pixelX: number;

            /**
             * The y coordinate of the top left of this tile in pixels. This is relative to the top left
             * of the layer this tile is being rendered within. This property does NOT factor in camera
             * scroll, layer scale or layer position.
             */
            pixelY: number;

            /**
             * Tile specific properties. These usually come from Tiled.
             */
            properties: object;

            /**
             * The rotation angle of this tile.
             */
            rotation: number;

            /**
             * Whether the tile should collide with any object on the left side.
             */
            collideLeft: boolean;

            /**
             * Whether the tile should collide with any object on the right side.
             */
            collideRight: boolean;

            /**
             * Whether the tile should collide with any object on the top side.
             */
            collideUp: boolean;

            /**
             * Whether the tile should collide with any object on the bottom side.
             */
            collideDown: boolean;

            /**
             * Whether the tile's left edge is interesting for collisions.
             */
            faceLeft: boolean;

            /**
             * Whether the tile's right edge is interesting for collisions.
             */
            faceRight: boolean;

            /**
             * Whether the tile's top edge is interesting for collisions.
             */
            faceTop: boolean;

            /**
             * Whether the tile's bottom edge is interesting for collisions.
             */
            faceBottom: boolean;

            /**
             * Tile collision callback.
             */
            collisionCallback: Function;

            /**
             * The context in which the collision callback will be called.
             */
            collisionCallbackContext: object;

            /**
             * The tint to apply to this tile. Note: tint is currently a single color value instead of
             * the 4 corner tint component on other GameObjects.
             */
            tint: number;

            /**
             * An empty object where physics-engine specific information (e.g. bodies) may be stored.
             */
            physics: object;

            /**
             * Check if the given x and y world coordinates are within this Tile. This does not factor in
             * camera scroll, layer scale or layer position.
             * @param x The x coordinate to test.
             * @param y The y coordinate to test.
             */
            containsPoint(x: number, y: number): boolean;

            /**
             * Copies the tile data & properties from the given tile to this tile. This copies everything
             * except for position and interesting faces.
             * @param tile The tile to copy from.
             */
            copy(tile: Phaser.Tilemaps.Tile): Phaser.Tilemaps.Tile;

            /**
             * The collision group for this Tile, defined within the Tileset. This returns a reference to
             * the collision group stored within the Tileset, so any modification of the returned object
             * will impact all tiles that have the same index as this tile.
             */
            getCollisionGroup(): object;

            /**
             * The tile data for this Tile, defined within the Tileset. This typically contains Tiled
             * collision data, tile animations and terrain information. This returns a reference to the tile
             * data stored within the Tileset, so any modification of the returned object will impact all
             * tiles that have the same index as this tile.
             */
            getTileData(): object;

            /**
             * Gets the world X position of the left side of the tile, factoring in the layers position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getLeft(camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Gets the world X position of the right side of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getRight(camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Gets the world Y position of the top side of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getTop(camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Gets the world Y position of the bottom side of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getBottom(camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Gets the world rectangle bounding box for the tile, factoring in the layers position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             * @param output [description]
             */
            getBounds(camera?: Phaser.Cameras.Scene2D.Camera, output?: object): Phaser.Geom.Rectangle | object;

            /**
             * Gets the world X position of the center of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getCenterX(camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Gets the world Y position of the center of the tile, factoring in the layer's position,
             * scale and scroll.
             * @param camera The Camera to use to perform the check.
             */
            getCenterY(camera?: Phaser.Cameras.Scene2D.Camera): number;

            /**
             * Clean up memory.
             */
            destroy(): void;

            /**
             * Check for intersection with this tile. This does not factor in camera scroll, layer scale or
             * layer position.
             * @param x The x axis in pixels.
             * @param y The y axis in pixels.
             * @param right The right point.
             * @param bottom The bottom point.
             */
            intersects(x: number, y: number, right: number, bottom: number): boolean;

            /**
             * Checks if the tile is interesting.
             * @param collides If true, will consider the tile interesting if it collides on any side.
             * @param faces If true, will consider the tile interesting if it has an interesting face.
             */
            isInteresting(collides: boolean, faces: boolean): boolean;

            /**
             * Reset collision status flags.
             * @param recalculateFaces Whether or not to recalculate interesting faces for this tile and its neighbors. Default true.
             */
            resetCollision(recalculateFaces?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Reset faces.
             */
            resetFaces(): Phaser.Tilemaps.Tile;

            /**
             * Sets the collision flags for each side of this tile and updates the interesting faces list.
             * @param left Indicating collide with any object on the left.
             * @param right Indicating collide with any object on the right.
             * @param up Indicating collide with any object on the top.
             * @param down Indicating collide with any object on the bottom.
             * @param recalculateFaces Whether or not to recalculate interesting faces
             * for this tile and its neighbors. Default true.
             */
            setCollision(left: boolean, right?: boolean, up?: boolean, down?: boolean, recalculateFaces?: boolean): Phaser.Tilemaps.Tile;

            /**
             * Set a callback to be called when this tile is hit by an object. The callback must true for
             * collision processing to take place.
             * @param callback Callback function.
             * @param context Callback will be called within this context.
             */
            setCollisionCallback(callback: Function, context: object): Phaser.Tilemaps.Tile;

            /**
             * Sets the size of the tile and updates its pixelX and pixelY.
             * @param tileWidth The width of the tile in pixels.
             * @param tileHeight The height of the tile in pixels.
             * @param baseWidth The base width a tile in the map (in pixels).
             * @param baseHeight The base height of the tile in pixels (in pixels).
             */
            setSize(tileWidth: integer, tileHeight: integer, baseWidth: integer, baseHeight: integer): Phaser.Tilemaps.Tile;

            /**
             * Used internally. Updates the tile's world XY position based on the current tile size.
             */
            updatePixelXY(): Phaser.Tilemaps.Tile;

            /**
             * True if this tile can collide on any of its faces or has a collision callback set.
             */
            canCollide: boolean;

            /**
             * True if this tile can collide on any of its faces.
             */
            collides: boolean;

            /**
             * True if this tile has any interesting faces.
             */
            hasInterestingFace: boolean;

            /**
             * The tileset that contains this Tile. This will only return null if accessed from a LayerData
             * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.
             */
            tileset: Phaser.Tilemaps.Tileset;

            /**
             * The tilemap layer that contains this Tile. This will only return null if accessed from a
             * LayerData instance before the tile is placed within a StaticTilemapLayer or
             * DynamicTilemapLayer.
             */
            tilemapLayer: Phaser.Tilemaps.StaticTilemapLayer | Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * The tilemap that contains this Tile. This will only return null if accessed from a LayerData
             * instance before the tile is placed within a StaticTilemapLayer or DynamicTilemapLayer.
             */
            tilemap: Phaser.Tilemaps.Tilemap;

            /**
             * Clears all alpha values associated with this Game Object.
             * Immediately sets the alpha levels back to 1 (fully opaque)
             */
            clearAlpha(): Phaser.GameObjects.GameObject;

            /**
             * Set the Alpha level of this Game Object. The alpha controls the opacity of the Game Object as it renders.
             * Alpha values are provided as a float between 0, fully transparent, and 1, fully opaque.
             * 
             * If your game is running under WebGL you can optionally specify four different alpha values, each of which
             * correspond to the four corners of the Game Object. Under Canvas only the `topLeft` value given is used.
             * @param topLeft The alpha value used for the top-left of the Game Object. If this is the only value given it's applied across the whole Game Object. Default 1.
             * @param topRight The alpha value used for the top-right of the Game Object. WebGL only.
             * @param bottomLeft The alpha value used for the bottom-left of the Game Object. WebGL only.
             * @param bottomRight The alpha value used for the bottom-right of the Game Object. WebGL only.
             */
            setAlpha(topLeft?: number, topRight?: number, bottomLeft?: number, bottomRight?: number): Phaser.GameObjects.GameObject;

            /**
             * The alpha value of the Game Object.
             * 
             * This is a global value, impacting the entire Game Object, not just a region of it.
             */
            alpha: number;

            /**
             * The alpha value starting from the top-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopLeft: number;

            /**
             * The alpha value starting from the top-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaTopRight: number;

            /**
             * The alpha value starting from the bottom-left of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomLeft: number;

            /**
             * The alpha value starting from the bottom-right of the Game Object.
             * This value is interpolated from the corner to the center of the Game Object.
             */
            alphaBottomRight: number;

            /**
             * The horizontally flipped state of the Game Object.
             * A Game Object that is flipped horizontally will render inversed on the horizontal axis.
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipX: boolean;

            /**
             * The vertically flipped state of the Game Object.
             * A Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)
             * Flipping always takes place from the middle of the texture and does not impact the scale value.
             */
            flipY: boolean;

            /**
             * Toggles the horizontal flipped state of this Game Object.
             */
            toggleFlipX(): Phaser.GameObjects.GameObject;

            /**
             * Toggles the vertical flipped state of this Game Object.
             */
            toggleFlipY(): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipX(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the vertical flipped state of this Game Object.
             * @param value The flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlipY(value: boolean): Phaser.GameObjects.GameObject;

            /**
             * Sets the horizontal and vertical flipped state of this Game Object.
             * @param x The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             * @param y The horizontal flipped state. `false` for no flip, or `true` to be flipped.
             */
            setFlip(x: boolean, y: boolean): Phaser.GameObjects.GameObject;

            /**
             * Resets the horizontal and vertical flipped state of this Game Object back to their default un-flipped state.
             */
            resetFlip(): Phaser.GameObjects.GameObject;

            /**
             * The visible state of the Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             */
            visible: boolean;

            /**
             * Sets the visibility of this Game Object.
             * 
             * An invisible Game Object will skip rendering, but will still process update logic.
             * @param value The visible state of the Game Object.
             */
            setVisible(value: boolean): Phaser.GameObjects.GameObject;

        }

        /**
         * A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data
         * 
         * about the map and allows you to add tilesets and tilemap layers to it. A map can have one or
         * 
         * more tilemap layers (StaticTilemapLayer or DynamicTilemapLayer), which are the display
         * 
         * objects that actually render tiles.
         * 
         * 
         * 
         * The Tilemap data be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free
         * 
         * software package specifically for creating tile maps, and is available from:
         * 
         * http://www.mapeditor.org
         * 
         * 
         * 
         * A Tilemap has handy methods for getting & manipulating the tiles within a layer. You can only
         * 
         * use the methods that change tiles (e.g. removeTileAt) on a DynamicTilemapLayer.
         * 
         * 
         * 
         * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a
         * 
         * StaticTilemapLayer or DynamicTilemapLayer may have its own unique tile size that overrides
         * 
         * it.
         */
        class Tilemap {
            /**
             * 
             * @param scene The Scene to which this Tilemap belongs.
             * @param mapData A MapData instance containing Tilemap data.
             */
            constructor(scene: Phaser.Scene, mapData: Phaser.Tilemaps.MapData);

            scene: Phaser.Scene;

            /**
             * The base width of a tile in pixels. Note that individual layers may have a different tile
             * width.
             */
            tileWidth: integer;

            /**
             * The base height of a tile in pixels. Note that individual layers may have a different
             * tile height.
             */
            tileHeight: integer;

            /**
             * The width of the map (in tiles).
             */
            width: number;

            /**
             * The height of the map (in tiles).
             */
            height: number;

            /**
             * The orientation of the map data (as specified in Tiled), usually 'orthogonal'.
             */
            orientation: string;

            /**
             * The format of the map data.
             */
            format: number;

            /**
             * The version of the map data (as specified in Tiled, usually 1).
             */
            version: number;

            /**
             * Map specific properties as specified in Tiled.
             */
            properties: object;

            /**
             * The width of the map in pixels based on width * tileWidth.
             */
            widthInPixels: number;

            /**
             * The height of the map in pixels based on height * tileHeight.
             */
            heightInPixels: number;

            imageCollections: Phaser.Tilemaps.ImageCollection[];

            /**
             * An array of Tiled Image Layers.
             */
            images: any[];

            /**
             * An array of Tilemap layer data.
             */
            layers: Phaser.Tilemaps.LayerData[];

            /**
             * An array of Tilesets used in the map.
             */
            tilesets: Phaser.Tilemaps.Tileset[];

            /**
             * An array of ObjectLayer instances parsed from Tiled object layers.
             */
            objects: Phaser.Tilemaps.ObjectLayer[];

            /**
             * The index of the currently selected LayerData object.
             */
            currentLayerIndex: integer;

            /**
             * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.
             * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled
             * editor.
             * @param tilesetName The name of the tileset as specified in the map data.
             * @param key The key of the Phaser.Cache image used for this tileset. If
             * `undefined` or `null` it will look for an image with a key matching the tilesetName parameter.
             * @param tileWidth The width of the tile (in pixels) in the Tileset Image. If not
             * given it will default to the map's tileWidth value, or the tileWidth specified in the Tiled
             * JSON file.
             * @param tileHeight The height of the tiles (in pixels) in the Tileset Image. If
             * not given it will default to the map's tileHeight value, or the tileHeight specified in the
             * Tiled JSON file.
             * @param tileMargin The margin around the tiles in the sheet (in pixels). If not
             * specified, it will default to 0 or the value specified in the Tiled JSON file.
             * @param tileSpacing The spacing between each the tile in the sheet (in pixels).
             * If not specified, it will default to 0 or the value specified in the Tiled JSON file.
             * @param gid If adding multiple tilesets to a blank map, specify the starting
             * GID this set will use here. Default 0.
             */
            addTilesetImage(tilesetName: string, key?: string, tileWidth?: integer, tileHeight?: integer, tileMargin?: integer, tileSpacing?: integer, gid?: integer): Phaser.Tilemaps.Tileset;

            /**
             * Turns the StaticTilemapLayer associated with the given layer into a DynamicTilemapLayer. If
             * no layer specified, the map's current layer is used. This is useful if you want to manipulate
             * a map at the start of a scene, but then make it non-manipulable and optimize it for speed.
             * Note: the DynamicTilemapLayer passed in is destroyed, so make sure to store the value
             * returned from this method if you want to manipulate the new StaticTilemapLayer.
             * @param layer The name of the layer from Tiled, the
             * index of the layer in the map, or a DynamicTilemapLayer.
             */
            convertLayerToStatic(layer?: string | integer | Phaser.Tilemaps.DynamicTilemapLayer): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * See component documentation. If no layer specified, the map's current layer is used. This
             * cannot be applied to StaticTilemapLayers.
             */
            copy(): Phaser.Tilemaps.Tilemap;

            /**
             * Creates a new and empty DynamicTilemapLayer. The currently selected layer in the map is set
             * to this new layer.
             * @param name The name of this layer. Must be unique within the map.
             * @param tileset The tileset the new layer will use.
             * @param width The width of the layer in tiles. If not specified, it will default
             * to the map's width.
             * @param height The height of the layer in tiles. If not specified, it will default
             * to the map's height.
             * @param tileWidth The width of the tiles the layer uses for calculations. If not
             * specified, it will default to the map's tileWidth.
             * @param tileHeight The height of the tiles the layer uses for calculations. If not
             * specified, it will default to the map's tileHeight.
             */
            createBlankDynamicLayer(name: string, tileset: Phaser.Tilemaps.Tileset, width: integer, height: integer, tileWidth: integer, tileHeight: integer): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Creates a new DynamicTilemapLayer that renders the LayerData associated with the given
             * `layerID`. The currently selected layer in the map is set to this new layer.
             * 
             * The `layerID` is important. If you've created your map in Tiled then you can get this by
             * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and
             * look at the layers[].name value. Either way it must match.
             * 
             * Unlike a static layer, a dynamic layer can be modified. See DynamicTilemapLayer for more
             * information.
             * @param layerID The layer array index value, or if a string is given, the
             * layer name from Tiled.
             * @param tileset The tileset the new layer will use.
             * @param x The x position to place the layer in the world. If not specified, it will
             * default to the layer offset from Tiled or 0.
             * @param y The y position to place the layer in the world. If not specified, it will
             * default to the layer offset from Tiled or 0.
             */
            createDynamicLayer(layerID: integer | string, tileset: Phaser.Tilemaps.Tileset, x: number, y: number): Phaser.Tilemaps.DynamicTilemapLayer;

            /**
             * Creates a Sprite for every object matching the given gid in the map data. All properties from
             * the map data objectgroup are copied into the `spriteConfig`, so you can use this as an easy
             * way to configure Sprite properties from within the map editor. For example giving an object a
             * property of alpha: 0.5 in the map editor will duplicate that when the Sprite is created.
             * @param name The name of the object layer (from Tiled) to create Sprites from.
             * @param id Either the id (object), gid (tile object) or name (object or
             * tile object) from Tiled. Ids are unique in Tiled, but a gid is shared by all tile objects
             * with the same graphic. The same name can be used on multiple objects.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default the scene the map is within.
             */
            createFromObjects(name: string, id: integer | string, spriteConfig: object, scene?: Phaser.Scene): Phaser.GameObjects.Sprite[];

            /**
             * Creates a Sprite for every object matching the given tile indexes in the layer. You can
             * optionally specify if each tile will be replaced with a new tile after the Sprite has been
             * created. This is useful if you want to lay down special tiles in a level that are converted to
             * Sprites, but want to replace the tile itself with a floor tile or similar once converted.
             * @param indexes The tile index, or array of indexes, to create Sprites from.
             * @param replacements The tile index, or array of indexes, to change a converted
             * tile to. Set to `null` to leave the tiles unchanged. If an array is given, it is assumed to be a
             * one-to-one mapping with the indexes array.
             * @param spriteConfig The config object to pass into the Sprite creator (i.e.
             * scene.make.sprite).
             * @param scene The Scene to create the Sprites within. Default scene the map is within.
             * @param camera The Camera to use when determining the world XY Default main camera.
             * @param layer [description]
             */
            createFromTiles(indexes: integer | any[], replacements: integer | any[], spriteConfig: object, scene?: Phaser.Scene, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.GameObjects.Sprite[];

            /**
             * Creates a new StaticTilemapLayer that renders the LayerData associated with the given
             * `layerID`. The currently selected layer in the map is set to this new layer.
             * 
             * The `layerID` is important. If you've created your map in Tiled then you can get this by
             * looking in Tiled and looking at the layer name. Or you can open the JSON file it exports and
             * look at the layers[].name value. Either way it must match.
             * 
             * It's important to remember that a static layer cannot be modified. See StaticTilemapLayer for
             * more information.
             * @param layerID The layer array index value, or if a string is given, the
             * layer name from Tiled.
             * @param tileset The tileset the new layer will use.
             * @param x The x position to place the layer in the world. If not specified, it will
             * default to the layer offset from Tiled or 0.
             * @param y The y position to place the layer in the world. If not specified, it will
             * default to the layer offset from Tiled or 0.
             */
            createStaticLayer(layerID: integer | string, tileset: Phaser.Tilemaps.Tileset, x: number, y: number): Phaser.Tilemaps.StaticTilemapLayer;

            /**
             * Removes all layer data from this Tilemap and nulls the scene reference. This will destroy any
             * StaticTilemapLayers or DynamicTilemapLayers that have been linked to LayerData.
             */
            destroy(): void;

            /**
             * Sets the tiles in the given rectangular area (in tile coordinates) of the layer with the
             * specified index. Tiles will be set to collide if the given index is a colliding index.
             * Collision information in the region will be recalculated.
             * 
             * If no layer specified, the map's current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param index [description]
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param recalculateFaces [description] Default true.
             * @param layer [description]
             */
            fill(index: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * For each object in the given object layer, run the given filter callback function. Any
             * objects that pass the filter test (i.e. where the callback returns true) will returned as a
             * new array. Similar to Array.prototype.Filter in vanilla JS.
             * @param objectLayer The name of an object layer (from Tiled) or an ObjectLayer instance.
             * @param callback The callback. Each object in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             */
            filterObjects(objectLayer: Phaser.Tilemaps.ObjectLayer | string, callback: TilemapFilterCallback, context?: object): Phaser.GameObjects.GameObject[];

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * filter callback function. Any tiles that pass the filter test (i.e. where the callback returns
             * true) will returned as a new array. Similar to Array.prototype.Filter in vanilla JS.
             * If no layer specified, the map's current layer is used.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter. The callback should return true for tiles that pass the
             * filter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param layer [description]
             */
            filterTiles(callback: Function, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile[];

            /**
             * Searches the entire map layer for the first tile matching the given index, then returns that Tile
             * object. If no match is found, it returns null. The search starts from the top-left tile and
             * continues horizontally until it hits the end of the row, then it drops down to the next column.
             * If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to
             * the top-left.
             * If no layer specified, the map's current layer is used.
             * @param index The tile index value to search for.
             * @param skip The number of times to skip a matching tile before returning. Default 0.
             * @param reverse If true it will scan the layer in reverse, starting at the
             * bottom-right. Otherwise it scans from the top-left. Default false.
             * @param layer [description]
             */
            findByIndex(index: integer, skip?: integer, reverse?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Find the first object in the given object layer that satisfies the provided testing function.
             * I.e. finds the first object for which `callback` returns true. Similar to
             * Array.prototype.find in vanilla JS.
             * @param objectLayer The name of an object layer (from Tiled) or an ObjectLayer instance.
             * @param callback The callback. Each object in the given area will be passed to this callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             */
            findObject(objectLayer: Phaser.Tilemaps.ObjectLayer | string, callback: TilemapFindCallback, context?: object): Phaser.GameObjects.GameObject;

            /**
             * Find the first tile in the given rectangular area (in tile coordinates) of the layer that
             * satisfies the provided testing function. I.e. finds the first tile for which `callback` returns
             * true. Similar to Array.prototype.find in vanilla JS.
             * If no layer specified, the maps current layer is used.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param layer [description]
             */
            findTile(callback: FindTileCallback, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * For each tile in the given rectangular area (in tile coordinates) of the layer, run the given
             * callback. Similar to Array.prototype.forEach in vanilla JS.
             * 
             * If no layer specified, the map's current layer is used.
             * @param callback The callback. Each tile in the given area will be passed to this
             * callback as the first and only parameter.
             * @param context The context under which the callback should be run.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide
             * on at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param layer [description]
             */
            forEachTile(callback: EachTileCallback, context?: object, tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object, layer?: LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Gets the image layer index based on its name.
             * @param name The name of the image to get.
             */
            getImageIndex(name: string): integer;

            /**
             * Internally used. Returns the index of the object in one of the Tilemaps arrays whose name
             * property matches the given `name`.
             * @param location The Tilemap array to search.
             * @param name The name of the array element to get.
             */
            getIndex(location: any[], name: string): number;

            /**
             * Gets the LayerData from this.layers that is associated with `layer`, or null if an invalid
             * `layer` is given.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the maps current layer index.
             */
            getLayer(layer?: string | integer | Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer): Phaser.Tilemaps.LayerData;

            /**
             * Gets the ObjectLayer from this.objects that has the given `name`, or null if no ObjectLayer
             * is found with that name.
             * @param name The name of the object layer from Tiled.
             */
            getObjectLayer(name?: string): Phaser.Tilemaps.ObjectLayer;

            /**
             * Gets the LayerData index of the given `layer` within this.layers, or null if an invalid
             * `layer` is given.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the map's current layer index.
             */
            getLayerIndex(layer?: string | integer | Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer): integer;

            /**
             * Gets the index of the LayerData within this.layers that has the given `name`, or null if an
             * invalid `name` is given.
             * @param name The name of the layer to get.
             */
            getLayerIndexByName(name: string): integer;

            /**
             * Gets a tile at the given tile coordinates from the given layer.
             * If no layer specified, the map's current layer is used.
             * @param tileX X position to get the tile from (given in tile units, not pixels).
             * @param tileY Y position to get the tile from (given in tile units, not pixels).
             * @param nonNull If true getTile won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             * @param layer [description]
             */
            getTileAt(tileX: integer, tileY: integer, nonNull?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Gets a tile at the given world coordinates from the given layer.
             * If no layer specified, the map's current layer is used.
             * @param worldX X position to get the tile from (given in pixels)
             * @param worldY Y position to get the tile from (given in pixels)
             * @param nonNull If true, function won't return null for empty tiles, but a Tile
             * object with an index of -1. Default false.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            getTileAtWorldXY(worldX: number, worldY: number, nonNull?: boolean, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Gets the tiles in the given rectangular area (in tile coordinates) of the layer.
             * If no layer specified, the maps current layer is used.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param layer [description]
             */
            getTilesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer, filteringOptions?: object, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile[];

            /**
             * Gets the tiles that overlap with the given shape in the given layer. The shape must be a Circle,
             * Line, Rectangle or Triangle. The shape should be in world coordinates.
             * If no layer specified, the maps current layer is used.
             * @param shape A shape in world (pixel) coordinates
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            getTilesWithinShape(shape: Phaser.Geom.Circle | Phaser.Geom.Line | Phaser.Geom.Rectangle | Phaser.Geom.Triangle, filteringOptions?: object, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile[];

            /**
             * Gets the tiles in the given rectangular area (in world coordinates) of the layer.
             * If no layer specified, the maps current layer is used.
             * @param worldX [description]
             * @param worldY [description]
             * @param width [description]
             * @param height [description]
             * @param filteringOptions Optional filters to apply when getting the tiles.
             * @param filteringOptions.isNotEmpty If true, only return tiles that don't have
             * -1 for an index. Default false.
             * @param filteringOptions.isColliding If true, only return tiles that collide on
             * at least one side. Default false.
             * @param filteringOptions.hasInterestingFace If true, only return tiles that
             * have at least one interesting face. Default false.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            getTilesWithinWorldXY(worldX: number, worldY: number, width: number, height: number, filteringOptions?: object, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile[];

            /**
             * Gets the index of the Tileset within this.tilesets that has the given `name`, or null if an
             * invalid `name` is given.
             * @param name The name of the Tileset to get.
             */
            getTilesetIndex(name: string): integer;

            /**
             * Checks if there is a tile at the given location (in tile coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * 
             * If no layer specified, the map's current layer is used.
             * @param tileX [description]
             * @param tileY [description]
             * @param layer [description]
             */
            hasTileAt(tileX: integer, tileY: integer, layer?: Phaser.Tilemaps.LayerData): boolean;

            /**
             * Checks if there is a tile at the given location (in world coordinates) in the given layer. Returns
             * false if there is no tile or if the tile at that location has an index of -1.
             * 
             * If no layer specified, the maps current layer is used.
             * @param worldX [description]
             * @param worldY [description]
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            hasTileAtWorldXY(worldX: number, worldY: number, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): boolean;

            /**
             * The LayerData object that is currently selected in the map. You can set this property using
             * any type supported by setLayer.
             */
            layer: Phaser.Tilemaps.LayerData;

            /**
             * Puts a tile at the given tile coordinates in the specified layer. You can pass in either an index
             * or a Tile object. If you pass in a Tile, all attributes will be copied over to the specified
             * location. If you pass in an index, only the index at the specified location will be changed.
             * Collision information will be recalculated at the specified location.
             * 
             * If no layer specified, the maps current layer is used.
             * 
             * This cannot be applied to StaticTilemapLayers.
             * @param tile The index of this tile to set or a Tile object.
             * @param tileX [description]
             * @param tileY [description]
             * @param recalculateFaces [description] Default true.
             * @param layer [description]
             */
            putTileAt(tile: integer | Phaser.Tilemaps.Tile, tileX: integer, tileY: integer, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Puts a tile at the given world coordinates (pixels) in the specified layer. You can pass in either
             * an index or a Tile object. If you pass in a Tile, all attributes will be copied over to the
             * specified location. If you pass in an index, only the index at the specified location will be
             * changed. Collision information will be recalculated at the specified location.
             * 
             * If no layer specified, the maps current layer is used. This
             * cannot be applied to StaticTilemapLayers.
             * @param tile The index of this tile to set or a Tile object.
             * @param worldX [description]
             * @param worldY [description]
             * @param recalculateFaces [description] Default true.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            putTileAtWorldXY(tile: integer | Phaser.Tilemaps.Tile, worldX: integer, worldY: integer, recalculateFaces?: boolean, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Puts an array of tiles or a 2D array of tiles at the given tile coordinates in the specified
             * layer. The array can be composed of either tile indexes or Tile objects. If you pass in a Tile,
             * all attributes will be copied over to the specified location. If you pass in an index, only the
             * index at the specified location will be changed. Collision information will be recalculated
             * within the region tiles were changed.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tile A row (array) or grid (2D array) of Tiles
             * or tile indexes to place.
             * @param tileX [description]
             * @param tileY [description]
             * @param recalculateFaces [description] Default true.
             * @param layer [description]
             */
            putTilesAt(tile: integer[] | integer[][] | Phaser.Tilemaps.Tile[] | Phaser.Tilemaps.Tile[][], tileX: integer, tileY: integer, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will recieve a new index. If an array of indexes is passed in, then
             * those will be used for randomly assigning new tile indexes. If an array is not provided, the
             * indexes found within the region (excluding -1) will be used for randomly assigning new tile
             * indexes. This method only modifies tile indexes and does not change collision information.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param indexes An array of indexes to randomly draw from during randomization.
             * @param layer [description]
             */
            randomize(tileX?: integer, tileY?: integer, width?: integer, height?: integer, indexes?: integer[], layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Calculates interesting faces at the given tile coordinates of the specified layer. Interesting
             * faces are used internally for optimizing collisions against tiles. This method is mostly used
             * internally to optimize recalculating faces when only one tile has been changed.
             * 
             * If no layer specified, the maps current layer is used.
             * @param tileX [description]
             * @param tileY [description]
             * @param layer [description]
             */
            calculateFacesAt(tileX: integer, tileY: integer, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Calculates interesting faces within the rectangular area specified (in tile coordinates) of the
             * layer. Interesting faces are used internally for optimizing collisions against tiles. This method
             * is mostly used internally.
             * 
             * If no layer specified, the map's current layer is used.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param layer [description]
             */
            calculateFacesWithin(tileX?: integer, tileY?: integer, width?: integer, height?: integer, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Removes all layers from this Tilemap and destroys any associated StaticTilemapLayers or
             * DynamicTilemapLayers.
             */
            removeAllLayers(): Phaser.Tilemaps.Tilemap;

            /**
             * Removes the tile at the given tile coordinates in the specified layer and updates the layer's
             * collision information.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tile The index of this tile to set or a Tile object.
             * @param tileX [description]
             * @param tileY [description]
             * @param replaceWithNull If true, this will replace the tile at the specified
             * location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces [description] Default true.
             * @param layer [description]
             */
            removeTileAt(tile: integer | Phaser.Tilemaps.Tile, tileX: integer, tileY: integer, replaceWithNull?: boolean, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Removes the tile at the given world coordinates in the specified layer and updates the layer's
             * collision information.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tile The index of this tile to set or a Tile object.
             * @param worldX [description]
             * @param worldY [description]
             * @param replaceWithNull If true, this will replace the tile at the specified
             * location with null instead of a Tile with an index of -1. Default true.
             * @param recalculateFaces [description] Default true.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            removeTileAtWorldXY(tile: integer | Phaser.Tilemaps.Tile, worldX: number, worldY: number, replaceWithNull?: boolean, recalculateFaces?: boolean, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tile;

            /**
             * Draws a debug representation of the layer to the given Graphics. This is helpful when you want to
             * get a quick idea of which of your tiles are colliding and which have interesting faces. The tiles
             * are drawn starting at (0, 0) in the Graphics, allowing you to place the debug representation
             * wherever you want on the screen.
             * 
             * If no layer specified, the maps current layer is used.
             * @param graphics The target Graphics object to draw upon.
             * @param styleConfig An object specifying the colors to use for the debug drawing.
             * @param styleConfig.tileColor Color to use for drawing a filled rectangle at
             * non-colliding tile locations. If set to null, non-colliding tiles will not be drawn. Default blue.
             * @param styleConfig.collidingTileColor Color to use for drawing a filled
             * rectangle at colliding tile locations. If set to null, colliding tiles will not be drawn. Default orange.
             * @param styleConfig.faceColor Color to use for drawing a line at interesting
             * tile faces. If set to null, interesting tile faces will not be drawn. Default grey.
             * @param layer [description]
             */
            renderDebug(graphics: Phaser.GameObjects.Graphics, styleConfig: object, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `findIndex` and updates their index to match `newIndex`. This only modifies the index and does
             * not change collision information.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param findIndex [description]
             * @param newIndex [description]
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param layer [description]
             */
            replaceByIndex(findIndex: integer, newIndex: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets collision on the given tile or tiles within a layer by index. You can pass in either a
             * single numeric index or an array of indexes: [2, 3, 15, 20]. The `collides` parameter controls if
             * collision will be enabled (true) or disabled (false).
             * 
             * If no layer specified, the map's current layer is used.
             * @param indexes Either a single tile index, or an array of tile indexes.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             * @param layer [description]
             */
            setCollision(indexes: integer | any[], collides?: boolean, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets collision on a range of tiles in a layer whose index is between the specified `start` and
             * `stop` (inclusive). Calling this with a start value of 10 and a stop value of 14 would set
             * collision for tiles 10, 11, 12, 13 and 14. The `collides` parameter controls if collision will be
             * enabled (true) or disabled (false).
             * 
             * If no layer specified, the map's current layer is used.
             * @param start The first index of the tile to be set for collision.
             * @param stop The last index of the tile to be set for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             * @param layer [description]
             */
            setCollisionBetween(start: integer, stop: integer, collides?: boolean, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets collision on the tiles within a layer by checking tile properties. If a tile has a property
             * that matches the given properties object, its collision flag will be set. The `collides`
             * parameter controls if collision will be enabled (true) or disabled (false). Passing in
             * `{ collides: true }` would update the collision flag on any tiles with a "collides" property that
             * has a value of true. Any tile that doesn't have "collides" set to true will be ignored. You can
             * also use an array of values, e.g. `{ types: ["stone", "lava", "sand" ] }`. If a tile has a
             * "types" property that matches any of those values, its collision flag will be updated.
             * 
             * If no layer specified, the map's current layer is used.
             * @param properties An object with tile properties and corresponding values that should
             * be checked.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             * @param layer [description]
             */
            setCollisionByProperty(properties: object, collides?: boolean, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets collision on all tiles in the given layer, except for tiles that have an index specified in
             * the given array. The `collides` parameter controls if collision will be enabled (true) or
             * disabled (false).
             * 
             * If no layer specified, the map's current layer is used.
             * @param indexes An array of the tile indexes to not be counted for collision.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             * @param layer [description]
             */
            setCollisionByExclusion(indexes: integer[], collides?: boolean, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets collision on the tiles within a layer by checking each tile's collision group data
             * (typically defined in Tiled within the tileset collision editor). If any objects are found within
             * a tile's collision group, the tile's colliding information will be set. The `collides` parameter
             * controls if collision will be enabled (true) or disabled (false).
             * 
             * If no layer specified, the map's current layer is used.
             * @param collides If true it will enable collision. If false it will clear
             * collision. Default true.
             * @param recalculateFaces Whether or not to recalculate the tile faces after the
             * update. Default true.
             * @param layer [description]
             */
            setCollisionFromCollisionGroup(collides?: boolean, recalculateFaces?: boolean, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets a global collision callback for the given tile index within the layer. This will affect all
             * tiles on this layer that have the same index. If a callback is already set for the tile index it
             * will be replaced. Set the callback to null to remove it. If you want to set a callback for a tile
             * at a specific location on the map then see setTileLocationCallback.
             * 
             * If no layer specified, the map's current layer is used.
             * @param indexes Either a single tile index, or an array of tile indexes to have a
             * collision callback set for.
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             * @param layer [description]
             */
            setTileIndexCallback(indexes: integer | any[], callback: Function, callbackContext: object, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets a collision callback for the given rectangular area (in tile coordindates) within the layer.
             * If a callback is already set for the tile index it will be replaced. Set the callback to null to
             * remove it.
             * 
             * If no layer specified, the map's current layer is used.
             * @param tileX [description]
             * @param tileY [description]
             * @param width [description]
             * @param height [description]
             * @param callback The callback that will be invoked when the tile is collided with.
             * @param callbackContext The context under which the callback is called.
             * @param layer [description]
             */
            setTileLocationCallback(tileX: integer, tileY: integer, width: integer, height: integer, callback: Function, callbackContext?: object, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Sets the current layer to the LayerData associated with `layer`.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the map's current layer index.
             */
            setLayer(layer?: string | integer | Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer): Phaser.Tilemaps.Tilemap;

            /**
             * Sets the base tile size for the map. Note: this does not necessarily match the tileWidth and
             * tileHeight for all layers. This also updates the base size on all tiles across all layers.
             * @param tileWidth The width of the tiles the map uses for calculations.
             * @param tileHeight The height of the tiles the map uses for calculations.
             */
            setBaseTileSize(tileWidth: integer, tileHeight: integer): Phaser.Tilemaps.Tilemap;

            /**
             * Sets the tile size for a specific `layer`. Note: this does not necessarily match the map's
             * tileWidth and tileHeight for all layers. This will set the tile size for the layer and any
             * tiles the layer has.
             * @param tileWidth The width of the tiles (in pixels) in the layer.
             * @param tileHeight The height of the tiles (in pixels) in the layer.
             * @param layer The name of the
             * layer from Tiled, the index of the layer in the map, a DynamicTilemapLayer or a
             * StaticTilemapLayer. If not given will default to the map's current layer index.
             */
            setLayerTileSize(tileWidth: integer, tileHeight: integer, layer?: string | integer | Phaser.Tilemaps.DynamicTilemapLayer | Phaser.Tilemaps.StaticTilemapLayer): Phaser.Tilemaps.Tilemap;

            /**
             * Shuffles the tiles in a rectangular region (specified in tile coordinates) within the given
             * layer. It will only randomize the tiles in that area, so if they're all the same nothing will
             * appear to have changed! This method only modifies tile indexes and does not change collision
             * information.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param layer [description]
             */
            shuffle(tileX?: integer, tileY?: integer, width?: integer, height?: integer, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Scans the given rectangular area (given in tile coordinates) for tiles with an index matching
             * `indexA` and swaps then with `indexB`. This only modifies the index and does not change collision
             * information.
             * 
             * If no layer specified, the maps current layer is used.
             * This cannot be applied to StaticTilemapLayers.
             * @param tileA First tile index.
             * @param tileB Second tile index.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param layer [description]
             */
            swapByIndex(tileA: integer, tileB: integer, tileX?: integer, tileY?: integer, width?: integer, height?: integer, layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Converts from tile X coordinates (tile units) to world X coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * 
             * If no layer specified, the maps current layer is used.
             * @param tileX [description]
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            tileToWorldX(tileX: integer, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): number;

            /**
             * Converts from tile Y coordinates (tile units) to world Y coordinates (pixels), factoring in the
             * layers position, scale and scroll.
             * 
             * If no layer specified, the maps current layer is used.
             * @param tileY [description]
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            tileToWorldY(tileY: integer, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): number;

            /**
             * Converts from tile XY coordinates (tile units) to world XY coordinates (pixels), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * 
             * If no layer specified, the maps current layer is used.
             * @param tileX [description]
             * @param tileY [description]
             * @param point [description]
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            tileToWorldXY(tileX: integer, tileY: integer, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Math.Vector2;

            /**
             * Randomizes the indexes of a rectangular region of tiles (in tile coordinates) within the
             * specified layer. Each tile will receive a new index. New indexes are drawn from the given
             * weightedIndexes array. An example weighted array:
             * 
             * [
             *  { index: 6, weight: 4 },    // Probability of index 6 is 4 / 8
             *  { index: 7, weight: 2 },    // Probability of index 7 would be 2 / 8
             *  { index: 8, weight: 1.5 },  // Probability of index 8 would be 1.5 / 8
             *  { index: 26, weight: 0.5 }  // Probability of index 27 would be 0.5 / 8
             * ]
             * 
             * The probability of any index being choose is (the index's weight) / (sum of all weights). This
             * method only modifies tile indexes and does not change collision information.
             * 
             * If no layer specified, the map's current layer is used. This
             * cannot be applied to StaticTilemapLayers.
             * @param tileX [description] Default 0.
             * @param tileY [description] Default 0.
             * @param width [description] Default max width based on tileX.
             * @param height [description] Default max height based on tileY.
             * @param weightedIndexes An array of objects to randomly draw from during
             * randomization. They should be in the form: { index: 0, weight: 4 } or
             * { index: [0, 1], weight: 4 } if you wish to draw from multiple tile indexes.
             * @param layer [description]
             */
            weightedRandomize(tileX?: integer, tileY?: integer, width?: integer, height?: integer, weightedIndexes?: object[], layer?: Phaser.Tilemaps.LayerData): Phaser.Tilemaps.Tilemap;

            /**
             * Converts from world X coordinates (pixels) to tile X coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * 
             * If no layer specified, the maps current layer is used.
             * @param worldX [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            worldToTileX(worldX: number, snapToFloor?: boolean, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): number;

            /**
             * Converts from world Y coordinates (pixels) to tile Y coordinates (tile units), factoring in the
             * layers position, scale and scroll.
             * 
             * If no layer specified, the maps current layer is used.
             * @param worldY [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            worldToTileY(worldY: number, snapToFloor?: boolean, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): number;

            /**
             * Converts from world XY coordinates (pixels) to tile XY coordinates (tile units), factoring in the
             * layers position, scale and scroll. This will return a new Vector2 object or update the given
             * `point` object.
             * 
             * If no layer specified, the maps current layer is used.
             * @param worldX [description]
             * @param worldY [description]
             * @param snapToFloor Whether or not to round the tile coordinate down to the
             * nearest integer. Default true.
             * @param point [description]
             * @param camera [description] Default main camera.
             * @param layer [description]
             */
            worldToTileXY(worldX: number, worldY: number, snapToFloor?: boolean, point?: Phaser.Math.Vector2, camera?: Phaser.Cameras.Scene2D.Camera, layer?: Phaser.Tilemaps.LayerData): Phaser.Math.Vector2;

        }

        /**
         * A Tileset is a combination of an image containing the tiles and a container for data about
         * 
         * each tile.
         */
        class Tileset {
            /**
             * 
             * @param name The name of the tileset in the map data.
             * @param firstgid The first tile index this tileset contains.
             * @param tileWidth Width of each tile (in pixels). Default 32.
             * @param tileHeight Height of each tile (in pixels). Default 32.
             * @param tileMargin The margin around all tiles in the sheet (in pixels). Default 0.
             * @param tileSpacing The spacing between each tile in the sheet (in pixels). Default 0.
             * @param tileProperties Custom properties defined per tile in the Tileset.
             * These typically are custom properties created in Tiled when editing a tileset. Default {}.
             * @param tileData Data stored per tile. These typically are created in Tiled
             * when editing a tileset, e.g. from Tiled's tile collision editor or terrain editor. Default {}.
             */
            constructor(name: string, firstgid: integer, tileWidth?: integer, tileHeight?: integer, tileMargin?: integer, tileSpacing?: integer, tileProperties?: object, tileData?: object);

            /**
             * The name of the Tileset.
             */
            name: string;

            /**
             * The starting index of the first tile index this Tileset contains.
             */
            firstgid: integer;

            /**
             * The width of each tile (in pixels). Use setTileSize to change.
             */
            tileWidth: integer;

            /**
             * The height of each tile (in pixels). Use setTileSize to change.
             */
            tileHeight: integer;

            /**
             * The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.
             */
            tileMargin: integer;

            /**
             * The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.
             */
            tileSpacing: integer;

            /**
             * Tileset-specific properties per tile that are typically defined in the Tiled editor in the
             * Tileset editor.
             */
            tileProperties: object;

            /**
             * Tileset-specific data per tile that are typically defined in the Tiled editor, e.g. within
             * the Tileset collision editor. This is where collision objects and terrain are stored.
             */
            tileData: object;

            /**
             * The cached image that contains the individual tiles. Use setImage to set.
             */
            image: Phaser.Textures.Texture;

            /**
             * The number of tile rows in the the tileset.
             */
            rows: integer;

            /**
             * The number of tile columns in the tileset.
             */
            columns: integer;

            /**
             * The total number of tiles in the tileset.
             */
            total: integer;

            /**
             * The look-up table to specific tile image texture coordinates (UV in pixels). Each element
             * contains the coordinates for a tile in an object of the form {x, y}.
             */
            texCoordinates: object[];

            /**
             * Get a tiles properties that are stored in the Tileset. Returns null if tile index is not
             * contained in this Tileset. This is typically defined in Tiled under the Tileset editor.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileProperties(tileIndex: integer): object | undefined;

            /**
             * Get a tile's data that is stored in the Tileset. Returns null if tile index is not contained
             * in this Tileset. This is typically defined in Tiled and will contain both Tileset collision
             * info and terrain mapping.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileData(tileIndex: integer): object | undefined;

            /**
             * Get a tile's collision group that is stored in the Tileset. Returns null if tile index is not
             * contained in this Tileset. This is typically defined within Tiled's tileset collision editor.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileCollisionGroup(tileIndex: integer): object;

            /**
             * Returns true if and only if this Tileset contains the given tile index.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            containsTileIndex(tileIndex: integer): boolean;

            /**
             * Returns the texture coordinates (UV in pixels) in the Tileset image for the given tile index.
             * Returns null if tile index is not contained in this Tileset.
             * @param tileIndex The unique id of the tile across all tilesets in the map.
             */
            getTileTextureCoordinates(tileIndex: integer): object;

            /**
             * Sets the image associated with this Tileset and updates the tile data (rows, columns, etc.).
             * @param texture The image that contains the tiles.
             */
            setImage(texture: Phaser.Textures.Texture): Phaser.Tilemaps.Tileset;

            /**
             * Sets the tile width & height and updates the tile data (rows, columns, etc.).
             * @param tileWidth The width of a tile in pixels.
             * @param tileHeight The height of a tile in pixels.
             */
            setTileSize(tileWidth?: integer, tileHeight?: integer): Phaser.Tilemaps.Tileset;

            /**
             * Sets the tile margin & spacing and updates the tile data (rows, columns, etc.).
             * @param margin The margin around the tiles in the sheet (in pixels).
             * @param spacing The spacing between the tiles in the sheet (in pixels).
             */
            setSpacing(margin?: integer, spacing?: integer): Phaser.Tilemaps.Tileset;

            /**
             * Updates tile texture coordinates and tileset data.
             * @param imageWidth The (expected) width of the image to slice.
             * @param imageHeight The (expected) height of the image to slice.
             */
            updateTileData(imageWidth: integer, imageHeight: integer): Phaser.Tilemaps.Tileset;

        }

    }

    namespace Time {
        /**
         * [description]
         */
        class Clock {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * [description]
             */
            now: number;

            /**
             * [description]
             */
            timeScale: number;

            /**
             * [description]
             */
            paused: boolean;

            /**
             * [description]
             * @param config [description]
             */
            addEvent(config: TimerEventConfig): Phaser.Time.TimerEvent;

            /**
             * [description]
             * @param delay [description]
             * @param callback [description]
             * @param args [description]
             * @param callbackScope [description]
             */
            delayedCall(delay: number, callback: Function, args: any[], callbackScope: any): Phaser.Time.TimerEvent;

            /**
             * [description]
             */
            clearPendingEvents(): Phaser.Time.Clock;

            /**
             * [description]
             */
            removeAllEvents(): Phaser.Time.Clock;

            /**
             * [description]
             * @param time [description]
             * @param delta [description]
             */
            preUpdate(time: number, delta: number): void;

            /**
             * [description]
             * @param time [description]
             * @param delta [description]
             */
            update(time: number, delta: number): void;

        }

        /**
         * [description]
         */
        class TimerEvent {
            /**
             * 
             * @param config [description]
             */
            constructor(config: TimerEventConfig);

            /**
             * The delay in ms at which this TimerEvent fires.
             */
            delay: number;

            /**
             * The total number of times this TimerEvent will repeat before finishing.
             */
            repeat: number;

            /**
             * If repeating this contains the current repeat count.
             */
            repeatCount: number;

            /**
             * True if this TimerEvent loops, otherwise false.
             */
            loop: boolean;

            /**
             * The callback that will be called when the TimerEvent occurs.
             */
            callback: Function;

            /**
             * The scope in which the callback will be called.
             */
            callbackScope: object;

            /**
             * Additional arguments to be passed to the callback.
             */
            args: any[];

            /**
             * Scale the time causing this TimerEvent to update.
             */
            timeScale: number;

            /**
             * Start this many MS into the elapsed (useful if you want a long duration with repeat, but for the first loop to fire quickly)
             */
            startAt: number;

            /**
             * [description]
             */
            elapsed: number;

            /**
             * [description]
             */
            paused: boolean;

            /**
             * [description]
             */
            hasDispatched: boolean;

            /**
             * [description]
             * @param config [description]
             */
            reset(config: TimerEventConfig): Phaser.Time.TimerEvent;

            /**
             * Gets the progress of the current iteration, not factoring in repeats.
             */
            getProgress(): number;

            /**
             * Gets the progress of the timer overall, factoring in repeats.
             */
            getOverallProgress(): number;

            /**
             * [description]
             */
            getRepeatCount(): number;

            /**
             * [description]
             */
            getElapsed(): number;

            /**
             * [description]
             */
            getElapsedSeconds(): number;

            /**
             * [description]
             * @param dispatchCallback [description]
             */
            remove(dispatchCallback: Function): void;

            /**
             * [description]
             */
            destroy(): void;

        }

    }

    namespace Tweens {
        namespace Builders {
            /**
             * [description]
             * @param source [description]
             * @param key [description]
             * @param defaultValue [description]
             */
            function GetBoolean(source: object, key: string, defaultValue: any): any;

            /**
             * [description]
             * @param ease [description]
             * @param easeParams [description]
             */
            function GetEaseFunction(ease: string | Function, easeParams: any[]): Function;

            /**
             * [description]
             * @param source [description]
             * @param key [description]
             * @param defaultValue [description]
             */
            function GetNewValue(source: object, key: string, defaultValue: any): Function;

            /**
             * [description]
             * @param config [description]
             */
            function GetProps(config: object): any[];

            /**
             * [description]
             * @param config [description]
             */
            function GetTargets(config: object): any[];

            /**
             * [description]
             * @param config [description]
             */
            function GetTweens(config: object): any[];

            /**
             * [description]
             * @param key [description]
             * @param propertyValue [description]
             */
            function GetValueOp(key: string, propertyValue: any): Function;

            /**
             * [description]
             * @param parent [description]
             * @param config [description]
             * @param defaults [description]
             */
            function NumberTweenBuilder(parent: Phaser.Tweens.TweenManager | Phaser.Tweens.Timeline, config: object, defaults: Phaser.Tweens.TweenConfigDefaults): Phaser.Tweens.Tween;

            /**
             * [description]
             * @param manager [description]
             * @param config [description]
             */
            function TimelineBuilder(manager: Phaser.Tweens.TweenManager, config: object): Phaser.Tweens.Timeline;

            /**
             * [description]
             * @param parent [description]
             * @param config [description]
             * @param defaults [description]
             */
            function TweenBuilder(parent: Phaser.Tweens.TweenManager | Phaser.Tweens.Timeline, config: object, defaults: Phaser.Tweens.TweenConfigDefaults): Phaser.Tweens.Tween;

        }

        /**
         * [description]
         */
        class Timeline extends Phaser.Events.EventEmitter {
            /**
             * 
             * @param manager [description]
             */
            constructor(manager: Phaser.Tweens.TweenManager);

            /**
             * [description]
             */
            manager: Phaser.Tweens.TweenManager;

            /**
             * [description]
             */
            isTimeline: boolean;

            /**
             * An array of Tween objects, each containing a unique property and target being tweened.
             */
            data: any[];

            /**
             * data array doesn't usually change, so we can cache the length
             */
            totalData: number;

            /**
             * If true then duration, delay, etc values are all frame totals.
             */
            useFrames: boolean;

            /**
             * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
             */
            timeScale: number;

            /**
             * Loop this tween? Can be -1 for an infinite loop, or an integer.
             * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)
             */
            loop: number;

            /**
             * Time in ms/frames before the tween loops.
             */
            loopDelay: number;

            /**
             * How many loops are left to run?
             */
            loopCounter: number;

            /**
             * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)
             */
            completeDelay: number;

            /**
             * Countdown timer (used by loopDelay and completeDelay)
             */
            countdown: number;

            /**
             * The current state of the tween
             */
            state: integer;

            /**
             * Does the Tween start off paused? (if so it needs to be started with Tween.play)
             */
            paused: boolean;

            /**
             * Elapsed time in ms/frames of this run through the Tween.
             */
            elapsed: number;

            /**
             * Total elapsed time in ms/frames of the entire Tween, including looping.
             */
            totalElapsed: number;

            /**
             * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.
             */
            duration: number;

            /**
             * Value between 0 and 1. The amount through the Tween, excluding loops.
             */
            progress: number;

            /**
             * Time in ms/frames for all Tweens to complete (including looping)
             */
            totalDuration: number;

            /**
             * Value between 0 and 1. The amount through the entire Tween, including looping.
             */
            totalProgress: number;

            /**
             * [description]
             * @param value [description]
             */
            setTimeScale(value: number): Phaser.Tweens.Timeline;

            /**
             * [description]
             */
            getTimeScale(): number;

            /**
             * [description]
             */
            isPlaying(): boolean;

            /**
             * [description]
             * @param config [description]
             */
            add(config: object): Phaser.Tweens.Timeline;

            /**
             * [description]
             * @param tween [description]
             */
            queue(tween: Phaser.Tweens.Tween): Phaser.Tweens.Timeline;

            /**
             * [description]
             * @param tween [description]
             */
            hasOffset(tween: Phaser.Tweens.Tween): boolean;

            /**
             * [description]
             * @param value [description]
             */
            isOffsetAbsolute(value: number): boolean;

            /**
             * [description]
             * @param value [description]
             */
            isOffsetRelative(value: string): boolean;

            /**
             * [description]
             * @param value [description]
             * @param base [description]
             */
            getRelativeOffset(value: string, base: number): number;

            /**
             * [description]
             */
            calcDuration(): void;

            /**
             * [description]
             */
            init(): boolean;

            /**
             * [description]
             * @param resetFromLoop [description]
             */
            resetTweens(resetFromLoop: boolean): void;

            /**
             * [description]
             * @param type [description]
             * @param callback [description]
             * @param params [description]
             * @param scope [description]
             */
            setCallback(type: string, callback: Function, params?: any[], scope?: object): Phaser.Tweens.Timeline;

            /**
             * Delegates #makeActive to the Tween manager.
             * @param tween The tween object to make active.
             */
            makeActive(tween: Phaser.Tweens.Tween): Phaser.Tweens.TweenManager;

            /**
             * [description]
             */
            play(): void;

            /**
             * [description]
             */
            nextState(): void;

            /**
             * Returns 'true' if this Timeline has finished and should be removed from the Tween Manager.
             * Otherwise, returns false.
             * @param timestamp [description]
             * @param delta [description]
             */
            update(timestamp: number, delta: number): boolean;

            /**
             * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.
             */
            stop(): void;

            /**
             * [description]
             */
            pause(): Phaser.Tweens.Timeline;

            /**
             * [description]
             */
            resume(): Phaser.Tweens.Timeline;

            /**
             * [description]
             * @param target [description]
             */
            hasTarget(target: object): boolean;

            /**
             * [description]
             */
            destroy(): void;

        }

        /**
         * TweenData state.
         */
        var CREATED: integer;

        /**
         * TweenData state.
         */
        var INIT: integer;

        /**
         * TweenData state.
         */
        var DELAY: integer;

        /**
         * TweenData state.
         */
        var OFFSET_DELAY: integer;

        /**
         * TweenData state.
         */
        var PENDING_RENDER: integer;

        /**
         * TweenData state.
         */
        var PLAYING_FORWARD: integer;

        /**
         * TweenData state.
         */
        var PLAYING_BACKWARD: integer;

        /**
         * TweenData state.
         */
        var HOLD_DELAY: integer;

        /**
         * TweenData state.
         */
        var REPEAT_DELAY: integer;

        /**
         * TweenData state.
         */
        var COMPLETE: integer;

        /**
         * Tween state.
         */
        var PENDING_ADD: integer;

        /**
         * Tween state.
         */
        var PAUSED: integer;

        /**
         * Tween state.
         */
        var LOOP_DELAY: integer;

        /**
         * Tween state.
         */
        var ACTIVE: integer;

        /**
         * Tween state.
         */
        var COMPLETE_DELAY: integer;

        /**
         * Tween state.
         */
        var PENDING_REMOVE: integer;

        /**
         * Tween state.
         */
        var REMOVED: integer;

        type TweenConfigDefaults = {
            /**
             * [description]
             */
            targets: object | object[];
            /**
             * [description]
             */
            delay?: number;
            /**
             * [description]
             */
            duration?: number;
            /**
             * [description]
             */
            ease?: string;
            /**
             * [description]
             */
            easeParams?: any[];
            /**
             * [description]
             */
            hold?: number;
            /**
             * [description]
             */
            repeat?: number;
            /**
             * [description]
             */
            repeatDelay?: number;
            /**
             * [description]
             */
            yoyo?: boolean;
            /**
             * [description]
             */
            flipX?: boolean;
            /**
             * [description]
             */
            flipY?: boolean;
        };

        /**
         * [description]
         */
        class Tween {
            /**
             * 
             * @param parent [description]
             * @param data [description]
             * @param targets [description]
             */
            constructor(parent: Phaser.Tweens.TweenManager | Phaser.Tweens.Timeline, data: Phaser.Tweens.TweenDataConfig[], targets: any[]);

            /**
             * [description]
             */
            parent: Phaser.Tweens.TweenManager | Phaser.Tweens.Timeline;

            /**
             * Is the parent of this Tween a Timeline?
             */
            parentIsTimeline: boolean;

            /**
             * An array of TweenData objects, each containing a unique property and target being tweened.
             */
            data: Phaser.Tweens.TweenDataConfig[];

            /**
             * data array doesn't change, so we can cache the length
             */
            totalData: integer;

            /**
             * An array of references to the target/s this Tween is operating on
             */
            targets: object[];

            /**
             * Cached target total (not necessarily the same as the data total)
             */
            totalTargets: integer;

            /**
             * If true then duration, delay, etc values are all frame totals.
             */
            useFrames: boolean;

            /**
             * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.
             * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.
             */
            timeScale: number;

            /**
             * Loop this tween? Can be -1 for an infinite loop, or an integer.
             * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)
             */
            loop: number;

            /**
             * Time in ms/frames before the tween loops.
             */
            loopDelay: number;

            /**
             * How many loops are left to run?
             */
            loopCounter: number;

            /**
             * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)
             */
            completeDelay: number;

            /**
             * Countdown timer (used by timeline offset, loopDelay and completeDelay)
             */
            countdown: number;

            /**
             * Set only if this Tween is part of a Timeline.
             */
            offset: number;

            /**
             * Set only if this Tween is part of a Timeline. The calculated offset amount.
             */
            calculatedOffset: number;

            /**
             * The current state of the tween
             */
            state: integer;

            /**
             * Does the Tween start off paused? (if so it needs to be started with Tween.play)
             */
            paused: boolean;

            /**
             * Elapsed time in ms/frames of this run through the Tween.
             */
            elapsed: number;

            /**
             * Total elapsed time in ms/frames of the entire Tween, including looping.
             */
            totalElapsed: number;

            /**
             * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.
             */
            duration: number;

            /**
             * Value between 0 and 1. The amount through the Tween, excluding loops.
             */
            progress: number;

            /**
             * Time in ms/frames for the Tween to complete (including looping)
             */
            totalDuration: number;

            /**
             * Value between 0 and 1. The amount through the entire Tween, including looping.
             */
            totalProgress: number;

            /**
             * An object containing the various Tween callback references.
             */
            callbacks: object;

            /**
             * [description]
             */
            getValue(): number;

            /**
             * [description]
             * @param value [description]
             */
            setTimeScale(value: number): Phaser.Tweens.Tween;

            /**
             * [description]
             */
            getTimeScale(): number;

            /**
             * [description]
             */
            isPlaying(): boolean;

            /**
             * [description]
             */
            isPaused(): boolean;

            /**
             * [description]
             * @param target [description]
             */
            hasTarget(target: object): boolean;

            /**
             * [description]
             * @param key [description]
             * @param value [description]
             * @param startToCurrent [description]
             */
            updateTo(key: string, value: any, startToCurrent: boolean): Phaser.Tweens.Tween;

            /**
             * [description]
             */
            restart(): void;

            /**
             * [description]
             */
            calcDuration(): void;

            /**
             * Called by TweenManager.preUpdate as part of its loop to check pending and active tweens.
             * Should not be called directly.
             */
            init(): boolean;

            /**
             * [description]
             */
            nextState(): void;

            /**
             * [description]
             */
            pause(): Phaser.Tweens.Tween;

            /**
             * [description]
             * @param resetFromTimeline [description]
             */
            play(resetFromTimeline: boolean): void;

            /**
             * [description]
             * @param resetFromLoop [description]
             */
            resetTweenData(resetFromLoop: boolean): void;

            /**
             * [description]
             */
            resume(): Phaser.Tweens.Tween;

            /**
             * [description]
             * @param toPosition A value between 0 and 1.
             */
            seek(toPosition: number): void;

            /**
             * [description]
             * @param type [description]
             * @param callback [description]
             * @param params [description]
             * @param scope [description]
             */
            setCallback(type: string, callback: Function, params?: any[], scope?: object): Phaser.Tweens.Tween;

            /**
             * Flags the Tween as being complete, whatever stage of progress it is at.
             * 
             * If an onComplete callback has been defined it will automatically invoke it, unless a `delay`
             * argument is provided, in which case the Tween will delay for that period of time before calling the callback.
             * 
             * If you don't need a delay, or have an onComplete callback, then call `Tween.stop` instead.
             * @param delay The time to wait before invoking the complete callback. If zero it will fire immediately. Default 0.
             */
            complete(delay?: number): void;

            /**
             * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.
             * @param resetTo A value between 0 and 1.
             */
            stop(resetTo?: number): void;

            /**
             * [description]
             * @param timestamp [description]
             * @param delta [description]
             */
            update(timestamp: number, delta: number): boolean;

            /**
             * [description]
             * @param tween [description]
             * @param tweenData [description]
             * @param diff [description]
             */
            setStateFromEnd(tween: Phaser.Tweens.Tween, tweenData: Phaser.Tweens.TweenDataConfig, diff: number): integer;

            /**
             * Was PLAYING_BACKWARD and has hit the start.
             * @param tween [description]
             * @param tweenData [description]
             * @param diff [description]
             */
            setStateFromStart(tween: Phaser.Tweens.Tween, tweenData: Phaser.Tweens.TweenDataConfig, diff: number): integer;

            /**
             * [description]
             * @param tween [description]
             * @param tweenData [description]
             * @param delta Either a value in ms, or 1 if Tween.useFrames is true
             */
            updateTweenData(tween: Phaser.Tweens.Tween, tweenData: Phaser.Tweens.TweenDataConfig, delta: number): boolean;

        }

        type TweenDataConfig = {
            /**
             * The target to tween.
             */
            target: object;
            /**
             * The property of the target being tweened.
             */
            key: string;
            /**
             * The returned value sets what the property will be at the END of the Tween.
             */
            getEndValue: Function;
            /**
             * The returned value sets what the property will be at the START of the Tween.
             */
            getStartValue: Function;
            /**
             * The ease function this tween uses.
             */
            ease: Function;
            /**
             * Duration of the tween in ms/frames, excludes time for yoyo or repeats.
             */
            duration?: number;
            /**
             * The total calculated duration of this TweenData (based on duration, repeat, delay and yoyo)
             */
            totalDuration?: number;
            /**
             * Time in ms/frames before tween will start.
             */
            delay?: number;
            /**
             * Cause the tween to return back to its start value after hold has expired.
             */
            yoyo?: boolean;
            /**
             * Time in ms/frames the tween will pause before running the yoyo or starting a repeat.
             */
            hold?: number;
            /**
             * Number of times to repeat the tween. The tween will always run once regardless, so a repeat value of '1' will play the tween twice.
             */
            repeat?: integer;
            /**
             * Time in ms/frames before the repeat will start.
             */
            repeatDelay?: number;
            /**
             * Automatically call toggleFlipX when the TweenData yoyos or repeats
             */
            flipX?: boolean;
            /**
             * Automatically call toggleFlipY when the TweenData yoyos or repeats
             */
            flipY?: boolean;
            /**
             * Between 0 and 1 showing completion of this TweenData.
             */
            progress?: number;
            /**
             * Delta counter
             */
            elapsed?: number;
            /**
             * How many repeats are left to run?
             */
            repeatCounter?: integer;
            /**
             * Ease value data.
             */
            start?: number;
            /**
             * Ease value data.
             */
            current?: number;
            /**
             * Ease value data.
             */
            end?: number;
            /**
             * Time duration 1.
             */
            t1?: number;
            /**
             * Time duration 2.
             */
            t2?: number;
            /**
             * LoadValue generation functions.
             */
            gen?: TweenDataGenConfig;
            /**
             * TWEEN_CONST.CREATED
             */
            state?: integer;
        };

        /**
         * [description]
         * @param target [description]
         * @param key [description]
         * @param getEnd [description]
         * @param getStart [description]
         * @param ease [description]
         * @param delay [description]
         * @param duration [description]
         * @param yoyo [description]
         * @param hold [description]
         * @param repeat [description]
         * @param repeatDelay [description]
         * @param flipX [description]
         * @param flipY [description]
         */
        function TweenData(target: object, key: string, getEnd: Function, getStart: Function, ease: Function, delay: number, duration: number, yoyo: boolean, hold: number, repeat: number, repeatDelay: number, flipX: boolean, flipY: boolean): TweenDataConfig;

        /**
         * [description]
         */
        class TweenManager {
            /**
             * 
             * @param scene [description]
             */
            constructor(scene: Phaser.Scene);

            /**
             * [description]
             */
            scene: Phaser.Scene;

            /**
             * [description]
             */
            systems: Phaser.Scenes.Systems;

            /**
             * [description]
             */
            timeScale: number;

            /**
             * Create a Tween Timeline and return it, but do NOT add it to the active or pending Tween lists.
             * @param config [description]
             */
            createTimeline(config: object): Phaser.Tweens.Timeline;

            /**
             * Create a Tween Timeline and add it to the active Tween list/
             * @param config [description]
             */
            timeline(config: object): Phaser.Tweens.Timeline;

            /**
             * Create a Tween and return it, but do NOT add it to the active or pending Tween lists.
             * @param config [description]
             */
            create(config: object): Phaser.Tweens.Tween;

            /**
             * Create a Tween and add it to the active Tween list.
             * @param config [description]
             */
            add(config: object): Phaser.Tweens.Tween;

            /**
             * Add an existing tween into the active Tween list.
             * @param tween [description]
             */
            existing(tween: Phaser.Tweens.Tween): Phaser.Tweens.TweenManager;

            /**
             * Create a Tween and add it to the active Tween list.
             * @param config [description]
             */
            addCounter(config: object): Phaser.Tweens.Tween;

            /**
             * [description]
             */
            preUpdate(): void;

            /**
             * [description]
             * @param timestamp [description]
             * @param delta [description]
             */
            update(timestamp: number, delta: number): void;

            /**
             * [description]
             * @param tween [description]
             */
            makeActive(tween: Phaser.Tweens.Tween): Phaser.Tweens.TweenManager;

            /**
             * Passes all Tweens to the given callback.
             * @param callback [description]
             * @param scope [description]
             * @param args [description]
             */
            each(callback: Function, scope?: object, ...args: any[]): void;

            /**
             * [description]
             */
            getAllTweens(): Phaser.Tweens.Tween[];

            /**
             * [description]
             */
            getGlobalTimeScale(): number;

            /**
             * [description]
             * @param target [description]
             */
            getTweensOf(target: object | any[]): Phaser.Tweens.Tween[];

            /**
             * [description]
             * @param target [description]
             */
            isTweening(target: object): boolean;

            /**
             * [description]
             */
            killAll(): Phaser.Tweens.TweenManager;

            /**
             * [description]
             * @param target [description]
             */
            killTweensOf(target: object | any[]): Phaser.Tweens.TweenManager;

            /**
             * [description]
             */
            pauseAll(): Phaser.Tweens.TweenManager;

            /**
             * [description]
             */
            resumeAll(): Phaser.Tweens.TweenManager;

            /**
             * [description]
             * @param value [description]
             */
            setGlobalTimeScale(value: number): Phaser.Tweens.TweenManager;

            /**
             * The Scene that owns this plugin is shutting down.
             * We need to kill and reset all internal properties as well as stop listening to Scene events.
             */
            shutdown(): void;

            /**
             * The Scene that owns this plugin is being destroyed.
             * We need to shutdown and then kill off all external references.
             */
            destroy(): void;

        }

    }

    namespace Utils {
        namespace Array {
            /**
             * Adds the given item, or array of items, to the array.
             * 
             * Each item must be unique within the array.
             * 
             * The array is modified in-place and returned.
             * 
             * You can optionally specify a limit to the maximum size of the array. If the quantity of items being
             * added will take the array length over this limit, it will stop adding once the limit is reached.
             * 
             * You can optionally specify a callback to be invoked for each item successfully added to the array.
             * @param array The array to be added to.
             * @param item The item, or array of items, to add to the array. Each item must be unique within the array.
             * @param limit Optional limit which caps the size of the array.
             * @param callback A callback to be invoked for each item successfully added to the array.
             * @param context The context in which the callback is invoked.
             */
            function Add(array: any[], item: any | any[], limit?: integer, callback?: Function, context?: object): any[];

            /**
             * Adds the given item, or array of items, to the array starting at the index specified.
             * 
             * Each item must be unique within the array.
             * 
             * Existing elements in the array are shifted up.
             * 
             * The array is modified in-place and returned.
             * 
             * You can optionally specify a limit to the maximum size of the array. If the quantity of items being
             * added will take the array length over this limit, it will stop adding once the limit is reached.
             * 
             * You can optionally specify a callback to be invoked for each item successfully added to the array.
             * @param array The array to be added to.
             * @param item The item, or array of items, to add to the array.
             * @param index The index in the array where the item will be inserted. Default 0.
             * @param limit Optional limit which caps the size of the array.
             * @param callback A callback to be invoked for each item successfully added to the array.
             * @param context The context in which the callback is invoked.
             */
            function AddAt(array: any[], item: any | any[], index?: integer, limit?: integer, callback?: Function, context?: object): any[];

            /**
             * Moves the given element to the top of the array.
             * The array is modified in-place.
             * @param array The array.
             * @param item The element to move.
             */
            function BringToTop(array: any[], item: any): any;

            /**
             * Returns the total number of elements in the array which have a property matching the given value.
             * @param array The array to search.
             * @param property The property to test on each array element.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from.
             * @param endIndex An optional end index to search to.
             */
            function CountAllMatching(array: any[], property: string, value: any, startIndex?: integer, endIndex?: integer): integer;

            /**
             * Passes each element in the array to the given callback.
             * @param array The array to search.
             * @param callback A callback to be invoked for each item in the array.
             * @param context The context in which the callback is invoked.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            function Each(array: any[], callback: Function, context: object, ...args: any[]): any[];

            /**
             * Passes each element in the array, between the start and end indexes, to the given callback.
             * @param array The array to search.
             * @param callback A callback to be invoked for each item in the array.
             * @param context The context in which the callback is invoked.
             * @param startIndex The start index to search from.
             * @param endIndex The end index to search to.
             * @param args Additional arguments that will be passed to the callback, after the child.
             */
            function EachInRange(array: any[], callback: Function, context: object, startIndex: integer, endIndex: integer, ...args: any[]): any[];

            /**
             * [description]
             * @param value The value to search for in the array.
             * @param array The array to search, which must be sorted.
             * @param key An optional property key. If specified the array elements property will be checked against value.
             */
            function FindClosestInSorted(value: number, array: any[], key?: string): number | object;

            /**
             * Returns all elements in the array.
             * 
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             * 
             * For example: `getAll('visible', true)` would return only elements that have their visible property set.
             * 
             * Optionally you can specify a start and end index. For example if the array had 100 elements,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would return matches from only
             * the first 50 elements.
             * @param array The array to search.
             * @param property The property to test on each array element.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from.
             * @param endIndex An optional end index to search to.
             */
            function GetAll(array: any[], property?: string, value?: any, startIndex?: integer, endIndex?: integer): any[];

            /**
             * Returns the first element in the array.
             * 
             * You can optionally specify a matching criteria using the `property` and `value` arguments.
             * 
             * For example: `getAll('visible', true)` would return the first element that had its `visible` property set.
             * 
             * Optionally you can specify a start and end index. For example if the array had 100 elements,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would search only the first 50 elements.
             * @param array The array to search.
             * @param property The property to test on each array element.
             * @param value The value to test the property against. Must pass a strict (`===`) comparison check.
             * @param startIndex An optional start index to search from. Default 0.
             * @param endIndex An optional end index to search up to (but not included) Default array.length.
             */
            function GetFirst(array: any[], property?: string, value?: any, startIndex?: integer, endIndex?: integer): object;

            /**
             * Returns a Random element from the array.
             * @param array The array to select the random entry from.
             * @param startIndex An optional start index. Default 0.
             * @param length An optional length, the total number of elements (from the startIndex) to choose from. Default array.length.
             */
            function GetRandom(array: any[], startIndex?: integer, length?: integer): object;

            namespace Matrix {
                /**
                 * [description]
                 * @param matrix [description]
                 */
                function CheckMatrix(matrix: any[]): boolean;

                /**
                 * [description]
                 * @param matrix [description]
                 */
                function MatrixToString(matrix: any[]): string;

                /**
                 * [description]
                 * @param matrix [description]
                 */
                function ReverseColumns(matrix: any[]): any[];

                /**
                 * [description]
                 * @param matrix [description]
                 */
                function ReverseRows(matrix: any[]): any[];

                /**
                 * [description]
                 * @param matrix [description]
                 */
                function Rotate180(matrix: any[]): any[];

                /**
                 * [description]
                 * @param matrix [description]
                 */
                function RotateLeft(matrix: any[]): any[];

                /**
                 * [description]
                 * @param matrix The array to rotate.
                 * @param direction The amount to rotate the matrix by. The value can be given in degrees: 90, -90, 270, -270 or 180, or a string command: `rotateLeft`, `rotateRight` or `rotate180`. Default 90.
                 */
                function RotateMatrix(matrix: any[], direction?: number | string): any[];

                /**
                 * [description]
                 * @param matrix [description]
                 */
                function RotateRight(matrix: any[]): any[];

                /**
                 * [description]
                 * @param array The array matrix to transpose.
                 */
                function TransposeMatrix(array: any[]): any[];

            }

            /**
             * Moves the given array element down one place in the array.
             * The array is modified in-place.
             * @param array The input array.
             * @param item The element to move down the array.
             */
            function MoveDown(array: any[], item: any): any[];

            /**
             * Moves an element in an array to a new position within the same array.
             * The array is modified in-place.
             * @param array The array.
             * @param item The element to move.
             * @param index The new index that the element will be moved to.
             */
            function MoveTo(array: any[], item: any, index: integer): any;

            /**
             * Moves the given array element up one place in the array.
             * The array is modified in-place.
             * @param array The input array.
             * @param item The element to move up the array.
             */
            function MoveUp(array: any[], item: any): any[];

            /**
             * Create an array representing the range of numbers (usually integers), between, and inclusive of,
             * the given `start` and `end` arguments. For example:
             * 
             * `var array = numberArray(2, 4); // array = [2, 3, 4]`
             * `var array = numberArray(0, 9); // array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
             * 
             * This is equivalent to `numberArrayStep(start, end, 1)`.
             * 
             * You can optionally provide a prefix and / or suffix string. If given the array will contain
             * strings, not integers. For example:
             * 
             * `var array = numberArray(1, 4, 'Level '); // array = ["Level 1", "Level 2", "Level 3", "Level 4"]`
             * `var array = numberArray(5, 7, 'HD-', '.png'); // array = ["HD-5.png", "HD-6.png", "HD-7.png"]`
             * @param start The minimum value the array starts with.
             * @param end The maximum value the array contains.
             * @param prefix Optional prefix to place before the number. If provided the array will contain strings, not integers.
             * @param suffix Optional suffix to place after the number. If provided the array will contain strings, not integers.
             */
            function NumberArray(start: number, end: number, prefix?: string, suffix?: string): number[] | string[];

            /**
             * Create an array of numbers (positive and/or negative) progressing from `start`
             * up to but not including `end` by advancing by `step`.
             * 
             * If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
             * 
             * Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
             * for forward compatibility make sure to pass in actual numbers.
             * @param start The start of the range. Default 0.
             * @param end The end of the range. Default null.
             * @param step The value to increment or decrement by. Default 1.
             */
            function NumberArrayStep(start?: number, end?: number, step?: number): number[];

            /**
             * [description]
             * @param arr [description]
             * @param k [description]
             * @param left [description]
             * @param right [description]
             * @param compare [description]
             */
            function QuickSelect(arr: any[], k: number, left: number, right: number, compare: Function): void;

            /**
             * [description]
             * @param a [description]
             * @param b [description]
             * @param options [description]
             */
            function Range(a: any[], b: any[], options: object): any[];

            /**
             * Removes the given item, or array of items, from the array.
             * 
             * The array is modified in-place.
             * 
             * You can optionally specify a callback to be invoked for each item successfully removed from the array.
             * @param array The array to be modified.
             * @param item The item, or array of items, to be removed from the array.
             * @param callback A callback to be invoked for each item successfully removed from the array.
             * @param context The context in which the callback is invoked.
             */
            function Remove(array: any[], item: any | any[], callback?: Function, context?: object): any | any[];

            /**
             * Removes the item from the given position in the array.
             * 
             * The array is modified in-place.
             * 
             * You can optionally specify a callback to be invoked for the item if it is successfully removed from the array.
             * @param array The array to be modified.
             * @param index The array index to remove the item from. The index must be in bounds or it will throw an error.
             * @param callback A callback to be invoked for the item removed from the array.
             * @param context The context in which the callback is invoked.
             */
            function RemoveAt(array: any[], index: integer, callback?: Function, context?: object): any;

            /**
             * Removes the item within the given range in the array.
             * 
             * The array is modified in-place.
             * 
             * You can optionally specify a callback to be invoked for the item/s successfully removed from the array.
             * @param array The array to be modified.
             * @param startIndex The start index to remove from.
             * @param endIndex The end index to remove to.
             * @param callback A callback to be invoked for the item removed from the array.
             * @param context The context in which the callback is invoked.
             */
            function RemoveBetween(array: any[], startIndex: integer, endIndex: integer, callback?: Function, context?: object): any[];

            /**
             * Removes a random object from the given array and returns it.
             * Will return null if there are no array items that fall within the specified range or if there is no item for the randomly chosen index.
             * @param array The array to removed a random element from.
             * @param start The array index to start the search from. Default 0.
             * @param length Optional restriction on the number of elements to randomly select from. Default array.length.
             */
            function RemoveRandomElement(array: any[], start?: integer, length?: integer): object;

            /**
             * Replaces an element of the array with the new element.
             * The new element cannot already be a member of the array.
             * The array is modified in-place.
             * @param oldChild The element in the array that will be replaced.
             * @param newChild The element to be inserted into the array at the position of `oldChild`.
             */
            function Replace(oldChild: any, newChild: any): boolean;

            /**
             * Moves the element at the start of the array to the end, shifting all items in the process.
             * The "rotation" happens to the left.
             * @param array The array to shift to the left. This array is modified in place.
             * @param total The number of times to shift the array. Default 1.
             */
            function RotateLeft(array: any[], total?: integer): any;

            /**
             * Moves the element at the end of the array to the start, shifting all items in the process.
             * The "rotation" happens to the right.
             * @param array The array to shift to the right. This array is modified in place.
             * @param total The number of times to shift the array. Default 1.
             */
            function RotateRight(array: any[], total?: integer): any;

            /**
             * Tests if the start and end indexes are a safe range for the given array.
             * @param array The array to check.
             * @param startIndex The start index.
             * @param endIndex The end index.
             * @param throwError Throw an error if the range is out of bounds. Default true.
             */
            function SafeRange(array: any[], startIndex: integer, endIndex: integer, throwError?: boolean): boolean;

            /**
             * Moves the given element to the bottom of the array.
             * The array is modified in-place.
             * @param array The array.
             * @param item The element to move.
             */
            function SendToBack(array: any[], item: any): any;

            /**
             * Scans the array for elements with the given property. If found, the property is set to the `value`.
             * 
             * For example: `SetAll('visible', true)` would set all elements that have a `visible` property to `false`.
             * 
             * Optionally you can specify a start and end index. For example if the array had 100 elements,
             * and you set `startIndex` to 0 and `endIndex` to 50, it would update only the first 50 elements.
             * @param array The array to search.
             * @param property The property to test for on each array element.
             * @param value The value to set the property to.
             * @param startIndex An optional start index to search from.
             * @param endIndex An optional end index to search to.
             */
            function SetAll(array: any[], property: string, value: any, startIndex?: integer, endIndex?: integer): any[];

            /**
             * Shuffles the contents of the given array using the Fisher-Yates implementation.
             * 
             * The original array is modified directly and returned.
             * @param array The array to shuffle. This array is modified in place.
             */
            function Shuffle(array: any[]): any[];

            /**
             * Removes a single item from an array and returns it without creating gc, like the native splice does.
             * Based on code by Mike Reinstein.
             * @param array [description]
             * @param index [description]
             */
            function SpliceOne(array: any[], index: integer): any;

            /**
             * Swaps the position of two elements in the given array.
             * The elements must exist in the same array.
             * The array is modified in-place.
             * @param array The input array.
             * @param item1 The first element to swap.
             * @param item2 The second element to swap.
             */
            function Swap(array: any[], item1: any, item2: any): any[];

        }

        /**
         * A NOOP (No Operation) callback function.
         * 
         * Used internally by Phaser when it's more expensive to determine if a callback exists
         * than it is to just invoke an empty function.
         */
        function NOOP(): void;

        namespace Object {
            /**
             * Shallow Object Clone. Will not clone nested objects.
             * @param obj the object from which to clone
             */
            function Clone(obj: object): object;

            /**
             * This is a slightly modified version of http://api.jquery.com/jQuery.extend/
             */
            function Extend(): object;

            /**
             * [description]
             * @param source [description]
             * @param key [description]
             * @param defaultValue [description]
             */
            function GetAdvancedValue(source: object, key: string, defaultValue: any): any;

            /**
             * Finds the key within the top level of the {@link source} object, or returns {@link defaultValue}
             * @param source The object to search
             * @param key The key for the property on source. Must exist at the top level of the source object (no periods)
             * @param defaultValue The default value to use if the key does not exist.
             */
            function GetFastValue(source: object, key: string, defaultValue?: any): any;

            /**
             * [description]
             * @param source [description]
             * @param key [description]
             * @param min [description]
             * @param max [description]
             * @param defaultValue [description]
             */
            function GetMinMaxValue(source: object, key: string, min: number, max: number, defaultValue: number): number;

            /**
             * [description]
             * @param source [description]
             * @param key [description]
             * @param defaultValue [description]
             */
            function GetValue(source: object, key: string, defaultValue: any): any;

            /**
             * Verifies that an object contains all requested keys
             * @param source an object on which to check for key existence
             * @param keys an array of keys to ensure the source object contains
             */
            function HasAll(source: object, keys: string[]): boolean;

            /**
             * Verifies that an object contains at least one of the requested keys
             * @param source an object on which to check for key existence
             * @param keys an array of keys to search the object for
             */
            function HasAny(source: object, keys: string[]): boolean;

            /**
             * [description]
             * @param source [description]
             * @param key [description]
             */
            function HasValue(source: object, key: string): boolean;

            /**
             * This is a slightly modified version of jQuery.isPlainObject.
             * A plain object is an object whose internal class property is [object Object].
             * @param obj The object to inspect.
             */
            function IsPlainObject(obj: object): boolean;

            /**
             * Creates a new Object using all values from obj1 and obj2.
             * If a value exists in both obj1 and obj2, the value in obj1 is used.
             * @param obj1 [description]
             * @param obj2 [description]
             */
            function Merge(obj1: object, obj2: object): object;

            /**
             * Creates a new Object using all values from obj1.
             * 
             * Then scans obj2. If a property is found in obj2 that *also* exists in obj1, the value from obj2 is used, otherwise the property is skipped.
             * @param obj1 [description]
             * @param obj2 [description]
             */
            function MergeRight(obj1: object, obj2: object): object;

        }

        namespace String {
            /**
             * Takes a string and replaces instances of markers with values in the given array.
             * The markers take the form of `%1`, `%2`, etc. I.e.:
             * 
             * `Format("The %1 is worth %2 gold", [ 'Sword', 500 ])`
             * @param string The string containing the replacement markers.
             * @param values An array containing values that will replace the markers. If no value exists an empty string is inserted instead.
             */
            function Format(string: string, values: any[]): string;

            /**
             * Takes the given string and pads it out, to the length required, using the character
             * specified. For example if you need a string to be 6 characters long, you can call:
             * 
             * `pad('bob', 6, '-', 2)`
             * 
             * This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
             * 
             * You can also use it to pad numbers (they are always returned as strings):
             * 
             * `pad(512, 6, '0', 1)`
             * 
             * Would return: `000512` with the string padded to the left.
             * 
             * If you don't specify a direction it'll pad to both sides:
             * 
             * `pad('c64', 7, '*')`
             * 
             * Would return: `**c64**`
             * @param str The target string. `toString()` will be called on the string, which means you can also pass in common data types like numbers.
             * @param len The number of characters to be added. Default 0.
             * @param pad The string to pad it out with (defaults to a space). Default " ".
             * @param dir The direction dir = 1 (left), 2 (right), 3 (both). Default 3.
             */
            function Pad(str: string, len?: integer, pad?: string, dir?: integer): string;

            /**
             * Takes the given string and reverses it, returning the reversed string.
             * For example if given the string `Atari 520ST` it would return `TS025 iratA`.
             * @param string The string to be reversed.
             */
            function ReverseString(string: string): string;

            /**
             * Capitalizes the first letter of a string if there is one.
             * @param str The string to capitalize.
             */
            function UppercaseFirst(str: string): string;

        }

    }

}

declare type ArcadeBodyBounds = {
    /**
     * [description]
     */
    x: number;
    /**
     * [description]
     */
    y: number;
    /**
     * [description]
     */
    right: number;
    /**
     * [description]
     */
    bottom: number;
};

declare type ArcadeBodyCollision = {
    /**
     * [description]
     */
    none: boolean;
    /**
     * [description]
     */
    up: boolean;
    /**
     * [description]
     */
    down: boolean;
    /**
     * [description]
     */
    left: boolean;
    /**
     * [description]
     */
    right: boolean;
};

declare type ArcadePhysicsCallback = (object1: Phaser.GameObjects.GameObject, object2: Phaser.GameObjects.GameObject)=>void;

declare type PhysicsGroupConfig = GroupConfig & {
    /**
     * [description]
     */
    collideWorldBounds?: any;
    /**
     * [description]
     */
    accelerationX?: number;
    /**
     * [description]
     */
    accelerationY?: number;
    /**
     * [description]
     */
    bounceX?: number;
    /**
     * [description]
     */
    bounceY?: number;
    /**
     * [description]
     */
    dragX?: number;
    /**
     * [description]
     */
    dragY?: number;
    /**
     * [description]
     */
    gravityX?: number;
    /**
     * [description]
     */
    gravityY?: number;
    /**
     * [description]
     */
    frictionX?: number;
    /**
     * [description]
     */
    frictionY?: number;
    /**
     * [description]
     */
    velocityX?: number;
    /**
     * [description]
     */
    velocityY?: number;
    /**
     * [description]
     */
    angularVelocity?: number;
    /**
     * [description]
     */
    angularAcceleration?: number;
    /**
     * [description]
     */
    angularDrag?: number;
    /**
     * [description]
     */
    mass?: number;
    /**
     * [description]
     */
    immovable?: boolean;
};

declare type PhysicsGroupDefaults = {
    /**
     * [description]
     */
    setCollideWorldBounds: any;
    /**
     * [description]
     */
    setAccelerationX: number;
    /**
     * [description]
     */
    setAccelerationY: number;
    /**
     * [description]
     */
    setBounceX: number;
    /**
     * [description]
     */
    setBounceY: number;
    /**
     * [description]
     */
    setDragX: number;
    /**
     * [description]
     */
    setDragY: number;
    /**
     * [description]
     */
    setGravityX: number;
    /**
     * [description]
     */
    setGravityY: number;
    /**
     * [description]
     */
    setFrictionX: number;
    /**
     * [description]
     */
    setFrictionY: number;
    /**
     * [description]
     */
    setVelocityX: number;
    /**
     * [description]
     */
    setVelocityY: number;
    /**
     * [description]
     */
    setAngularVelocity: number;
    /**
     * [description]
     */
    setAngularAcceleration: number;
    /**
     * [description]
     */
    setAngularDrag: number;
    /**
     * [description]
     */
    setMass: number;
    /**
     * [description]
     */
    setImmovable: boolean;
};

declare type ArcadeWorldConfig = {
    /**
     * [description]
     */
    gravity?: object;
    /**
     * [description]
     */
    "gravity.x"?: number;
    /**
     * [description]
     */
    "gravity.y"?: number;
    /**
     * [description]
     */
    x?: number;
    /**
     * [description]
     */
    y?: number;
    /**
     * [description]
     */
    width?: number;
    /**
     * [description]
     */
    height?: number;
    /**
     * [description]
     */
    checkCollision?: object;
    /**
     * [description]
     */
    "checkCollision.up"?: boolean;
    /**
     * [description]
     */
    "checkCollision.down"?: boolean;
    /**
     * [description]
     */
    "checkCollision.left"?: boolean;
    /**
     * [description]
     */
    "checkCollision.right"?: boolean;
    /**
     * [description]
     */
    overlapBias?: number;
    /**
     * [description]
     */
    tileBias?: number;
    /**
     * [description]
     */
    forceX?: boolean;
    /**
     * [description]
     */
    isPaused?: boolean;
    /**
     * [description]
     */
    debug?: boolean;
    /**
     * [description]
     */
    debugShowBody?: boolean;
    /**
     * [description]
     */
    debugShowStaticBody?: boolean;
    /**
     * [description]
     */
    debugShowVelocity?: boolean;
    /**
     * [description]
     */
    debugBodyColor?: number;
    /**
     * [description]
     */
    debugStaticBodyColor?: number;
    /**
     * [description]
     */
    debugVelocityColor?: number;
    /**
     * [description]
     */
    maxEntries?: number;
};

declare type CheckCollisionObject = {
    /**
     * [description]
     */
    up: boolean;
    /**
     * [description]
     */
    down: boolean;
    /**
     * [description]
     */
    left: boolean;
    /**
     * [description]
     */
    right: boolean;
};

declare type ArcadeWorldDefaults = {
    /**
     * [description]
     */
    debugShowBody: boolean;
    /**
     * [description]
     */
    debugShowStaticBody: boolean;
    /**
     * [description]
     */
    debugShowVelocity: boolean;
    /**
     * [description]
     */
    bodyDebugColor: number;
    /**
     * [description]
     */
    staticBodyDebugColor: number;
    /**
     * [description]
     */
    velocityDebugColor: number;
};

declare type ArcadeWorldTreeMinMax = {
    /**
     * [description]
     */
    minX: number;
    /**
     * [description]
     */
    minY: number;
    /**
     * [description]
     */
    maxX: number;
    /**
     * [description]
     */
    maxY: number;
};

declare type BodyUpdateCallback = (body: Phaser.Physics.Impact.Body)=>void;

declare type JSONImpactBody = {
    /**
     * [description]
     */
    name: string;
    /**
     * [description]
     */
    size: object;
    /**
     * [description]
     */
    pos: object;
    /**
     * [description]
     */
    vel: object;
    /**
     * [description]
     */
    accel: object;
    /**
     * [description]
     */
    friction: object;
    /**
     * [description]
     */
    maxVel: object;
    /**
     * [description]
     */
    gravityFactor: number;
    /**
     * [description]
     */
    bounciness: number;
    /**
     * [description]
     */
    minBounceVelocity: number;
    /**
     * [description]
     */
    type: Phaser.Physics.Impact.TYPE;
    /**
     * [description]
     */
    checkAgainst: Phaser.Physics.Impact.TYPE;
    /**
     * [description]
     */
    collides: Phaser.Physics.Impact.COLLIDES;
};

declare type CollideCallback = (body: Phaser.Physics.Impact.Body, other: Phaser.Physics.Impact.Body, axis: string)=>void;

declare namespace MatterJS {
    /**
     * The `Matter.Body` module contains methods for creating and manipulating body models.
     * 
     * A `Matter.Body` is a rigid body that can be simulated by a `Matter.Engine`.
     * 
     * Factories for commonly used body configurations (such as rectangles, circles and other polygons) can be found in the module `Matter.Bodies`.
     */
    class Body {
    }

    /**
     * The `Matter.Composite` module contains methods for creating and manipulating composite bodies.
     * 
     * A composite body is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`, therefore composites form a tree structure.
     * 
     * It is important to use the functions in this module to modify composites, rather than directly modifying their properties.
     * 
     * Note that the `Matter.World` object is also a type of `Matter.Composite` and as such all composite methods here can also operate on a `Matter.World`.
     */
    class Composite {
    }

    /**
     * The `Matter.World` module contains methods for creating and manipulating the world composite.
     * 
     * A `Matter.World` is a `Matter.Composite` body, which is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite`.
     * 
     * A `Matter.World` has a few additional properties including `gravity` and `bounds`.
     * 
     * It is important to use the functions in the `Matter.Composite` module to modify the world composite, rather than directly modifying its properties.
     * 
     * There are also a few methods here that alias those in `Matter.Composite` for easier readability.
     */
    class World extends MatterJS.Composite {
    }

    /**
     * The `Matter.Constraint` module contains methods for creating and manipulating constraints.
     * 
     * Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).
     * 
     * The stiffness of constraints can be modified to create springs or elastic.
     */
    class Constraint {
    }

    /**
     * The `Matter.Engine` module contains methods for creating and manipulating engines.
     * 
     * An engine is a controller that manages updating the simulation of the world.
     */
    class Engine {
    }

}

declare type RendererConfig = {
    /**
     * [description]
     */
    clearBeforeRender: boolean;
    /**
     * [description]
     */
    pixelArt: boolean;
    /**
     * [description]
     */
    backgroundColor: Phaser.Display.Color;
    /**
     * [description]
     */
    resolution: number;
    /**
     * [description]
     */
    autoResize: boolean;
    /**
     * [description]
     */
    roundPixels: boolean;
};

declare type SnapshotCallback = (snapshot: HTMLImageElement)=>void;

declare type WebGLContextCallback = (renderer: Phaser.Renderer.WebGL.WebGLRenderer)=>void;

declare type SnapshotState = {
    /**
     * [description]
     */
    callback: SnapshotCallback;
    /**
     * [description]
     */
    type: string;
    /**
     * [description]
     */
    encoder: number;
};

declare namespace Phaser.Scenes.ScenePlugin {
    type SceneTransitionConfig = {
        /**
         * The Scene key to transition to.
         */
        target: string;
        /**
         * The duration, in ms, for the transition to last.
         */
        duration?: integer;
        /**
         * Will the Scene responsible for the transition be sent to sleep on completion (`true`), or stopped? (`false`)
         */
        sleep?: boolean;
        /**
         * Will the Scenes Input system be able to process events while it is transitioning in or out?
         */
        allowInput?: boolean;
        /**
         * More the target Scene to be above this one before the transition starts.
         */
        moveAbove?: boolean;
        /**
         * More the target Scene to be below this one before the transition starts.
         */
        moveBelow?: boolean;
        /**
         * This callback is invoked every frame for the duration of the transition.
         */
        onUpdate?: Function;
        /**
         * The context in which the callback is invoked.
         */
        onUpdateScope?: any;
        /**
         * An object containing any data you wish to be passed to the target Scenes init / create methods.
         */
        data?: any;
    };

}

declare type EachActiveSoundCallback = (manager: Phaser.Sound.BaseSoundManager, sound: Phaser.Sound.BaseSound, index: number, sounds: Phaser.Sound.BaseSound[])=>void;

declare namespace Phaser.Sound.BaseSound {
    /**
     * Audio sprite sound type.
     */
    type AudioSpriteSound = ()=>void;

}

/**
 * Config object containing various sound settings.
 */
declare type SoundConfig = {
    /**
     * Boolean indicating whether the sound should be muted or not.
     */
    mute?: boolean;
    /**
     * A value between 0 (silence) and 1 (full volume).
     */
    volume?: number;
    /**
     * Defines the speed at which the sound should be played.
     */
    rate?: number;
    /**
     * Represents detuning of sound in [cents](https://en.wikipedia.org/wiki/Cent_%28music%29).
     */
    detune?: number;
    /**
     * Position of playback for this sound, in seconds.
     */
    seek?: number;
    /**
     * Whether or not the sound or current sound marker should loop.
     */
    loop?: boolean;
    /**
     * Time, in seconds, that should elapse before the sound actually starts its playback.
     */
    delay?: number;
};

/**
 * Marked section of a sound represented by name, and optionally start time, duration, and config object.
 */
declare type SoundMarker = {
    /**
     * Unique identifier of a sound marker.
     */
    name: string;
    /**
     * Sound position offset at witch playback should start.
     */
    start?: number;
    /**
     * Playback duration of this marker.
     */
    duration?: number;
    /**
     * An optional config object containing default marker settings.
     */
    config?: SoundConfig;
};

declare type EachListCallback<I> = (item: any, ...args: any[])=>void;

declare type EachMapCallback<E> = (key: string, entry: any)=>void;

declare type EachSetCallback<E> = (entry: any, index: number)=>void;

declare type EachTextureCallback = (texture: Phaser.Textures.Texture, ...args: any[])=>void;

declare type SpriteSheetConfig = {
    /**
     * The fixed width of each frame.
     */
    frameWidth: integer;
    /**
     * The fixed height of each frame. If not set it will use the frameWidth as the height.
     */
    frameHeight?: integer;
    /**
     * Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     */
    startFrame?: integer;
    /**
     * The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     */
    endFrame?: integer;
    /**
     * If the frames have been drawn with a margin, specify the amount here.
     */
    margin?: integer;
    /**
     * If the frames have been drawn with spacing between them, specify the amount here.
     */
    spacing?: integer;
};

declare type SpriteSheetFromAtlasConfig = {
    /**
     * The key of the Texture Atlas in which this Sprite Sheet can be found.
     */
    atlas: string;
    /**
     * The key of the Texture Atlas Frame in which this Sprite Sheet can be found.
     */
    frame: string;
    /**
     * The fixed width of each frame.
     */
    frameWidth: integer;
    /**
     * The fixed height of each frame. If not set it will use the frameWidth as the height.
     */
    frameHeight?: integer;
    /**
     * Skip a number of frames. Useful when there are multiple sprite sheets in one Texture.
     */
    startFrame?: integer;
    /**
     * The total number of frames to extract from the Sprite Sheet. The default value of -1 means "extract all frames".
     */
    endFrame?: integer;
    /**
     * If the frames have been drawn with a margin, specify the amount here.
     */
    margin?: integer;
    /**
     * If the frames have been drawn with spacing between them, specify the amount here.
     */
    spacing?: integer;
};

declare type FindTileCallback = (value: Phaser.Tilemaps.Tile, index: number, array: Phaser.Tilemaps.Tile[])=>void;

declare type EachTileCallback = (value: Phaser.Tilemaps.Tile, index: number, array: Phaser.Tilemaps.Tile[])=>void;

declare type GetTilesWithinFilteringOptions = {
    /**
     * If true, only return tiles that don't have -1 for an index.
     */
    isNotEmpty?: boolean;
    /**
     * If true, only return tiles that collide on at least one side.
     */
    isColliding?: boolean;
    /**
     * If true, only return tiles that have at least one interesting face.
     */
    hasInterestingFace?: boolean;
};

declare type TilemapFilterCallback = (value: Phaser.GameObjects.GameObject, index: number, array: Phaser.GameObjects.GameObject[])=>void;

declare type TilemapFindCallback = (value: Phaser.GameObjects.GameObject, index: number, array: Phaser.GameObjects.GameObject[])=>void;

declare type TilemapConfig = {
    /**
     * The key in the Phaser cache that corresponds to the loaded tilemap data.
     */
    key?: string;
    /**
     * Instead of loading from the cache, you can also load directly from a 2D array of tile indexes.
     */
    data?: integer[][];
    /**
     * The width of a tile in pixels.
     */
    tileWidth?: integer;
    /**
     * The height of a tile in pixels.
     */
    tileHeight?: integer;
    /**
     * The width of the map in tiles.
     */
    width?: integer;
    /**
     * The height of the map in tiles.
     */
    height?: integer;
    /**
     * Controls how empty tiles, tiles with an index of -1,
     * in the map data are handled. If `true`, empty locations will get a value of `null`. If `false`,
     * empty location will get a Tile object with an index of -1. If you've a large sparsely populated
     * map and the tile data doesn't need to change then setting this value to `true` will help with
     * memory consumption. However if your map is small or you need to update the tiles dynamically,
     * then leave the default value set.
     */
    insertNull?: boolean;
};

declare type TimerEventConfig = {
    /**
     * [description]
     */
    delay?: number;
    /**
     * [description]
     */
    repeat?: number;
    /**
     * [description]
     */
    loop?: boolean;
    /**
     * [description]
     */
    callback?: Function;
    /**
     * [description]
     */
    callbackScope?: any;
    /**
     * [description]
     */
    args?: any[];
    /**
     * [description]
     */
    timeScale?: number;
    /**
     * [description]
     */
    startAt?: number;
    /**
     * [description]
     */
    paused?: boolean;
};

declare type TweenDataGenConfig = {
    /**
     * [description]
     */
    delay: Function;
    /**
     * [description]
     */
    duration: Function;
    /**
     * [description]
     */
    hold: Function;
    /**
     * [description]
     */
    repeat: Function;
    /**
     * [description]
     */
    repeatDelay: Function;
};

/**
 * Class
 */
declare class Class {
    /**
     * 
     * @param definition a dictionary of functions for the class
     */
    constructor(definition: Object);

}

declare type integer = number;

declare module 'phaser' {
    export = Phaser;

}

