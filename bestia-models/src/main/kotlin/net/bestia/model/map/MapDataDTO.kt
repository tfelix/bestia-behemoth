package net.bestia.model.map

import java.io.Serializable
import java.util.ArrayList
import java.util.HashMap
import java.util.Objects

import net.bestia.model.geometry.Point
import net.bestia.model.geometry.Rect

/**
 * This is a map data transfer object. It contains all the needed map data to
 * construct maps or map chunks. It can be easily serialized for binary storage
 * inside the database.
 *
 * It is also used to be directly generated by the map creation algorithms and
 * to be persisted into the database. The [net.bestia.model.map.BestiaMap] class
 * is optimized for storage of the map parts inside the database. The
 * [net.bestia.model.map.BestiaMap] for access by the game and [MapChunk]
 * for transfer to the client system.
 *
 * @see {@link MapChunk}.
 *
 * @author Thomas Felix
 */
class MapDataDTO(rect: Rect) : Serializable {
  /**
   * Returns the rectangular area represented by this map part data.
   *
   * @return The rectangular area of this part of the map.
   */
  val rect: Rect
  private val groundLayer: IntArray
  private val layers = ArrayList<MutableMap<Point, Int>>()

  /**
   * Returns all GIDs which are contained within this [MapDataDTO]. This
   * includes ALL layers of the DTO.
   *
   * @return A set containing all GIDs of the data included in this instance.
   */
  // Now we go over all the over ids and add them to the set.
  val distinctGids: Set<Int>
    get() {
      val gids = groundLayer.toMutableSet()
      val layerGids = layers.flatMap { it.values }.toSet()
      gids.addAll(layerGids)

      return gids
    }

  init {

    this.rect = Objects.requireNonNull(rect)

    val size = (rect.height * rect.width).toInt()
    groundLayer = IntArray(size)

  }

  /**
   * Calculates the index of the x and y coordiante.
   *
   * @param x
   * X coordinate.
   * @param y
   * Y coordiante.
   * @return The index to get the tile out of the internal array.
   */
  private fun getIndex(x: Long, y: Long): Int {
    if (x < 0 || y < 0) {
      throw IllegalArgumentException("X and Y coordinates can not be negative.")
    }

    // First we normalize the coordiantes into map data space.
    val posX = (x - rect.origin.x).toInt()
    val posY = (y - rect.origin.y).toInt()

    return (posY * rect.width).toInt() + posX
  }

  /**
   * Gets the GID from the ground layer.
   *
   * @param x
   * @param y
   * @return
   */
  fun getGroundGid(x: Long, y: Long): Int {
    val index = getIndex(x, y)
    if (index > groundLayer.size) {
      throw IndexOutOfBoundsException("Given coordiantes are not within the data.")
    }

    return groundLayer[index]
  }

  /**
   * Puts the given GID to the given x and y coordinates. The coordinates are
   * GLOBAL map coordinates.
   *
   * @param x
   * Global map x coordinate.
   * @param y
   * Global map y coordinate.
   * @param gid
   * The tile ID of the ground tile.
   */
  fun putGroundLayer(x: Long, y: Long, gid: Int) {
    val index = getIndex(x, y)
    if (index > groundLayer.size) {
      throw IndexOutOfBoundsException("Given coordiantes are not within the data.")
    }

    groundLayer[index] = gid
  }

  /**
   * Returns all layered ids for the given coordiante.
   */
  fun getLayerGids(x: Long, y: Long): List<Int> {
    val p = Point(x, y)
    val gids = ArrayList<Int>()

    for (layer in layers) {
      val lgid = layer.get(p)

      if (lgid != null) {
        gids.add(lgid)
      }
    }

    return gids
  }

  /**
   * Sets a tile id onto a given layer. We must start with layer 1 since layer
   * 0 is the ground layer.
   *
   * @param layer
   * @param x
   * @param y
   * @param gid
   */
  fun putLayer(layer: Int, x: Long, y: Long, gid: Int) {
    // Check if the cords are within this chunkg.
    val p = Point(x, y)

    if (!rect.collide(p)) {
      throw IndexOutOfBoundsException("Given coordiantes are not within the data.")
    }

    if (layers.size < layer) {
      // Extend list to the given layers.
      for (i in layer - layers.size downTo 1) {
        layers.add(HashMap<Point, Int>())
      }
    }

    layers[layer].put(p, gid)
  }

  /**
   * Combines different DTOs into a single one the covered are is extended.
   * The instances can only be joined if they are adjacent to each other. If
   * this is not the case an illegal argument exception is thrown.
   *
   * @param rhs
   * @return
   */
  fun join(rhs: MapDataDTO): MapDataDTO {

    // We can only join same dimensions.
    if (rhs.rect.width != rect.width || rhs.rect.height != rect.height) {
      throw IllegalArgumentException("MapDataDTOs have different sizes. Can not join.")
    }

    val rhsX = rhs.rect.x
    val rhsX2 = rhsX + rhs.rect.width
    val rhsY = rhs.rect.y
    val rhsY2 = rhsY + rhs.rect.height

    val x = rect.x
    val x2 = x + rect.width
    val y = rect.y
    val y2 = y + rect.height

    val totalWidth = rect.width + rhs.rect.width
    val totalHeight = rect.height + rhs.rect.height

    val joinedRect: Rect

    if (x2 + 1 == rhsX && rhsY == y) {
      // RHS is on right quadrant.
      joinedRect = Rect(x, y, totalWidth, rect.height)
    } else if (rhsX2 + 1 == x && rhsY == y) {
      // RHS is on left quadrant.
      joinedRect = Rect(rhsX, rhsY, totalWidth, rect.height)
    } else if (rhsX == x && rhsY == y2 + 1) {
      // RHS is on the bottom quadrant.
      joinedRect = Rect(x, y, rect.width, totalHeight)
    } else if (rhsX == x && rhsY2 + 1 == y) {
      // RHS is on the top quadrant.
      joinedRect = Rect(rhsX, rhsY, rect.width, totalHeight)
    } else {
      // Non overlapping.
      throw IllegalArgumentException("Area is not adjacent to each other.")
    }

    val joinedData = MapDataDTO(joinedRect)

    // Since width must be equal for both arrays.
    val length = rhs.rect.width.toInt()

    // Combine the ground layer data.
    for (i in 0 until y2 - y) {

      val srcPos = i * length
      var destPos = 2 * i * length

      System.arraycopy(groundLayer, srcPos.toInt(), joinedData.groundLayer, destPos.toInt(), length)

      destPos += length

      System.arraycopy(rhs.groundLayer, srcPos.toInt(), joinedData.groundLayer, destPos.toInt(), length)
    }

    // Copy the upper map layers.
    val maxLayer = Math.max(layers.size, rhs.layers.size)

    for (i in 0 until maxLayer) {
      val layer = HashMap<Point, Int>()

      if (layers.size < i) {
        layer.putAll(layers[i])
      }

      if (rhs.layers.size < i) {
        layer.putAll(rhs.layers[i])
      }

      joinedData.layers.add(layer)
    }

    return joinedData
  }

  /**
   * Returns a sliced rect from the [MapDataDTO]. The given rect must be
   * fully inside the are covered by this DTO or an
   * [IllegalArgumentException] is thrown.
   *
   * @return
   */
  fun slice(slice: Rect): MapDataDTO {

    Objects.requireNonNull(rect)
    if (slice.x < rect.x
        || slice.y > rect.y
        || slice.width > rect.width
        || slice.height > rect.height) {
      throw IllegalArgumentException("Slice is bigger then the area covered by the DTO.")
    }

    val sliced = MapDataDTO(slice)

    // This could be possibly done more effectivly. But I am tired for now
    // and this needs to work asap.
    for (y in slice.y until slice.y + slice.height) {
      for (x in slice.x until slice.x + slice.width) {

        val gid = getGroundGid(x, y)
        sliced.putGroundLayer(x, y, gid)

        val layerGids = getLayerGids(x, y)
        var layer = 1

        for (lgid in layerGids) {
          sliced.putLayer(layer, x, y, lgid)
          layer++
        }
      }
    }

    return sliced
  }

  override fun toString(): String {
    return String.format("MapDataDTO[%s]", rect.toString())
  }

  companion object {

    private const val serialVersionUID = 1L
  }
}
