package net.bestia.model.map;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.Map;

import net.bestia.model.geometry.Point;
import net.bestia.model.geometry.Rect;

/**
 * This is a map data transfer object. It contains all the needed map data to
 * construct maps or map chunks. It can be easily serialized for binary storage
 * inside the database.
 * 
 * It is also used to be directly generated by the map creation algorithms and
 * to be persisted into the database. The {@link net.bestia.model.map.Map} class
 * is optimized for storage of the map parts inside the database. The
 * {@link net.bestia.model.map.Map} for access by the game and {@link MapChunk}
 * for transfer to the client system.
 * 
 * @see {@link net.bestia.model.map.Map} {@link MapChunk}.
 * @author Thomas Felix
 *
 */
public class MapDataDTO implements Serializable {

	private static final long serialVersionUID = 1L;
	private final Rect rect;
	private final int[] groundLayer;
	private final List<Map<Point, Integer>> layers = new ArrayList<>();

	public MapDataDTO(Rect rect) {

		this.rect = Objects.requireNonNull(rect);

		int size = (int) (rect.getHeight() * rect.getWidth());
		groundLayer = new int[size];

	}

	/**
	 * Calculates the index of the x and y coordiante.
	 * 
	 * @param x
	 *            X coordinate.
	 * @param y
	 *            Y coordiante.
	 * @return The index to get the tile out of the internal array.
	 */
	private int getIndex(long x, long y) {
		if (x < 0 || y < 0) {
			throw new IllegalArgumentException("X and Y coordinates can not be negative.");
		}

		// First we normalize the coordiantes into map data space.
		int posX = (int) (x - rect.getOrigin().getX());
		int posY = (int) (y - rect.getOrigin().getY());

		return (int) (posY * rect.getWidth()) + posX;
	}

	/**
	 * Gets the GID from the ground layer.
	 * 
	 * @param x
	 * @param y
	 * @return
	 */
	public int getGroundGid(long x, long y) {
		int index = getIndex(x, y);
		if (index > groundLayer.length) {
			throw new IndexOutOfBoundsException("Given coordiantes are not within the data.");
		}

		return groundLayer[index];
	}

	/**
	 * Puts the given GID to the given x and y coordinates.
	 * 
	 * @param x
	 * @param y
	 * @param gid
	 */
	public void putGroundLayer(long x, long y, int gid) {
		int index = getIndex(x, y);
		if (index > groundLayer.length) {
			throw new IndexOutOfBoundsException("Given coordiantes are not within the data.");
		}

		groundLayer[index] = gid;
	}

	public void putLayer(int layer, long x, long y, int gid) {
		// Check if the cords are within this chunkg.
		final Point p = new Point(x, y);
		if (!rect.collide(p)) {
			throw new IndexOutOfBoundsException("Given coordiantes are not within the data.");
		}

		if (layers.size() < layer) {
			// Extend list to the given layers.
			for (int i = layer - layers.size(); i > 0; i--) {
				layers.add(new HashMap<>());
			}
		}

		layers.get(layer).put(p, gid);
	}

	/**
	 * Returns the rectangular area represented by this map part data.
	 * 
	 * @return The rectangular area of this part of the map.
	 */
	public Rect getRect() {
		return rect;
	}

}
