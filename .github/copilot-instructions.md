# Project Overview

This project is an open source MMORPG that presents a huge 3D voxel based game world with lots of interactions.
It uses Spring, Kotlin, Protobuf and MariaDB as the server backend (and focuses on open source technologies). The client
uses the Godot game engine with GDScript, C++ and C#.

## Folder Structure

This is a multi-module gradle project. The Gradle specific files are under the root `/` like `./gradlew.bat` and `./gradlew` .

- `/login-server`: Contains the source code for the login server responsible for user login and authentication logic via JWT.
- `/zone-server`: Contains the source code for the main backend server which manages game state, game logic and network sync.
- `/cli-client`: Contains the source code for a text based, cli client to connect to the server for testing purposes.
into in-game data .
- `/bestia-client`: Contains the Godot engine client code for connecting to the server and playing the game.
- `/bestia-client/src/Bnet/Proto`: Contains the autogenerated protobuf files from the `./gen-protobuf.bat` script. DO NOT TOUCH.
- `/bestia-client/src/Bnet/Message`: Contains the interface messages between Godot engine and the protobuf envelopes. Matching
and Godot engine compatible C# files are put in there.
- `/bestia-client/raw-assets`: Contains the raw data like images, textures and models in their raw form, before they are converted to be used with Godot.
- `/bnet-messages`: Contains protobuf files which describe the message format.
- `/shared`: Is a Gradle module which contains shared code, usually between `login-server` and `zone-server`

# Unit Tests

Follow those guidelines when creating unit tests:

When creating names for the methods make use of Kotlin option for space in names via backticks \`. Use the following
pattern: <NAME_OF_METHOD> <SHORT DESCRIPTION OF WHAT IS TESTED> <EXPECTED OUTPUT>. Example: 'doLogin with an invalid
login throws LoginException'.

Do not @autowire the constructor but use `lateinit var` instead.

**DON'T DO THIS**

```kotlin
@Autowired constructor(
  val restTemplate: TestRestTemplate,
): LoginScenario()
```

**DO THIS**

```kotlin
@Autowired
private lateinit var restTemplate: TestRestTemplate
```

When told to create a test/unit test, do not create a Spring Boot test. Just a regular Junit test. When told to create a
scenario (or explicit a Spring Boot test) create a Spring Boot based test. Check if there is a parent class which you are
supposed to extend for such a test.

For mocking use mockk and extend the Junit 5 classes with `@ExtendWith(MockKExtension::class)`

The object which is tested inside a test should be kept in a class property name `sut` (service under test).

# Extending the Protobuf Message Protocol

## General Guidelines

* Messages send FROM the client TO the server are postfixed with `CMSG` (client message).
* Messages send FROM the server TO the client are postfixed with `SMSG` (server message).
* `envelope.proto` variable names MUST NOT have this postfix. Example: `GetInventoryCMSG get_inventory = 301;`
* For component messages in `envelope.proto` are some special patterns. Inside the `envelope.proto` they look like
this: `BestiaVisualComponentSMSG comp_bestia_visual`. They start with `comp_` but do NOT end with `_component`.

The workflow to add or modify a message goes like this, Point 1 is usually already done:

1. Add the new messages as *.proto files into the respective folders according to the requirement.
2. Add the new messages to the `envelope.proto`.
3. Add the new messages to the `./gen-protobuf.bat` file so their code can be auto-generated.
4. Generate the C# files by executing `./gen-protobuf.bat` (use Windows Powershell command syntax, keep this in mind)
5. Add the interaction and Godot API friendly layer in `/bestia-client/src/Bnet/Message`, by adding the *.cs files. They
translate the Protobuf message in a Godot friendly format. Make sure the message inherit from `EntitySMSG` (when
addressing an entity, entityId present) or ISMSG (when it is a generic message coming from the server) or `ICMSG` when
the message is sent to the server.
6. Make sure the message is also added in the conversion section in `BenetSocket.cs`.
7. Add the messages in the zone server backend. The messages there are placed in a domain aligned module structure where
it makes most sense. But also here they must inherit from their respective `SMSG` or `CMSG` interfaces. Please note that
depending on the interface some implementations must have helper methods which will produce a Bnet (the protobuf envelope)
message when getting called. This must be implemented too. Especially if this conversion is more complex.
8. On the server side you also must also add a handler which derived from `InMessageProcessor.IncomingMessageHandler<T>`.
You can leave the body out and just add a `TODO()`.
9. On the server side you also must adapt the `BnetMessageProcessorAdapter` which will convert from the Bnet protobuf
message into a server internal message format.
10. If its a message from the server to the client (SMSG), on the Godot side also add the message handling code in `connection_manager.gd`. Add an specific event for general messages and emit it on message receive. If it is an entity message it will already get handled via the `entity_received` emitter.

# Project Specific Instructions

## zone-server

* When adding a new exception always extend from `BestiaException` and assign a specific error code.

# Running Tests

The game is developed on different operating systems. When executing commands in the shell DO NOT use platform
specifics like the '&&' to combine to commands. This will not work on windows developer machines. Assume you are
on a Windows Powershell or determine the platform first.

